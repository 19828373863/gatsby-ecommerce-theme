<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>民工的自我修养</title>
  
  <subtitle>民工的自我修养</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-16T04:14:12.717Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>民工的自我修养</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/16/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/"/>
    <id>http://example.com/2023/11/16/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/</id>
    <published>2023-11-16T02:48:05.052Z</published>
    <updated>2023-11-16T04:14:12.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="纳税义务人、征税对象与税率-★"><a href="#纳税义务人、征税对象与税率-★" class="headerlink" title="纳税义务人、征税对象与税率(★)"></a>纳税义务人、征税对象与税率(★)</h1><h2 id="税率"><a href="#税率" class="headerlink" title="税率"></a>税率</h2><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116105009934.png" alt="image-20231116105009934"></p><h1 id="收入总额-★★★"><a href="#收入总额-★★★" class="headerlink" title="收入总额(★★★)"></a>收入总额(★★★)</h1><h2 id="一-一般收入的确认"><a href="#一-一般收入的确认" class="headerlink" title="(一)一般收入的确认"></a>(一)一般收入的确认</h2><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116105123483.png" alt="image-20231116105123483"></p><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116110834826.png" alt="image-20231116110834826"></p><p>【真题演练·单选题·2019年】2018年1月甲企业以1000万元直接投资乙企业，取得其40%股权。2019年10月甲企业将该股权全部转让，取得收入1200万元。股权转让时，乙企业累积的未分配利润200万元。甲企业该项投资业务的税务处理，正确的是()。</p><p>A. 甲企业该项投资业务的股息所得 80 万元</p><p>B.甲企业该项投资资产的转让所得120万元</p><p>C.甲企业转让该项股权应缴纳企业所得税50万元</p><p>D. 甲企业投资成本1000万元在持股期间均摊扣除</p><p>【答案】C</p><p>【解析】</p><p>(1)转让股权收入扣除为取得该股权所发生的成本后，为股权转让所得。</p><p>(2)企业在计算股权转让所得时，<strong>不得扣除被投资企业未分配利润等股东留存收益中按该项股权所可能分配的金额</strong>。</p><p>(3)股权转让所得&#x3D;1200-1000&#x3D;200(万元),甲企业该项投资业务应缴纳企业所得税&#x3D;200×25%(万元)。选项C正确。</p><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116111205066.png" alt="image-20231116111205066"></p><h2 id="特殊收入的确认"><a href="#特殊收入的确认" class="headerlink" title="特殊收入的确认"></a>特殊收入的确认</h2><table><thead><tr><th>情形</th><th>处理</th></tr></thead><tbody><tr><td>分期收款方式销售  货物</td><td>按照<strong>合同约定</strong>的收款日期确认收入的实现。</td></tr><tr><td>持续时间超过12  个月的劳务</td><td>企业受托加工制造大型机械设备、船舶、飞机等，以及从事建筑、安装、装配工  程业务或者提供劳务等，<strong>持续时间超过12个月</strong>的，按照纳税年度内完工进度或  者完成的工作量确认收入的实现。</td></tr><tr><td>采取产品分成方式  取得收入</td><td>以企业分得产品的日期确认收入的实现，其收入额按照产品的公允价值确定。</td></tr><tr><td>非货币性资产交换  及货物、财产、劳  务流出企业</td><td>企业发生非货币性资产交换，以及将货物、财产、劳务用于捐赠、偿债、赞助、  集资、广告、样品、职工福利和利润分配等用途的，应当视同销售货物、转让财  产或者提供劳务，另有规定除外。</td></tr></tbody></table><h2 id="处置资产收入"><a href="#处置资产收入" class="headerlink" title="处置资产收入"></a>处置资产收入</h2><table><thead><tr><th>类型</th><th>处理</th><th>举例</th></tr></thead><tbody><tr><td>内部处置资产</td><td>不视同销售确  认收入(除非  将资产<strong>移至境  外</strong> )</td><td>(1)将资产用于生产、制造、加工另一产品。<br />  (2)改变资产形状、结构或性能。  <br />(3)改变资产用途(如自建商品房转为自用或经营)。<br />  (4)将资产在总机构及其分支机构之间转移。<br />  (5)上述两种或两种以上情形的混合。<br />  (6)其他不改变资产所有权属的用途。</td></tr><tr><td>资产移送他人</td><td>资产所有权属  已发生改变，  按视同销售确  认收入</td><td>(1)用于市场推广或销售。 <br /> (2)用于交际应酬。  <br />(3)用于职工奖励或福利。 <br /> (4)用于股息分配。  <br />(5)用于对外捐赠。  <br />(6)其他改变资产所有权属的用途。</td></tr></tbody></table><p>(1)判断原则：资产所有权属在形式和实质上是否发生改变。</p><p>(2)将资产用于市场推广、用于交际应酬、其他改变资产所有权属的用途按视同销售征收企业所得税，但是会计不能确认收入。</p><p>(3)将资产用于市场推广、用于交际应酬、其他改变资产所有权属的用途按视同销售征</p><p>收企业所得税，但是会计不能确认收入(会计上只有将自产货物用于职工福利或个人消费才会</p><p>视同销售确认收入，其他情况会计均不作视同销售处理，不确认收入)。</p><table><thead><tr><th>行为</th><th>增值税</th><th>消费税</th><th>企业所得税</th></tr></thead><tbody><tr><td>将自产应税消费品连续生产应税消费品</td><td>不征</td><td>不征</td><td>不计收入</td></tr><tr><td>将自产应税消费品连续生产非应税消费品</td><td>不征</td><td>征税</td><td>不计收入</td></tr><tr><td>自产应税消费品在境内总机构与分支机构之间  转移，用于销售(同一县市的除外)</td><td>征税</td><td>征税</td><td>不计收入</td></tr><tr><td>将自产应税消费品用于赞助、集资、广告、样品、  职工福利、奖励</td><td>征税</td><td>征税</td><td>计收入征税</td></tr><tr><td>将自产应税消费品用于换取生产资料和消费资  料、投资入股、抵偿债务</td><td>按同类平均价  征税</td><td>按同类最高价  征税</td><td>按同类公允价  计收入征税</td></tr></tbody></table><h1 id="不征收收入和免税收入-★★★"><a href="#不征收收入和免税收入-★★★" class="headerlink" title="不征收收入和免税收入(★★★)"></a>不征收收入和免税收入(★★★)</h1><h2 id="一-不征税收入-调减"><a href="#一-不征税收入-调减" class="headerlink" title="(一)不征税收入(调减)"></a>(一)不征税收入(调减)</h2><p>1.财政拨款(对行政机关、事业单位拨付办公经费)。</p><p>2.依法收取并纳入财政管理的行政事业性收费、政府性基金。</p><p>3.国务院规定的其他不征税收入，是指企业取得的，由国务院财政、税务主管部门规定专项用途并经国务院批准的财政性资金。</p><p>例如：企业取得的来源于政府及其有关部门的财政补助、补贴、贷款贴息，以及其他各类财政专项资金，包括直接减免的增值税和即征即退、先征后退、先征后返的各种税收，但不包括企业按规定取得的出口退税款和增值税留抵退税款。(2023年新增)</p><p>符合不征税收入的财政性资金的条件：</p><ul><li><p>(1)企业能够提供规定资金专项用途的资金拨付文件；</p></li><li><p>(2)财政部门或其他拨付资金的政府部门对该资金有专门的资金管理办法或具体管理要求；</p></li><li><p>(3)企业对该资金以及以该资金发生的支出单独进行核算。</p></li></ul><blockquote><p>不征税收入由于收入不用计入应纳税所得额，因此其支出所形成的费用也不能税前扣除。免税收入用于支出形成的成本费用可以税前扣除，另有规定除外。</p></blockquote><h2 id="二-免税收入-调减"><a href="#二-免税收入-调减" class="headerlink" title="(二)免税收入(调减)"></a>(二)免税收入(调减)</h2><p>1.国债利息收入。</p><p>持有期间尚未兑付的国债利息收入，按以下公式计算确定：</p><p>(1)国债利息收入&#x3D;国债金额×(适用年利率÷<strong>365</strong>)×持有天数</p><p>国债金额：按照国债发行面值或发行价格确定</p><p>(2)转让国债收益(损失)&#x3D;企业转让或到期兑付国债取得的价款-购买国债成本-持有期间尚未兑付的国债利息收入一交易过程中相关税费</p><p>企业转让国债取得的收益(损失)应计算纳税</p><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116113337912.png" alt="image-20231116113337912"></p><p>2.符合条件的<strong>居民企业之间</strong>的股息、红利等权益性投资收益，是指居民企业直接投资于其他居民企业取得的投资收益；</p><p>3.在中国境内设立机构、场所的非居民企业从居民企业取得与该机构、场所有实际联系的股息、红利等权益性投资收益。</p><p>上述“(2)”和“(3)”所称的权益性收益(投资收益)均不包含连续持有居民企业公开发行并<strong>上市流通</strong>的股票不足12个月取得的投资收益。</p><blockquote><p>对内地企业投资者通过深港通投资香港联交所上市股票取得的股息红利所得、转让差价所得，计入其收入总额，依法计征企业所得税。其中，内地居民企业连续持有H股满12个月取得的股息红利所得，依法免征企业所得税。</p></blockquote><p>4.符合条件的非营利组织的收入：</p><p>(1)接受其他单位或者个人捐赠的收入；</p><p>(2)除《中华人民共和国企业所得税法》第七条规定的财政拨款以外的其他政府补助收入，但不包括因政府购买服务取得的收入；</p><p>(3)按照省级以上民政、财政部门规定收取的会费；</p><p>(4)不征税收入和免税收入孳生的银行存款利息收入；</p><p>(5)财政部、国家税务总局规定的其他收入。</p><p>5.企业取得的地方政府债券利息所得，免税。</p><p>6.境外机构投资境内债券市场取得的债券利息收入，免税。</p><p>7.(2023年新增)国际金融组织赠款收入、国内外机构、组织和个人的捐赠收入、基金资金的存款利息收入，免税。</p><p>8.(2023年新增)对非营利性科研机构、高等学校接收企业、个人和其他组织机构基础研究资金收入，免征企业所得税。</p><h1 id="扣除原则和项目-★★★"><a href="#扣除原则和项目-★★★" class="headerlink" title="扣除原则和项目(★★★)"></a>扣除原则和项目(★★★)</h1><p>税金，是指企业发生的除企业所得税和允许抵扣的增值税以外的企业缴纳的各项税金及附加。税金要么是当期直接扣除，要么计入了资产的成本，慢慢扣除。</p><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116113901886.png" alt="image-20231116113901886"></p><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116114146623.png" alt="image-20231116114146623"></p><h1 id="资产的税务处理-★★"><a href="#资产的税务处理-★★" class="headerlink" title="资产的税务处理(★★)"></a>资产的税务处理(★★)</h1><p>对单价500万元以上，最低折旧年限为4年、5年、10年的设备、器具，适用按一定比例一次性税前扣除政策的中小微企业，单位价值的50%按规定在剩余年度计算折旧进行税前扣除，具体规定见税收优惠部分。</p><h2 id="其他资产的税务处理"><a href="#其他资产的税务处理" class="headerlink" title="其他资产的税务处理"></a>其他资产的税务处理</h2><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116120916645.png" alt="image-20231116120916645"></p><h2 id="非货币性资产投资企业所得税处理-递延纳税、5年内"><a href="#非货币性资产投资企业所得税处理-递延纳税、5年内" class="headerlink" title="非货币性资产投资企业所得税处理(递延纳税、5年内)"></a>非货币性资产投资企业所得税处理(递延纳税、5年内)</h2><p>非货币性资产，是指现金、银行存款、应收账款、应收票据以及准备持有至到期的债券投</p><p>资等货币性资产以外的资产。</p><p><img src="/../../../pic/%E4%BC%81%E4%B8%9A%E6%89%80%E5%BE%97%E7%A8%8E/image-20231116121037313.png" alt="image-20231116121037313"></p><h1 id="房地产开发经营业务的所得税处理-★★"><a href="#房地产开发经营业务的所得税处理-★★" class="headerlink" title="房地产开发经营业务的所得税处理(★★)"></a>房地产开发经营业务的所得税处理(★★)</h1><h2 id="收入的税务处理"><a href="#收入的税务处理" class="headerlink" title="收入的税务处理"></a>收入的税务处理</h2><h3 id="1-销售收入的范围"><a href="#1-销售收入的范围" class="headerlink" title="1.销售收入的范围"></a>1.销售收入的范围</h3><p>销售开发产品过程中取得的<strong>全部价款，包括现金、现金等价物及其他经济利益</strong>。企业代有关部门、单位和企业收取的各种基金、费用和附加等，<strong>凡纳入开发产品价内或由企业开具发票的，应按规定全部确认为销售收入</strong>；未纳入开发产品价内并由企业之外的其他收取部门、单位开具发票的，可作为代收代缴款项进行管理。</p><h3 id="2-收入的实现规则"><a href="#2-收入的实现规则" class="headerlink" title="2.收入的实现规则"></a>2.收入的实现规则</h3><table><thead><tr><th>销售方式</th><th>确认收入规则</th></tr></thead><tbody><tr><td>一次性全  额收款</td><td>实际收讫价款或取得索取价款凭据(权利)之日</td></tr><tr><td>分期收款</td><td>应按销售合同或协议约定的价款和付款日确认收入的实现。付款方提前付款的， 在实际  付款日确认收入的实现。</td></tr><tr><td>银行按揭</td><td>应按销售合同或协议约定价款确定收入额，其首付款应于实际收到日确认收入的实现，  余款在银行按揭贷款办理转账之日确认收入的实现。</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;纳税义务人、征税对象与税率-★&quot;&gt;&lt;a href=&quot;#纳税义务人、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/16/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/"/>
    <id>http://example.com/2023/11/16/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/</id>
    <published>2023-11-16T02:35:37.924Z</published>
    <updated>2023-11-16T02:47:56.617Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/../../../pic/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/image-20231116103628267.png" alt="image-20231116103628267"></p><p>&#96;</p><p><img src="/../../../pic/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/image-20231116103757194.png" alt="image-20231116103757194"></p><p>国际税收是指对在两个或两个以上国家之间开展跨境交易行为征税的一系列税收法律规范</p><p>的总称。国家间对商品服务、所得、财产课税的<strong>制度差异</strong>是国际税收产生的基础。国际税收的</p><p>实质是国家之间的税收分配关系和税收协调关系。</p><h1 id="税收管辖权-★★"><a href="#税收管辖权-★★" class="headerlink" title="税收管辖权(★★)"></a>税收管辖权(★★)</h1><h1 id="国际税收抵免制度-★★★"><a href="#国际税收抵免制度-★★★" class="headerlink" title="国际税收抵免制度(★★★)"></a>国际税收抵免制度(★★★)</h1><blockquote><p>主观题。近几年基本上每年都会出现国际税收抵免的大题。考生重点掌握直接抵免法和间接抵免法的计算。</p></blockquote><h2 id="限额抵免概述"><a href="#限额抵免概述" class="headerlink" title="限额抵免概述"></a>限额抵免概述</h2><p>一般来说，抵免限额是指居住国(国籍国)允许居民(公民)纳税人从本国应纳税额中，扣除就其外国来源所得缴纳的外国税款的最高限额，即对跨国纳税人在外国已纳税款进行抵免的限度。</p><h2 id="我国的税收抵免制度"><a href="#我国的税收抵免制度" class="headerlink" title="我国的税收抵免制度"></a>我国的税收抵免制度</h2><h3 id="纳税人境外所得适用范围"><a href="#纳税人境外所得适用范围" class="headerlink" title="纳税人境外所得适用范围"></a>纳税人境外所得适用范围</h3><p><img src="/../../../pic/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/image-20231116104146022.png" alt="image-20231116104146022"></p><h3 id="抵免方法"><a href="#抵免方法" class="headerlink" title="抵免方法"></a>抵免方法</h3><p>境外税额抵免分为直接抵免和间接抵免。</p><p><img src="/../../../pic/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/image-20231116104304565.png" alt="image-20231116104304565"></p><h2 id="境外所得税额抵免计算的基本项目"><a href="#境外所得税额抵免计算的基本项目" class="headerlink" title="境外所得税额抵免计算的基本项目"></a>境外所得税额抵免计算的基本项目</h2><p>1.境内所得的应纳税所得额和分国(地区)别的境外所得的应纳税所得额；</p><p>2.分国(地区)别确定的可抵免境外所得税税额；</p><p>企业来源于中国境外的所得依照境外税收法律以及相关规定应当缴纳并已经实际缴纳的企业所得税性质的税款。</p><p>3.分国(地区)别确定境外所得税的抵免限额</p><p>4.将抵免限额与境外已纳税额比较，按较小一方抵免——确定实际抵免税额</p><p><strong>不应作为可抵免境外所得税税额</strong>的情形分析</p><p>(1)按照境外所得税法律及相关规定属于错缴或错征的境外所得税税款；</p><p>(2)按照税收协定规定不应征收的境外所得税税款；</p><p>(3)因少缴或迟缴境外所得税而追加的利息、滞纳金或罚款；</p><p>(4)境外所得税纳税人或其利害关系人从境外征税主体得到实际返还或补偿的境外所得税税款；</p><p>(5)按我国税法规定，已经免征我国企业所得税的境外所得负担的境外所得税税款；</p><p>(6)按照国务院财税部门有关规定已经从企业境外应纳税所得额中扣除的境外所得税税款。</p><h2 id="境外应纳税所得额的计算"><a href="#境外应纳税所得额的计算" class="headerlink" title="境外应纳税所得额的计算"></a>境外应纳税所得额的计算</h2><p><img src="/../../../pic/%E5%9B%BD%E9%99%85%E7%A8%8E%E6%94%B6/image-20231116104726919.png" alt="image-20231116104726919"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;img src=&quot;/../../../pic/%E5%9B%BD%E9%9</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/14/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/"/>
    <id>http://example.com/2023/11/14/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/</id>
    <published>2023-11-14T10:59:16.359Z</published>
    <updated>2023-11-15T02:40:53.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="解除劳动关系、提前退休、内部退养的一次性补偿金的个税处理"><a href="#解除劳动关系、提前退休、内部退养的一次性补偿金的个税处理" class="headerlink" title="解除劳动关系、提前退休、内部退养的一次性补偿金的个税处理"></a>解除劳动关系、提前退休、内部退养的一次性补偿金的个税处理</h1><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231114190015289.png" alt="image-20231114190015289"></p><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231114190058381.png" alt="image-20231114190058381"></p><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231114190231790.png" alt="image-20231114190231790"></p><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231114190256768.png" alt="image-20231114190256768"></p><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231114190409399.png" alt="image-20231114190409399"></p><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231114190420750.png" alt="image-20231114190420750"></p><h1 id="个人劳务报酬预扣预缴税率表"><a href="#个人劳务报酬预扣预缴税率表" class="headerlink" title="个人劳务报酬预扣预缴税率表"></a>个人劳务报酬预扣预缴税率表</h1><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231115103858787.png" alt="image-20231115103858787"></p><p>扣缴人向居民个人支付应税款项时，应当预扣或者代扣税款。</p><p><img src="/../../../pic/%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/image-20231115104050576.png" alt="image-20231115104050576"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;解除劳动关系、提前退休、内部退养的一次性补偿金的个税处理&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/14/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/"/>
    <id>http://example.com/2023/11/14/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E7%A8%8E%E6%B3%95%E4%B8%80/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/</id>
    <published>2023-11-14T05:08:12.255Z</published>
    <updated>2023-11-14T05:20:02.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本章整体变动小，新增“房地产开发企业缴纳的印花税列入管理费用，已相应予以扣除，因此不允许作为转让环节有关的税金重复扣除。其他土地增值税纳税义务人在计算土地增值税的允许在转让时缴纳的印花税，按产权转移书据记载的金额0.5‰计算”。</p></blockquote><p><img src="/../../../pic/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/image-20231114130939689.png" alt="image-20231114130939689"></p><p>土地增值税，是对<strong>转让国有土地使用权、地上建筑物及其附着物</strong>取得的<strong>增值额</strong>征收的一种税。</p><p>转让<strong>集体所有土地</strong>和<strong>出让</strong>国有土地的行为均<strong>不征税</strong>。</p><p><img src="/../../../pic/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/image-20231114131139542.png" alt="image-20231114131139542"></p><p><img src="/../../../pic/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/image-20231114131155901.png" alt="image-20231114131155901"></p><p>土地增值税采用四级超率累进税率，是我国唯一一个采用<strong>超率累进税率</strong>的税种。</p><p><img src="/../../../pic/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/image-20231114131259588.png" alt="image-20231114131259588"></p><p><img src="/../../../pic/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/image-20231114131311586.png" alt="image-20231114131311586"></p><p>纳税人转让房地产所取得的收入，是指转让房地产所取得的各种收入(<strong>不含增值税)</strong>,包括货币收入、实物收入和其他收入在内的全部价款及有关的经济利益。</p><p><img src="/../../../pic/%E5%9C%9F%E5%9C%B0%E5%A2%9E%E5%80%BC%E7%A8%8E/image-20231114131833851.png" alt="image-20231114131833851"></p><blockquote><p>对于代收费用作为转让收入计税的，在计算扣除项目金额时，可予以扣除，但不允许作为加计20%除的基数；对于代收费用未作为转让房地产的收入计税的，在计算增值额时不允许扣除代收费用。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;本章整体变动小，新增“房地产开发企业缴纳的印花税列</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/13/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/11/13/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/</id>
    <published>2023-11-13T04:03:38.598Z</published>
    <updated>2023-11-13T12:22:10.392Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="财务报表作用"><a href="#财务报表作用" class="headerlink" title="财务报表作用"></a>财务报表作用</h1><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113160543162.png" alt="image-20231113160543162"></p><h2 id="Balance-Sheet-x2F-资产负债表"><a href="#Balance-Sheet-x2F-资产负债表" class="headerlink" title="Balance Sheet&#x2F;资产负债表"></a>Balance Sheet&#x2F;资产负债表</h2><p>和投资活动联系。</p><h2 id="Income-statement-x2F-损益表"><a href="#Income-statement-x2F-损益表" class="headerlink" title="Income statement&#x2F;损益表"></a>Income statement&#x2F;损益表</h2><p>日常管理。</p><h2 id="Statement-of-Cash-Flows-x2F-现金流量表"><a href="#Statement-of-Cash-Flows-x2F-现金流量表" class="headerlink" title="Statement of Cash Flows&#x2F;现金流量表"></a>Statement of Cash Flows&#x2F;现金流量表</h2><p>日常管理。</p><h2 id="Statement-of-Shareholders’-Equity-x2F-股东权益变动表"><a href="#Statement-of-Shareholders’-Equity-x2F-股东权益变动表" class="headerlink" title="Statement of Shareholders’ Equity&#x2F;股东权益变动表"></a>Statement of Shareholders’ Equity&#x2F;股东权益变动表</h2><p>融资。</p><h1 id="重要的会计原则"><a href="#重要的会计原则" class="headerlink" title="重要的会计原则"></a>重要的会计原则</h1><blockquote><p> <strong>GAAP</strong> :通用会计原则”（Generally Accepted Accounting Principles）</p></blockquote><p>国际会计准则（International Accounting Standards，IAS）</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113164938463.png" alt="image-20231113164938463"></p><h2 id="Historical-Cost-x2F-历史成本"><a href="#Historical-Cost-x2F-历史成本" class="headerlink" title="Historical Cost&#x2F;历史成本"></a>Historical Cost&#x2F;历史成本</h2><p>企业购入资产时的<strong>账面价值</strong>。</p><p> fair &amp; objective values from arm’s-length  bargaining &#x2F;来自独立谈判的公平和客观价值。</p><h2 id="Accrual-Accounting-x2F-权责发生制"><a href="#Accrual-Accounting-x2F-权责发生制" class="headerlink" title="Accrual Accounting  &#x2F;权责发生制"></a>Accrual Accounting  &#x2F;权责发生制</h2><p> recognize revenues when earned,  expenses when incurred 。</p><p> 在收入实现时确认收入，在发生费用时确认费用。</p><h2 id="Materiality-x2F-重要性原则"><a href="#Materiality-x2F-重要性原则" class="headerlink" title="Materiality &#x2F;重要性原则"></a>Materiality &#x2F;重要性原则</h2><p>threshold when information impacts decision  making &#x2F;信息对决策产生影响的门槛。</p><p>当某项信息<strong>对于决策者的决策产生实质性影响时</strong>，该信息应被视为重大的，需要在财务报表中进行充分披露。</p><h2 id="Conservatism-x2F-谨慎性原则"><a href="#Conservatism-x2F-谨慎性原则" class="headerlink" title="Conservatism  &#x2F;谨慎性原则"></a>Conservatism  &#x2F;谨慎性原则</h2><p>reporting or disclosing the least optimistic  information about uncertain events and transactions&#x2F;在报告或披露不确定事件和交易时提供最不乐观的信息。</p><p>强调在面对不确定性时，会计师应该偏向选择较为<strong>保守的估计和处理方法</strong>，以反映可能产生的风险和损失，而对潜在利益进行较为谨慎的处理。如<strong>不应高估收益，低估风险、费用</strong>。</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113125144302.png" alt="image-20231113125144302"></p><p><strong>Relevance</strong>&#x2F;相关性：与生产经营相关。</p><ul><li>Predictive value：预测性；能够通过一些会计科目对利润表项目、资产负债表项目和现金流量表项目进行判断、预计和估算。</li><li>confirmatory value:可验证性；能够通过过去的数据来预测现在的会计项目，如果二者相差过大，则可能存在问题。</li><li>materiality：重要性；如果一项错报单独或连同其他错报可 能影响财务报表使用者依据财务报表<strong>作出的经济决策</strong>, 则该项错报是重大<strong>的</strong>。</li></ul><p><strong>Faithful representation</strong>：忠实报道；一笔事项发生时，就如实的记录；没发生，就不要杜撰。</p><ul><li><p>Completeness：完备性</p></li><li><p>Neutrality :<strong>中立</strong>性；会计人员在实施会计准则时要不偏不倚，即要求信息不受偏见的影响，为信息使用者提供有用的会计信息。<strong>按照对shareholders有利方式记账。</strong>shareholders就是股东；managers：企业高层</p></li></ul><p>使用会计信息的人：<strong>投资者</strong>，政府，企业，以及和企业有利害关系的人，包括企业管理层。</p><p>Comparability：可比性（和自身的过去可比，和同行业其他企业可比）；</p><p>Verifiability：可核实性，能够与债权人核实；</p><p>timelineness：时效性；</p><p>understandability：易懂性；</p><h1 id="Cash-Basis-and-Accrual-basis-summary-x2F-收付实现制和权责发生制"><a href="#Cash-Basis-and-Accrual-basis-summary-x2F-收付实现制和权责发生制" class="headerlink" title="Cash Basis and Accrual-basis summary&#x2F;收付实现制和权责发生制"></a>Cash Basis and Accrual-basis summary&#x2F;收付实现制和权责发生制</h1><blockquote><p>权责发生制：权责发生制指凡是在本期内已经收到和已经发生或应当负担的一切费用，不论其款项是否收到或付出，都作为本期的收入和费用处理；反之，凡不属于本期的收入和费用，即使款项在本期收到或付出，也不应作为本期的收入和费用处理。</p><p>收付实现制，又称现金制或实收实付制是以<strong>现金收到或付出为标准</strong>，来记录收入的实现和费用的发生。</p></blockquote><p>2014年1月，坎特伯雷向1,000名客户销售其季刊杂志的为期三年的订阅。</p><p>客户一次性支付全额订阅费（$300 &#x3D; 12x$25）。</p><p>坎特伯雷申请了10万美元的三年期贷款。2016年12月31日<strong>到期时支付</strong>年利率10%的利息。</p><p>出版和分发杂志的成本每年为$60,000，并在出版时现金支付。</p><h2 id="收付实现制-x2F-Cash-Basis-Income-Determination"><a href="#收付实现制-x2F-Cash-Basis-Income-Determination" class="headerlink" title="收付实现制&#x2F;Cash-Basis Income Determination"></a>收付实现制&#x2F;Cash-Basis Income Determination</h2><table><thead><tr><th>收付实现制</th><th>2014</th><th>2015</th><th>2016</th></tr></thead><tbody><tr><td>Cash inflows&#x2F;现金流入</td><td>$300,000</td><td>$0</td><td>$0</td></tr><tr><td>Cash outflows for production and distribution&#x2F;现金流出（生产和分发成本）</td><td>$60,000</td><td>$60,000</td><td>$60,000</td></tr><tr><td>Cash outflow for loan interest&#x2F;现金流出（利息支出）</td><td>$0</td><td>$0</td><td>$30,000</td></tr><tr><td>Net Income (loss)-Cash Basis（收付实现制下的净损益）</td><td>$240，000</td><td>-$60,000</td><td>-$90,000</td></tr></tbody></table><h2 id="权责发生制-x2F-Accrual-basis-summary"><a href="#权责发生制-x2F-Accrual-basis-summary" class="headerlink" title="权责发生制&#x2F;Accrual-basis summary"></a>权责发生制&#x2F;Accrual-basis summary</h2><table><thead><tr><th>权责发生制</th><th>2014</th><th>2015</th><th>2016</th></tr></thead><tbody><tr><td>Revenues recognized as earned&#x2F;收入的确认</td><td>$100,000</td><td>$100,000</td><td>$100,000</td></tr><tr><td>Expenses-Magazine costs&#x2F;杂志成本</td><td>$60,000</td><td>$60,000</td><td>$60,000</td></tr><tr><td>Expenses-Interest accrued&#x2F;利息费用</td><td>$10,000</td><td>$10,000</td><td>$10,000</td></tr><tr><td>Net Income</td><td>$30,000</td><td>$30,000</td><td>$30,000</td></tr></tbody></table><p>在收付实现制下，<strong>收入应该在其整个履约期间按履约进度均匀确认</strong>。</p><p><strong>利息费用也应该均匀分摊在整个借款期间</strong>。</p><h1 id="Auditing-Report-x2F-审计意见"><a href="#Auditing-Report-x2F-审计意见" class="headerlink" title="Auditing Report&#x2F;审计意见"></a>Auditing Report&#x2F;审计意见</h1><h2 id="clean-opinion-x2F-unqualified-opinion-x2F-无保留意见"><a href="#clean-opinion-x2F-unqualified-opinion-x2F-无保留意见" class="headerlink" title="clean opinion &#x2F; unqualified opinion &#x2F;无保留意见"></a>clean opinion &#x2F; unqualified opinion &#x2F;无保留意见</h2><ul><li><strong>free of any misrepresentations</strong>.</li><li><strong>prepared by an unbiased third party</strong>.</li></ul><p>我们认为，后附的财务报表在所有重大方面按照企业会计准则的规定编制，<strong>公允</strong>反映了……</p><h2 id="clean-opinion-with-some-of-the-items-to-be-strengthend-x2F-带强调事项的无保留意见"><a href="#clean-opinion-with-some-of-the-items-to-be-strengthend-x2F-带强调事项的无保留意见" class="headerlink" title="clean opinion with some of the items to be strengthend&#x2F;带强调事项的无保留意见"></a>clean opinion with some of the items to be strengthend&#x2F;带强调事项的无保留意见</h2><p><strong>强调事项</strong></p><p>我们提醒财务报表使用者关注……。</p><blockquote><p>在clean opinion 的基础上多了一个items to be strengthend（强调事项）。</p></blockquote><h2 id="qualified-opinion-x2F-保留意见"><a href="#qualified-opinion-x2F-保留意见" class="headerlink" title="qualified opinion&#x2F;保留意见"></a>qualified opinion&#x2F;保留意见</h2><ul><li><strong>not been maintained in accordance with GAAP</strong></li><li><strong>no misrepresentations are identified</strong></li></ul><p>In situations when a company’s financial records have <strong>not been</strong> <strong>maintained in accordance with GAAP</strong> <strong>but no misrepresentations are identified</strong>, an auditor will issue a qualified opinion. The writing of a qualified opinion is extremely similar to that of an unqualified opinion. A qualified opinion, however, will include an additional paragraph that highlights the reason why the audit report is not unqualified.</p><p>在一个公司的财务记录没有按照通用会计准则（GAAP）进行维护的情况下，但没有发现虚假陈述时，审计师会发布一个保留意见（qualified opinion）。保留意见的写作方式与无保留意见非常相似，但是保留意见会包括一个额外的段落，说明为什么审计报告不是无保留的。</p><p>例：我们审计了深圳市惠程信息科技股份有限公司(以下简称“贵公司”)的财务报表，包括2020年12月31日的合并及母公司资产负债表，2020年度的合并及母公司利润表、合并及母公司现金流量表、合并及母公司股东权益变动表，以及财务报表附注。</p><p>我们认为，除“<strong>形成保留意见的基础</strong>”部分所述事项产生的影响外，后附的财务报表在所有重大方面按照企业会计准则的规定编制，公允反映了贵公司2020年12月31日的台并及母公司财务状况以及2020年度的合并及母公司的经营成果和现金流量。</p><h2 id="adverse-opinion-x2F-否定意见"><a href="#adverse-opinion-x2F-否定意见" class="headerlink" title="adverse opinion &#x2F;否定意见"></a>adverse opinion &#x2F;否定意见</h2><ul><li><p>Accounting methods <strong>seriously violate</strong> the Accounting Standards for Enterprises&#x2F;在<strong>重大事项</strong>上违反企业会计准则。</p></li><li><p>Accounting statements <strong>seriously distort the financial status, operating results and changes of cash flow</strong>, and the firm being audited refuse to adjust。会计报表<strong>严重扭曲了财务状况、经营成果和现金流量变动</strong>，而经审计的公司拒绝进行调整。</p></li></ul><p>Certified public accountants may express reservations when unadjusted, uncertain and inconsistent matters affect accounting statements to a certain extent. However, <strong>if the impact is beyond a certain range, so that the accounting statements can not be accepted</strong>, and the audited firms’ accounting statements have lost their value, CPAs can not express reservations, nor should they not express opinions, but can only express negative opinions.</p><p>注册会计师可能在未调整的、不确定的和不一致的事项对会计报表产生一定程度的影响时表示保留意见。但<strong>如果影响超出了一定范围，以至于会计报表无法被接受</strong>，经审计的公司的会计报表已经失去了其价值，注册会计师不能表示保留意见，也不应该不表达任何意见，只能表达<strong>否定意见</strong>。</p><h2 id="disclaimer-of-opinion-x2F-无法表示意见"><a href="#disclaimer-of-opinion-x2F-无法表示意见" class="headerlink" title="disclaimer of opinion&#x2F;无法表示意见"></a>disclaimer of opinion&#x2F;无法表示意见</h2><ul><li><strong>impossible  to obtain sufficient and appropriate audit evidence</strong> &#x2F;无法获得财务信息，无法表示意见。</li></ul><h1 id="收入的确认与计量"><a href="#收入的确认与计量" class="headerlink" title="收入的确认与计量"></a>收入的确认与计量</h1><h2 id="在某一时间点确认收入"><a href="#在某一时间点确认收入" class="headerlink" title="在某一时间点确认收入"></a>在某一时间点确认收入</h2><p>客户交付现金后，公司的<strong>履约义务在某一瞬间立刻完成</strong>。</p><h2 id="在某一期间确认收入"><a href="#在某一期间确认收入" class="headerlink" title="在某一期间确认收入"></a>在某一期间确认收入</h2><ul><li><p>公司提供了一项服务，这个服务需要三年才能完成，比如三年的保洁服务或者是营造一栋大楼。</p></li><li><p>按时间进度，如保洁服务。</p></li><li><p>按<strong>工程成本进度</strong>，如营造大楼。</p></li></ul><p>一栋大楼，建成之后付给企业10亿元。企业预计成本1亿。当企业发生3000万成本的时候，企业就该认为这个工程已经完成了30%。应该确认3亿元的收入。</p><p>权责发生制指凡是在本期内已经收到和已经发生或应当负担的一切费用，不论其款项是否收到或付出，都作为本期的收入和费用处理；反之，凡不属于本期的收入和费用，即使款项在本期收到或付出，也不应作为本期的收入和费用处理。</p><h1 id="Expense-Recognition-x2F-费用的确认"><a href="#Expense-Recognition-x2F-费用的确认" class="headerlink" title="Expense Recognition&#x2F;费用的确认"></a><strong>Expense Recognition</strong>&#x2F;费用的确认</h1><p>Kahn Distribution Limited (KDL) purchases inventory items for resale. During 2006, Kahn had the following transactions:</p><p>KD有限责任公司采购用于转售的库存物品。在2006年，Kahn进行了以下交易：</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113144937688.png" alt="image-20231113144937688"></p><p>Inventory sales during the year were 5,600 units at $50 per unit. </p><p>KDL determines that there were 2,000 remaining units of inventory and specifically identifies that 1,900 were those purchased in the fourth quarter and 100 were purchased in the third quarter. </p><p>What are the revenue and expense associated with these transactions during 2006?</p><p> 5600+2000&#x3D;7600 units in total. Within the remaining 2000 units, 1900 from 4th quarter, 100 from 3rd quarter.</p><p>在2006年，库存销售了5,600个单位，每个单位售价为50美元。</p><p>KDL确定库存中还有2,000个单位，并明确指出其中1,900个单位是在第四季度购买的，100个单位是在第三季度购买的。在这些交易中，与之相关的收入和费用如下：</p><p>收入：销售额 &#x3D; 销售单位数 × 每单位售价 &#x3D; 5,600 × 50 &#x3D; 280,000美元</p><p>费用：购买的库存物品费用 &#x3D; 1,900 × 单位成本 + 100 × 单位成本</p><p>请提供单位成本或总购买成本以便计算相关费用。</p><h2 id="存货成本计算方法"><a href="#存货成本计算方法" class="headerlink" title="存货成本计算方法"></a><strong>存货成本计算方法</strong></h2><p><strong>First in first out method (FIFO)</strong>&#x2F;<strong>先进先出法</strong></p><p>it is simply assumed that the earliest items purchased were sold first.</p><p>这里简单地假设最早购买的商品先卖出。</p><p>So the goods bought in first quarter, 2nd quarter and partially 3rd quarter are been sold out in order, remaining 100 units unsold in inventory for 3rd quarter and 1900 units unsold in 4th quarter, this is exactly the same as the <strong>Specific</strong> <strong>identification method</strong> in this case**.**</p><p>因此，<strong>按顺序销售</strong>了在第一季度、第二季度和部分第三季度购买的商品，剩下的100个单位库存未售出属于第三季度购买的，并且剩下的1900个单位库存未售出属于第四季度购买的。这与这种情况下的“特定识别法”完全相同。</p><p>共卖出了5,600单位，其中第一季度2000，第二季度1500，第三季度2100，第四季度0。</p><p>再根据每个季度购买成本计算出总成本。</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113145937775.png" alt="image-20231113145937775"></p><blockquote><p>先进先出法在物价持续上升时，期末存货成本接近于市价，而发出成本偏低，会高估企业当期<a href="https://www.dongao.com/wdzt/cjks_lirun/">利润</a>和库存存货价值；物价下降时，则会低估企业当期利润和库存存货价值。后进先出法相反。</p></blockquote><h1 id="Depreciation-and-Amortization-x2F-折旧和摊销"><a href="#Depreciation-and-Amortization-x2F-折旧和摊销" class="headerlink" title="Depreciation and Amortization&#x2F;折旧和摊销"></a>Depreciation and Amortization&#x2F;折旧和摊销</h1><p><strong>Straight - line method</strong> allocates evenly the cost of long - lived assets less estimated residual value over the estimated useful life of an asset</p><p>“直线法”将长期资产成本（减去估计残值）平均分配到资产的估计使用寿命上。</p><p>Under IAS No. 16, the residual value is the amount that the company expects to receive upon sale of the asset at the end of its useful life</p><p>根据《国际会计准则第16号》（IAS No. 16），残值是公司预计在资产使用寿命结束时在销售该资产时预计收到的金额。</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113150636907.png" alt="image-20231113150636907"></p><h1 id="EPS"><a href="#EPS" class="headerlink" title="EPS"></a>EPS</h1><blockquote><p>基本每股收益是指企业应当按照**属于<a href="https://baike.baidu.com/item/%E6%99%AE%E9%80%9A%E8%82%A1/648529?fromModule=lemma_inlink">普通股</a>股东的当期<a href="https://baike.baidu.com/item/%E5%87%80%E5%88%A9%E6%B6%A6/5352725?fromModule=lemma_inlink">净利润</a>**，除以发行在外普通股的<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E6%95%B0/2580366?fromModule=lemma_inlink">加权平均数</a>从而计算出的<a href="https://baike.baidu.com/item/%E6%AF%8F%E8%82%A1%E6%94%B6%E7%9B%8A/2429458?fromModule=lemma_inlink">每股收益</a>。</p></blockquote><blockquote><p>普通股股东。</p></blockquote><p>EPS 是美国通用会计准则（U.S. GAAP）要求公司披露的唯一额外财务指标。</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113152009386.png" alt="image-20231113152009386"></p><p><strong>加权平均数</strong>：假定年初1000股流通股，年中<strong>8月1日</strong>发行1000流通股，当年的加权平均股数为1000+1000×<strong>5&#x2F;12</strong>&#x3D;1000×7&#x2F;12+ 2000×5&#x2F;12股。</p><p>Firms have <strong>simple capital structures</strong> if they do not have 1. outstanding convertible bonds or convertible preferred stock that holders can exchange for shares of common stock. 2. options or warrants that holders can use to acquire common stock.</p><p>如果公司没有可转换债券或可转换优先股（持有人可以用来交换普通股的证券），也没有持有人可以使用来获取普通股的期权或认股权证，那么该公司的资本结构可以称为<strong>简单资本结构</strong>。</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113154739631.png" alt="image-20231113154739631"></p><p>年初4000 outstanding shares ，年末3000 outstanding shares ，库存股1000；</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113154549405.png" alt="image-20231113154549405"></p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113154614494.png" alt="image-20231113154614494"></p><blockquote><p><a href="https://baike.baidu.com/item/%E7%A8%80%E9%87%8A%E6%AF%8F%E8%82%A1%E6%94%B6%E7%9B%8A/5961395?fromModule=lemma_inlink">稀释每股收益</a>（Fully Diluted Earnings Per Share）稀释<a href="https://baike.baidu.com/item/%E6%AF%8F%E8%82%A1%E6%94%B6%E7%9B%8A/2429458?fromModule=lemma_inlink">每股收益</a>是以基本每股收益为基础，假设企业所有发行在外的<a href="https://baike.baidu.com/item/%E7%A8%80%E9%87%8A%E6%80%A7%E6%BD%9C%E5%9C%A8%E6%99%AE%E9%80%9A%E8%82%A1/9800499?fromModule=lemma_inlink">稀释性潜在普通股</a><a href="https://baike.baidu.com/item/%E5%9D%87%E5%B7%B2/6068131?fromModule=lemma_inlink">均已</a>转换为普通股，从而分别调整归属于普通股股东的当期<a href="https://baike.baidu.com/item/%E5%87%80%E5%88%A9%E6%B6%A6?fromModule=lemma_inlink">净利润</a>以及发行在外普通股的<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E6%95%B0?fromModule=lemma_inlink">加权平均数</a>计算而得的每股收益。</p></blockquote><p>潜在普通股：可转债，认股权证；他们在一定条件下，可以转化为普通股。</p><p>稀释性普通股：潜在普通股转化之后，会降低EPS。</p><p>Firms that have convertible securities and&#x2F;or stock options or warrants outstanding have complex capital structures. <strong>Dilution</strong> refers to the reduction in basic EPS that would result if holders of convertible securities exchanged them for shares of common stock or if holders of stock options or warrants exercised them.</p><p>具有可转换证券和&#x2F;或待定的股票期权或认股权证的公司拥有复杂的资本结构。<strong>稀释指的是如果可转换证券持有人将其转换为普通股，或者如果股票期权或认股权证持有人行使这些权利的话，会导致基本每股收益的降低。</strong></p><p>假设Dog公司的资本结构与Cat公司相同，除了Dog公司的<u>500优先股可以转换为1,000股普通股外</u>。另外假设Dog公司有待定的股票期权，持有人可以当前以300股额外普通股进行交换。计算稀释每股收益的方法如下：</p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113154433711.png" alt="image-20231113154433711"></p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113154636773.png" alt="image-20231113154636773"></p><blockquote><p>稀释每股收益：假设这些认股权证，可转债在年初<strong>全部</strong>转换为普通股。</p></blockquote><p>The calculation assumes the conversion of the convertible preferred stock into common stock as of January 1. If conversion had taken place, the firm would have had no preferred dividends during the year. Thus, the accountant adds back $500 of preferred dividends to the numerator. The weighted-average number of shares in the denominator increases for the 1,000 common shares the firm would issue on conversion of the preferred stock. The weighted-average number of shares in the denominator also increases for the incremental shares issuable under stock option plans.</p><p>该计算假设可转换优先股在<strong>1月1日转换为普通股</strong>。如果进行了转换，公司<strong>在该年期间将不会支付优先股股息</strong>。因此，会计师将500美元的优先股股息添加回分子部分。分母部分的加权平均股数会增加将来在优先股转换为1,000股普通股时发行的普通股份。分母部分的加权平均股数还会增加根据股票期权计划可以发行的额外股份</p><h1 id="ROA"><a href="#ROA" class="headerlink" title="ROA"></a>ROA</h1><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113155534777.png" alt="image-20231113155534777"></p><p><img src="/../../pic/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/image-20231113155627356.png" alt="image-20231113155627356"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;财务报表作用&quot;&gt;&lt;a href=&quot;#财务报表作用&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/11/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E4%BC%9A%E8%AE%A1/8.%E6%89%80%E5%BE%97%E7%A8%8E/"/>
    <id>http://example.com/2023/11/11/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E4%BC%9A%E8%AE%A1/8.%E6%89%80%E5%BE%97%E7%A8%8E/</id>
    <published>2023-11-11T12:59:26.934Z</published>
    <updated>2023-11-11T12:59:26.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>3.财务管理-投资管理概述</title>
    <link href="http://example.com/2023/11/07/%E7%A8%8E%E5%8A%A1%E5%B8%88/4.%E6%8A%95%E8%B5%84%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/11/07/%E7%A8%8E%E5%8A%A1%E5%B8%88/4.%E6%8A%95%E8%B5%84%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</id>
    <published>2023-11-07T14:09:24.784Z</published>
    <updated>2023-11-07T15:17:34.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="投资管理概述"><a href="#投资管理概述" class="headerlink" title="投资管理概述"></a>投资管理概述</h1><p>投资是指企业把资金直接或间接投放于一定对象，以期望在未来获取收益的经济活动。</p><table><thead><tr><th>分类标准</th><th>具体类型</th><th></th></tr></thead><tbody><tr><td>投资回收期限的长短</td><td>短期投资</td><td>回收期在1年以内的投资，如短期有价证券投资</td></tr><tr><td>投资回收期限的长短</td><td>长期投资</td><td>回收期在1年以上的投资，如固定资产投资</td></tr><tr><td>资金投出的方向</td><td>对内投资</td><td>把资金投向企业内部，如形成无形资产的投资</td></tr><tr><td>资金投出的方向</td><td>对外投资</td><td>把资金投向企业外部，如购买其他公司的债券</td></tr><tr><td>投资活动与公司本身的生产经营  活动的关系</td><td>直接投资</td><td><strong>把资金投放于形成生产经营能力的实体性资产，  直接谋取经营利润的投资行为</strong></td></tr><tr><td>投资活动与公司本身的生产经营活动的关系</td><td>间接投资</td><td>把资金投放于股票、债券等权益性资产上的投资  行为，以<strong>获取投资收益和资本利息</strong></td></tr></tbody></table><h1 id="固定资产投资管理"><a href="#固定资产投资管理" class="headerlink" title="固定资产投资管理"></a>固定资产投资管理</h1><h2 id="固定资产投资的特点与意义"><a href="#固定资产投资的特点与意义" class="headerlink" title="固定资产投资的特点与意义"></a>固定资产投资的特点与意义</h2><p>固定资产投资又称项目投资，具有投资数额大、影响时间长(至少1年或一个营业周期以上)、发生频率低、变现能力差和投资风险高的特点。</p><p>从宏观角度看，项目投资有助于促进社会经济的长期可持续发展；能够为社会提供更多的就业机会，提高社会总供给量。</p><p>从微观角度看，项目投资能够增强企业经济实力，提高企业创新能力和市场竞争能力。</p><h2 id="投资项目现金流量估计【★★★】"><a href="#投资项目现金流量估计【★★★】" class="headerlink" title="投资项目现金流量估计【★★★】"></a>投资项目现金流量估计【★★★】</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>只有增量现金流量才是与项目相关的现金流量。</p><p>所谓增量现金流量，是指<strong>接受或拒绝某个投资方案后，企业总现金流量因此发生的变动</strong>。要树立一种整体的观念，不要仅仅局限于这个项目本身。</p><p>净现金流量是指现金流入量与现金流出量之差。</p><table><thead><tr><th>维度</th><th>解读</th></tr></thead><tbody><tr><td>相关成本和  非相关成本</td><td><strong>相关成本</strong>是指与特定决策有关的、在分析评价时<strong>必须加以考虑的成本</strong>。例如，差额成本、未来成本、重置  成本、机会成本等；<strong>非相关成本</strong>是与特定决策无关的、在分析评价时<strong>不必加以考虑的成本</strong>。例如，<u>沉没成本、过去成本、账面成本</u>等</td></tr><tr><td>机会成本</td><td>在投资方案的选择中，如果选择了一个投资方案，则  必须放弃投资于其他途径的机会。其他投资机会可能  取得的收益是实行本方案的一种代价，被称为这项投  资方案的机会成本</td></tr><tr><td>投资方案对公司 其他项目的影响</td><td>当采纳一个新的项目后，该项目可能对公司的其他项  目造成有利或不利的影响</td></tr></tbody></table><h3 id="营运资金"><a href="#营运资金" class="headerlink" title="营运资金"></a>营运资金</h3><p>所谓<strong>营运资金的需要</strong>，指<strong>增加的经营性流动资产与增加的经营性流动负债之间的差额</strong>。</p><p>营运资金一般在经营期的期初投入，并随着生产规模的扩大而追加。流动资金投资额估算方法如下：</p><p>某年流动资金投资额(垫支数)&#x3D;本年流动资金需用额-截至上年的流动资金投资额</p><p>或:</p><p>某年流动资金投资额(垫支数) &#x3D;本年流动资金需用额-上年流动资金需用额</p><p>本年流动资金需用额&#x3D;本年流动资产需用额-本年流动负债需用额</p><blockquote><p> 提示:在进行投资分析时，通常假定开始时投资的营运资金在项目结束时收回。</p></blockquote><h1 id="有价证券投资管理"><a href="#有价证券投资管理" class="headerlink" title="有价证券投资管理"></a>有价证券投资管理</h1><h2 id="股票投资"><a href="#股票投资" class="headerlink" title="股票投资"></a>股票投资</h2><h3 id="股票投资的优缺点"><a href="#股票投资的优缺点" class="headerlink" title="股票投资的优缺点"></a>股票投资的优缺点</h3><table><thead><tr><th>优点</th><th>解读</th></tr></thead><tbody><tr><td>投资收益高</td><td>虽然普通股票的价格变动频繁，但优质股票的价格总是呈  上涨趋势。只要投资决策正确，股票投资收益是比较高的</td></tr><tr><td>能降低购买力  的损失</td><td>普通股票的股利是不固定的，其随着股份公司收益的增长  而提高。在通货膨胀时期，股份公司的收益增长率一般仍  大于通货膨胀率，股东获得的股利可全部或部分抵消通货  膨胀带来的购买力损失</td></tr><tr><td>流动性很强</td><td>上市公司股票的流动性很强，投资者有闲散资金可随时买  入，需要资金时又可随时卖出</td></tr><tr><td>能达到控制股  份公司的目的</td><td>投资者是股份公司的股东，有权参与或监督公司的生产经  营活动。当投资者的投资额达到公司股本一定比例时，就  能实现控制公司的目的</td></tr></tbody></table><p>股票投资的主要缺点是投资风险较大。</p><h3 id="股票的估价模型"><a href="#股票的估价模型" class="headerlink" title="股票的估价模型"></a>股票的估价模型</h3><p>1.股票估价的基本模型</p><p>由于普通股票的价值是通过各年股利所形成的现金流人量表示出来的，因此，将各年股利的现值加总即为普通股票的价值。</p><p>2.零增长模型</p><p>零增长模型是普通股票的<strong>股利增长速度为 0</strong> , 即每年的股利保持不变, 这种股票价值的估价模型为: ${P}&#x3D;{d}_0 \div {k}$ 。</p><p>式中, ${P}$ 表示普通股票的价值; ${d}_0$ 表示上一期支付的固定股利; $k$ 表示投资者要求的报酬率。</p><blockquote><p>就相当于是一个永续债。</p></blockquote><p>3.固定增长模型</p><p>若普通股票的股利每年都增长, 并且增长速度相等, 这种条件下, 普通股票估价的计算公式为:$$\mathrm{P}&#x3D;\left[\mathrm{d}_0 \times(1+\mathrm{g})\right] &#x2F;(\mathrm{k}-\mathrm{g})&#x3D;\mathrm{d}_1 &#x2F;(\mathrm{k}-\mathrm{g})$$</p><p>式中，P表示普通股票的价值； ${d}_0$表示上一期支付的股利；</p><p>${d}_1$ 表示下一期预计支付的股利; ${g}$ 表示股利的增长率; ${k}$ 表示投资者要求的报酬率，并且 ${k}$ 大于 ${g}$ 。</p><h2 id="债券投资"><a href="#债券投资" class="headerlink" title="债券投资"></a>债券投资</h2><h3 id="债券投资的优缺点"><a href="#债券投资的优缺点" class="headerlink" title="债券投资的优缺点"></a>债券投资的优缺点</h3><p>1.优点</p><table><thead><tr><th>优点</th><th>解读</th></tr></thead><tbody><tr><td>投资收益  比较稳定</td><td>债券收益主要包括利息和买卖差价两部分。由于债券票面一  般标有固定利率，而发行单位又有按规定支付利息的法定义  务，所以利息收入是稳定的；同样，由于债券的未来利息比  较稳定，所以，债券的转让价格及买卖价差也比较稳定</td></tr><tr><td>投资  安全性好</td><td>政府债券有国家的财力作后盾，通常称为无风险债券；公司  债券优先于股票求偿，保证了债券投资的安全性优于股票</td></tr></tbody></table><p>2.债券投资的缺点</p><p>购买债券不能达到参与和控制发行企业经营管理活动的目的。</p><h3 id="债券的估值模型"><a href="#债券的估值模型" class="headerlink" title="债券的估值模型"></a>债券的估值模型</h3><p><strong>1.一年付息一次的债券估价模型</strong></p><p>一年付息一次的债券，是指每年年底债券的持有人都会得到当年的利息，在债券到期日收回债券的本金，该债券的价值可由下式计算：</p><p>债券价值&#x3D;每年利息现值合计+到期日本金现值</p><p>其中：</p><p>每年利息&#x3D;债券面值×票面利率</p><p><strong>2.到期一次还本付息的债券估价模型</strong></p><p>这种债券在未到期之前不支付利息，当债券到期时，一次支付全部的本金及利息，一般情况下，这种债券的利息是按单利计息。到期一次还本付息的债券估价模型为：</p><p>债券的价值&#x3D;债券到期日本金与利息的现值</p><p>债券到期日本金与利息之和&#x3D;债券面值+债券面值×票面利率×债券期限</p><p><strong>3.贴现发行债券的估价模型</strong></p><p><u>贴现发行</u>的债券是在债券上没有票面利率，只有票面值的债券。在债券发行时，以低于票面值的价格发行，到期时按面值偿还，面值与发行价格的差额作为债券的利息。贴现发行债券的估价模型为：</p><p>债券价值&#x3D;债券到期日债券面值的现值</p><h1 id="公司并购与收缩"><a href="#公司并购与收缩" class="headerlink" title="公司并购与收缩"></a>公司并购与收缩</h1><h2 id="公司并购"><a href="#公司并购" class="headerlink" title="公司并购"></a>公司并购</h2><p>并购是合并与收购的简称。</p><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>合并</td><td>吸收合并</td><td>以主并企业法人地位存续为前提，将目标公  司的产权折合为股份，连同相应的资产与负债整合到主并企业之中的资本运作方式，也叫<strong>兼并</strong>。</td></tr><tr><td>合并</td><td>新设合并</td><td>两个或两个以上公司合并组成一个新的统一 的法人公司，被合并的各公司原有的法人地位均不复存在。</td></tr></tbody></table><table><thead><tr><th>类型</th><th>含义</th><th></th></tr></thead><tbody><tr><td>收购  (股权收购)</td><td>非控制权性收购</td><td>主并企业与目标公司各自原有的法人地位继续存在，也称之为<strong>参股性收购</strong></td></tr><tr><td>收购  (股权收购)</td><td>控制权性收购</td><td>目标公司通常作为主并企业的一个子公司，  而继续保持其原有的法人地位</td></tr></tbody></table><p>并购动因：</p><table><thead><tr><th>动因</th><th>解读</th></tr></thead><tbody><tr><td>获取公司控制权增效</td><td><strong>控制权增效</strong>，是指由于取得对公司的控制权，而使公司  效率改进和获得价值增大的效果</td></tr><tr><td>取得<strong>协同效应</strong></td><td>两个企业组成一个企业之后，其产出比原先两个企业产  出之和还要大的情形，即俗称的“1+1&gt;2”效应</td></tr><tr><td>向市场<strong>传递公司  价值低估的信息</strong></td><td>收购活动会传递关于目标企业股票被低估的信息，并且促使市场对这些股票进行重新估价，<strong>收购要约</strong>会激励目  标企业的管理层自身贯彻更有效的战略</td></tr><tr><td><strong>降低代理成本</strong></td><td>当管理者只拥有一小部分公司股份时，便会产生代理问题(如管理层的额外消费),在所有权极为分散的大公司中，单个所有者没有足够的动力去花费大量的资源用于监督管理者行为</td></tr><tr><td><strong>管理者扩张动机</strong></td><td><strong>经理阶层扩张动机论</strong>认为，管理者具有很强烈的扩大公  司规模的欲望，因为经理的报酬是公司规模的函数。这样，经理会热衷于扩大公司规模</td></tr></tbody></table><p>被并购企业的价值评估：</p><p>企业价值评估是并购方制定合理支付价格范围的主要依据。目前，企业价值</p><p>评估模式大致可分为两类：</p><table><thead><tr><th>模式</th><th>解读</th></tr></thead><tbody><tr><td>折现式价值评估</td><td>目标公司价值&#x3D;目标公司每年自由现金流量现值的合计 ；<br />目标公司股权价值&#x3D;目标公司价值-目标公司债务价值  <br />在现金流量折现过程中，需要三个重要参数： 一是现金流量；  二是折现率；三是期限</td></tr><tr><td>非折现式价值评估</td><td>非折现式价值评估模式包括<strong>市盈率法、账面资产净值法和清算价值法</strong>等，教材主要介绍市盈率法的应用。</td></tr><tr><td>非折现式价值评估</td><td>市盈率&#x3D;每股价格÷每股收益<br />根据公式可知，如果知道一个标准的市盈率，知道目标公司的  预计每股收益，则：<br />每股价值&#x3D;预计每股收益×标准市盈率<br />这种估值方法一般适用于并购公司或目标公司为上市公司的情况</td></tr></tbody></table><p>并购支付方式：</p><table><thead><tr><th>方式</th><th>特征</th></tr></thead><tbody><tr><td>现金  支付</td><td>最迅速、最受现金拮据的目标公司欢迎的一种方式，但容易造成并购公司巨大的现金压力，引起并购公司流动性问题。</td></tr><tr><td>股票  对价</td><td>集团公司<strong>通过增发新股换取目标公司的股权，减少集团公司财务风险</strong>，但可能会稀释企业集团原有的控制权结构与每股收益水平，同时股票支付处理程序复杂，可能会延误并购时机，增大并购成本</td></tr><tr><td>杠杆  收购</td><td>杠杆收购指<strong>集团公司通过借款的方式购买目标公司的股权</strong>，取得控制权后，再以目标公司未来创造的现金流量偿付借款。<strong>管理层收购中多采用杠杆收购方式</strong></td></tr><tr><td><strong>卖方  融资</strong></td><td>卖方融资指作为并购公司的集团公司暂不向目标公司支付全额价款，而是作为对目标公司所有者的负债，承诺在未来一定时期内<strong>分期、分批支付并购价款的方式</strong>。应用这种付款方式的前提是企业集  团有着良好的资本结构和风险承受能力</td></tr></tbody></table><h2 id="公司收缩"><a href="#公司收缩" class="headerlink" title="公司收缩"></a>公司收缩</h2><p>公司收缩是公司重组的一种形式，是相对于公司扩张而提出的概念，它是指<strong>对公司的股本或资产进行重组从而缩减主营业务范围或缩小公司规模的各种资本运作方式</strong>。</p><p>公司收缩的目标是通过收缩战线实现公司的最优规模。</p><p>公司收缩的主要方式包括：资产剥离、公司分立、分拆上市等。</p><h3 id="资产剥离"><a href="#资产剥离" class="headerlink" title="资产剥离"></a>资产剥离</h3><p>资产剥离指<strong>企业将其所拥有的资产、产品线、经营部门、子公司出售给第三方，以获取现金或股票</strong>，或现金与股票混合形式回报的一种<strong>商业行为</strong>。在一个典型的剥离中，购买者是一家已存在的企业，因此，不会产生新的法律实体。</p><p>资产剥离的一种特别方式是资产置换。</p><p>资产剥离的消息通常会对股票市场价值产生积极的影响。</p><h3 id="公司分立"><a href="#公司分立" class="headerlink" title="公司分立"></a>公司分立</h3><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>标准式</td><td>标准式公司分立指母公司将其在某子公司中所拥有的股份，按母公司股东在母公司中的持股比例分配给现有母公司的股东，从而 <strong>在法律上和组织上将子公司的经营从母公司的经营中分离出去的  行为</strong></td></tr><tr><td>衍生式</td><td>换股式：换股式公司分立指母公司把其在子公司中占有的股份分配给母公司的一些股东(而不是全部母公司股东),用以交换上述股东在母公司中的股份的行为</td></tr><tr><td>衍生式</td><td>解散式：解散式公司分立指母公司将子公司的控制权移交给它的股东。  在解散式公司分立中，母公司所拥有的全部子公司都分立出来，因此原母公司不复存在</td></tr></tbody></table><h3 id="分拆上市"><a href="#分拆上市" class="headerlink" title="分拆上市"></a>分拆上市</h3><p>广义的分拆上市是指已上市公司或者尚未上市公司将其中部分业务独立出来单独上市；</p><p>狭义的分拆上市指的是已上市公司将其中部分业务或者已上市母公司将其中某个子公司独立出来，另行公开招股上市。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;投资管理概述&quot;&gt;&lt;a href=&quot;#投资管理概述&quot; class=&quot;</summary>
      
    
    
    
    <category term="税务师" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/"/>
    
    <category term="财务管理" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
    <category term="4.投资管理概述" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86/4-%E6%8A%95%E8%B5%84%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>3.财务管理-筹资与股利分配管理</title>
    <link href="http://example.com/2023/11/07/%E7%A8%8E%E5%8A%A1%E5%B8%88/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/11/07/%E7%A8%8E%E5%8A%A1%E5%B8%88/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/</id>
    <published>2023-11-07T05:46:23.846Z</published>
    <updated>2023-11-07T14:03:50.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="筹资管理概述"><a href="#筹资管理概述" class="headerlink" title="筹资管理概述"></a>筹资管理概述</h1><h2 id="筹资分类"><a href="#筹资分类" class="headerlink" title="筹资分类"></a>筹资分类</h2><p>企业筹资，是指企业为了满足<strong>经营活动、投资活动、资本结构管理和其他需要</strong>，运用一定的筹资方式，通过一定的筹资渠道，筹措和获取所需资金的一种财务行为。</p><p>企业采用不同方式所筹集的资金，按照不同的分类标准，可分为不同的筹资类别。</p><table><thead><tr><th>分类标准</th><th>类型</th><th>解读</th><th>举例</th></tr></thead><tbody><tr><td>所取得资金的权益特性</td><td>股权  筹资</td><td>股东投入的，企业依法长期拥  有、能够自主调配运用的资本</td><td>吸收直接投资、发行  股票、利用留存收益</td></tr><tr><td>所取得资金的权益特性</td><td>债务  筹资</td><td>企业按合同向债权人取得的，  在规定期限内需要清偿的债务</td><td>发行债券、银行借款</td></tr><tr><td>所取得资金的权益特性</td><td>混合  筹资</td><td>兼具股权与债务筹资性质</td><td>可转换债券、  认股权证</td></tr></tbody></table><blockquote><p>认股权证是指由特定发行人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人购买或出售标的证券，或以现金结算等方式收取结算差价的有价证券。</p></blockquote><table><thead><tr><th>分类标准</th><th>类型</th><th>解读</th><th>举例</th></tr></thead><tbody><tr><td>是否以金融机构 为媒介</td><td>直接筹资</td><td>企业<strong>直接与资金供应者协商</strong>融通资金的筹资活动</td><td>发 行股 票 、发 行 债  券、吸收直接投资</td></tr><tr><td>是否以金融机构为媒介</td><td>间接筹资</td><td>企业借助银行和非银行金融机构而筹资的资金</td><td>银行借款、融资租赁</td></tr><tr><td>资金的来源范围  不同</td><td>内部筹资</td><td>企业通过利润留存而形成的筹资来源</td><td><strong>利用留存收益</strong></td></tr><tr><td>资金的来源范围  不同</td><td>外部筹资</td><td>企业向外部筹措资金形成的筹资来源</td><td>发行股票、发行债  券、向银行借款等</td></tr><tr><td>所筹集资金的使用期限</td><td>短期筹资</td><td>企业筹集资金使用期限在1年以内的资金</td><td><strong>商业信用、短期借款、保理业务</strong></td></tr><tr><td>所筹集资金的使用期限</td><td>长期筹资</td><td>企业筹集资金使用期限在1年以上的资金</td><td>发行股票、取得长期借款等</td></tr></tbody></table><h2 id="筹资管理原则"><a href="#筹资管理原则" class="headerlink" title="筹资管理原则"></a>筹资管理原则</h2><table><thead><tr><th>原则</th><th>含义</th></tr></thead><tbody><tr><td>筹措合法</td><td>企业筹资要遵循国家法律法规，合法筹措资金</td></tr><tr><td>规模适当</td><td>要根据生产经营及其发展的需要，合理安排资金需求</td></tr><tr><td>取得及时</td><td>要合理安排筹资时间，适时取得资金</td></tr><tr><td>来源经济</td><td>要充分利用各种筹资渠道，选择经济、 可行的资金来源</td></tr><tr><td>结构合理</td><td>筹资管理要综合考虑各种筹资方式，优化资本结构</td></tr></tbody></table><h1 id="筹资方式"><a href="#筹资方式" class="headerlink" title="筹资方式"></a>筹资方式</h1><h2 id="股权筹资-★★"><a href="#股权筹资-★★" class="headerlink" title="股权筹资(★★)"></a>股权筹资(★★)</h2><p>股权筹资是企业<strong>最基本的筹资方式</strong>，它包括吸收<strong>直接投资、发行股票和利用留存收益</strong>三种基本形式。</p><p><strong>吸收直接投资</strong>的出资方式包括以货币资产出资、以实物资产出资、以土地使用权出资、以工业产权出资和以特定债权出资。</p><p><strong>普通股</strong>股票简称普通股，是公司发行的代表着股东享有平等的权利、义务，不加特别限制的，股利不固定的股票。</p><p><strong>优先股</strong>股票简称优先股，是公司发行的相对于普通股具有一定优先权的股</p><p>票。其优先权利主要表现在股利分配优先权和分配剩余财产优先权上。优先股股东在股东大会上无表决权，在参与公司经营管理上受到一定限制，仅对涉及优先股股利的问题有表决权。</p><table><thead><tr><th>特点</th><th>直接投资</th><th>发行普通股股票</th><th>发行优先股</th></tr></thead><tbody><tr><td>优点</td><td><strong>能够尽快形成生产能力</strong>：吸收直接投资不仅可以取得一部分货币资金，而且能够直接获得所需的先进设备和技术，尽快形成生产经营能力</td><td><strong>两权分离，有利于公司自主经营管理</strong>：公司通过对外发行股票筹资，公司的所有权与经营权相分离，分散了公司控制权，有利于公  司自主管理、自主经营</td><td>优先股一般没有到期日，不需要偿还本金，只需支付固定股息;优先股的股息率一般为固定比率，使得优先股融资具有<strong>财务杠杆</strong>作用。</td></tr><tr><td>优点</td><td><strong>容易进行信息沟通</strong>：吸收直接投资的投资者比较单一，股权没有社会化、  分散化，投资者还可以直接担任公司管理层职务</td><td><strong>能提高公司的社会声誉</strong>，促进股权流  通和转让：普通股筹资，股东的大众化为公司带来了广泛  的社会影响。特别是上市公司，其股票的流通  性强，有利于市场确认公司的价值</td><td>优先股股东不能强迫公司破产，发行优先股能增强公司的信誉，<strong>提高公司的举债能力</strong>；优先股股东一般没有投票权，发行优先股<strong>不会因稀释控制权而引起普通股股东的反对</strong>，其筹资能顺利进行</td></tr><tr><td>缺点</td><td><strong>资本成本较高</strong>：相对于股票筹资方式来说，吸收直接投资的<strong>资本成本较高</strong>。但与发行股票相比，吸收投资的手续相对比较  简便，<strong>筹资费用较低</strong></td><td><strong>资本成本较高</strong>：(1)对投资者来说，投资普通股票的风险比投 资债券的风险大。因此，投资者对普通股投资  要求得到较高的收益率，这就增加了筹资公司  的资本成本；  (2)股利由扣除所得税后的净利润支付，筹资  公司得不到抵减税款的好处；  (3)普通股票的发行手续复杂，发行费用一般  比其他筹资方式高</td><td>优先股的资本成本虽低于普通股，但<strong>高于债券</strong>；优先股在股息分配、资产清算等方面拥有优先权，使<strong>普通股股东在公司经营不稳定时收益受到影响</strong>；</td></tr><tr><td>缺点</td><td><strong>不易进行产权交易</strong>：由于没有以证券为媒介，不利于产权交易，难以进行产权转让</td><td><strong>不易及时形成生产能力</strong>：普通股筹资吸收的一般都是货币资金，还需要  通过购置和建造固定资产等形成生产经营能  力。相对吸收直接投资方式来说，不易及时形  成生产能力</td><td>优先股筹资后对公司的限制较多</td></tr></tbody></table><p><strong>留存收益的筹资途径</strong></p><p>(1)提取盈余公积金。</p><p>盈余公积金，是指有指定用途的留存净利润，其提取基数是抵减年初累计亏损后的本年度净利润。盈余公积金主要用于企业未来的经营发展，经投资者审议后也可以用于转增股本(实收资本)和弥补以前年度经营亏损。</p><p>(2)未分配利润。</p><p>未分配利润，是指未限定用途的留存净利润。未分配利润有两层含义：第一，这部分净利润本年没有分配给公司的股东投资者；第二，这部分净利润未指定用途，可以用于企业未来经营发展、转增股本(实收资本)、弥补以前年度经营亏损、以后年度利润分配。</p><table><thead><tr><th>特点</th><th>解读</th></tr></thead><tbody><tr><td>不用发生  筹资费用</td><td>与普通股筹资相比较，留存收益筹资不需要发生筹资费  用，资本成本较低</td></tr><tr><td>维持公司的  控制权分布</td><td>利用留存收益筹资，不用对外发行新股或吸收新投资者，  由此增加的权益资本不会改变公司的股权结构，不会稀释  原有股东的控制权</td></tr><tr><td>筹资数额有限</td><td>留存收益的最大数额是企业当期的净利润和以前年度未分  配利润之和，不像外部筹资一次性可以筹集大量资金</td></tr></tbody></table><h2 id="债务筹资-★★"><a href="#债务筹资-★★" class="headerlink" title="债务筹资(★★)"></a>债务筹资(★★)</h2><p>债务筹资的前提是资产回报率大于债务利率。债务筹资不仅可以满足企业投资和经营的资金需要，而且存在<strong>杠杆效应</strong>，能够提高股权资本回报率。债务资金的高风险性，能够限制经理人的扩张冲动，因此，债务筹资也具有<strong>公司治理效应</strong>。</p><p>债务筹资的主要方式包括<strong>银行借款、发行债券、融资租赁和商业信用</strong>等多种方式。</p><h3 id="银行借款"><a href="#银行借款" class="headerlink" title="银行借款"></a>银行借款</h3><h4 id="基本种类"><a href="#基本种类" class="headerlink" title="基本种类"></a>基本种类</h4><table><thead><tr><th>分类标准</th><th>类型</th></tr></thead><tbody><tr><td>提供贷款的机构</td><td>政策性银行贷款、商业性银行贷款和其他金融机构贷款</td></tr><tr><td>有无担保要求</td><td>信用贷款和担保贷款</td></tr><tr><td>取得贷款的用途</td><td>基本建设贷款、专项贷款和流动资金贷款</td></tr></tbody></table><h4 id="长期借款的保护性条款"><a href="#长期借款的保护性条款" class="headerlink" title="长期借款的保护性条款"></a>长期借款的保护性条款</h4><p>长期借款的金额高、期限长、风险大，除借款合同的基本条款之外，债权人通常还在借款合同中附加各种保护性条款，以确保企业按要求使用借款和按时足额偿还借款。</p><p>保护性条款一般有三类：<strong>例行性保护条款、一般性保护条款、特殊性保护条款</strong>。</p><table><thead><tr><th>条款类型</th><th>具体内容</th></tr></thead><tbody><tr><td>例行性 保护条款</td><td><strong>例行常规，在大多数借款合同中都会出现</strong>。主要包括：  (1)要求定期向提供贷款的金融机构<strong>提交公司财务报表</strong>；  (2)保持存货储备量，不准在正常情况下出售较多的非产成品存货 ；  (3)及时清偿债务，以防被罚款而造成不必要的现金流失；  (4)不准以资产作其他承诺的担保或抵押；  (5)<strong>不准贴现应收票据或出售应收账款，以避免或有负债等</strong></td></tr><tr><td>一般性保  护条款</td><td>对企业资产的<strong>流动性及偿债能力等方面的要求条款</strong>，应用于大多数借款合同。主要包括：  (1)保持企业的资产流动性；  (2)<strong>限制企业非经营性支出</strong>；  (3)<strong>限制企业资本支出的规模</strong>；  (4)限制公司再举债规模；  (5)限制公司的长期投资</td></tr><tr><td>特殊性保  护条款</td><td>针对某些<strong>特殊情况而出现在部分借款合同中的条款</strong>，只有在特  殊情况下才能生效。主要包括：  (1)要求公司的主要领导人购买<strong>人身保险</strong>；  (2)<strong>借款的用途不得改变</strong>；  (3)<strong>违约惩罚条款</strong></td></tr></tbody></table><h4 id="银行借款的筹资特点"><a href="#银行借款的筹资特点" class="headerlink" title="银行借款的筹资特点"></a>银行借款的筹资特点</h4><table><thead><tr><th>特点</th><th>解读</th><th></th></tr></thead><tbody><tr><td>优点</td><td><strong>筹资  速度快</strong></td><td>与发行公司债券、融资租赁等其他债务筹资方式相比，  银行借款的程序相对简单，所花时间较短，公司可以迅速获得所需资金</td></tr><tr><td>优点</td><td>资本  成本较低</td><td>利用银行借款筹资， 一般都<strong>比发行债券和融资租赁的利息负担要低</strong>。而且，无须支付证券发行费用、租赁手续费用等筹资费用</td></tr><tr><td>优点</td><td>筹资  弹性较大</td><td>在借款之前，公司根据当时的资本需求与银行等贷款机构直接商定贷款的时间、数量和条件。在借款期间，若  公司的财务状况发生某些变化，也可与债权人再协商，  变更借款数量、时间和条件，或提前偿还本息</td></tr><tr><td>缺点</td><td>限制  条款多</td><td>与发行公司债券相比较，银行借款合同对借款用途有明确规定，通过借款的保护性条款，<strong>对公司资本支出额  度、再筹资、股利支付等行为有严格的约束</strong></td></tr><tr><td>缺点</td><td>筹资  数额有限</td><td>银行借款的数额往往受到贷款机构资本实力的制约，难以像发行公司债券、股票能一次筹集到大笔资金，<strong>无法满足公司大规模筹资的需要</strong></td></tr></tbody></table><h3 id="发行公司债"><a href="#发行公司债" class="headerlink" title="发行公司债"></a>发行公司债</h3><p>公司债券是由企业发行的有价证券，是企业为筹措资金而公开负担的一种债务契约，表示企业借款后，有义务偿还其所借金额的一种期票。</p><p>债券的基本要素：</p><table><thead><tr><th>要素</th><th>解读</th></tr></thead><tbody><tr><td>面值</td><td>债券面值是债券设定的票面金额，代表发行人承诺于未来某一 特定日偿付债券持有人的金额</td></tr><tr><td>票面利率</td><td>债券票面利率是债券发行者预计一年内向持有者支付的利息占票面金额的比率</td></tr><tr><td>到期日</td><td>债券到期日是指偿还债券本金的日期，债券一般都有规定到期日，以便到期时归还本金</td></tr></tbody></table><table><thead><tr><th>分类标准</th><th>类型</th></tr></thead><tbody><tr><td>是否记名</td><td>记名债券和无记名债券</td></tr><tr><td>能否转换为公司股票</td><td>可转换债券和不可转换债券</td></tr><tr><td>是否上市流通</td><td>上市债券和非上市债券</td></tr><tr><td>偿还期限的长短</td><td>长期债券和短期债券</td></tr><tr><td>支付利息的形式不同</td><td>固定利息债券、浮动利息债券和贴息债券</td></tr><tr><td>发行的保证条件不同</td><td>抵押债券、担保债券和信用债券</td></tr></tbody></table><table><thead><tr><th>特点</th><th>解读</th><th></th></tr></thead><tbody><tr><td>优点</td><td>一次筹资  数额大</td><td>利用发行公司债券筹资能够筹集大额的资金，满  足公司大规模筹资的需要</td></tr><tr><td>优点</td><td>募集资金的使用  限制条件少</td><td>与银行借款相比，发行公司债券募集的资金在使  用上具有相对灵活性和自主性</td></tr><tr><td>优点</td><td>提高公司的社会声誉</td><td>公司债券的发行主体有严格的资格限制。通过发行公司债券， 一方面筹集了大量资金，另一方面  也扩大了公司的社会影响</td></tr><tr><td>缺点</td><td>资本成本负担较高</td><td>相对于银行借款筹资，发行公司债券的利息负担和筹资费用都比较高</td></tr></tbody></table><h3 id="融资租赁"><a href="#融资租赁" class="headerlink" title="融资租赁"></a>融资租赁</h3><p>租赁，是指在一定期间内，出租人将资产的使用权让与承租人以获取对价的合同。租赁分为经营租赁和融资租赁。</p><p>1.按照租赁当事人之间的关系，融资租赁可以划分为三种类型</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>直接租赁</td><td>出租人直接向承租人提供租赁资产的租赁形式。直接租赁  只涉及出租人和承租人双方</td></tr><tr><td>杠杆租赁  (出租方  角度)</td><td>出租人引入资产时只支付所需款项的一部分，其余款项向  第三方申请贷款解决。这样，出租人利用自己的少量资金  推动了大额的租赁业务。杠杆租赁涉及三方当事人</td></tr><tr><td>售后回租  (承租方  角度)</td><td>承租人先将某资产卖给出租人，再将该资产租回的一种租  赁形式。  承租人一方面通过出售资产获得了现金，另一方面又通过  租赁满足了对资产的需要，而租赁费却可以分期支付</td></tr></tbody></table><p>2.融资租赁筹资的特点</p><table><thead><tr><th>特点</th><th>解读</th><th></th></tr></thead><tbody><tr><td>优点</td><td>无须大量资金  就能迅速获得资产</td><td>在缺乏资金情况下，融资租赁能迅速获得所需  资产</td></tr><tr><td>优点</td><td>财务风险小</td><td>能够避免一次性支付的负担，而且租金支出是  未来的、分期的。还款时，租金可以通过项目  本身产生的收益来支付，是一种基于未来的  “借鸡生蛋、卖蛋还钱”的筹资方式</td></tr></tbody></table><table><thead><tr><th>特点</th><th>解读</th><th></th></tr></thead><tbody><tr><td>优点</td><td>筹资的限制条件较少</td><td>相比运用股票、债券、长期借款筹资方式，租赁筹资的限制条件很少</td></tr><tr><td>优点</td><td>能延长资金的融通期限</td><td>通常为购置设备而贷款的借款期限比该资产的  物理寿命要短得多，而租赁的融资期限却可接近其全部使用寿命期限</td></tr><tr><td>缺点</td><td>资本成本负担较高</td><td><strong>租赁的租金通常比银行借款或发行公司债券所负担的利息高得多</strong>，租金总额通常要比设备价值高出30%</td></tr></tbody></table><h3 id="筹资方式创新"><a href="#筹资方式创新" class="headerlink" title="筹资方式创新"></a>筹资方式创新</h3><h4 id="商业票据融资"><a href="#商业票据融资" class="headerlink" title="商业票据融资"></a>商业票据融资</h4><p>商业票据融资是指通过商业票据进行融通资金。商业票据是一种<strong>商业信用工具</strong>，是由<strong>债务人向债权人开出的、承诺在一定时期内支付一定款项的支付保证书</strong>，即由无担保、可转让的短期期票组成。商业票据融资具有融资成本较低、灵活方便等特点。</p><h4 id="中期票据融资"><a href="#中期票据融资" class="headerlink" title="中期票据融资"></a>中期票据融资</h4><p>中期票据是指具有法人资格的<strong>非金融类企业</strong>在<strong>银行间债券市场</strong>按计划分期发行的、约定在一定期限还本付息的债务融资工具。中期票据具有如下特点：</p><table><thead><tr><th>特点</th><th>解读</th></tr></thead><tbody><tr><td>发行机制灵活</td><td>中期票据发行采用注册制， 一次注册通过后两年内可分次发行；可选择固定利率或浮动利率，到期还本付息；付息可选择按年或季等</td></tr><tr><td>用款方式灵活</td><td>中期票据可用于中长期流动资金、置换银行借款、项目建设等</td></tr><tr><td>融资额度大</td><td>企业申请发行中期票据，按规定发行额度最多可达企业净资产的40%</td></tr><tr><td>使用期限长</td><td>中期票据的发行期限在1年以上， 一般3～5年，最长可达10年</td></tr><tr><td>成本较低</td><td>根据企业信用评级和当时市场利率，中期票据利率较中长期贷款等融资方式往往低20%～30%</td></tr><tr><td>无须担保  抵押</td><td>发行中期票据，主要依靠企业自身信用，无须担保和抵押</td></tr></tbody></table><h4 id="股权众筹融资"><a href="#股权众筹融资" class="headerlink" title="股权众筹融资"></a>股权众筹融资</h4><p>股权众筹融资主要是指通过互联网形式进行公开<strong>小额股权融资</strong>的活动。股权众筹融资必须通过股权众筹融资中介机构平台(互联网网站或其他类似的电子媒介)进行，并且融资方应为小微企业。股权众筹融资业务由证监会负责监管。</p><h4 id="企业应收账款证券化"><a href="#企业应收账款证券化" class="headerlink" title="企业应收账款证券化"></a>企业应收账款证券化</h4><p>企业应收账款资产支持证券，是指证券公司、基金管理公司子公司作为管理人，通过设立资产支持专项计划开展资产证券化业务，以企业应收账款债权为基础资产或基础资产现金流来源所发行的资产支持证券。</p><h4 id="融资租赁债权资产证券化"><a href="#融资租赁债权资产证券化" class="headerlink" title="融资租赁债权资产证券化"></a>融资租赁债权资产证券化</h4><p>融资租赁债权资产支持证券是指证券公司、基金管理公司子公司作为管理人，通过设立资产支持专项计划开展资产证券化业务，以融资租赁债权为基础资产或基础资产现金流来源所发行的资产支持证券。</p><h4 id="商圈融资"><a href="#商圈融资" class="headerlink" title="商圈融资"></a>商圈融资</h4><p>商圈融资模式包括商圈担保融资、商铺经营权和租赁权质押、仓单质押、存货质押、动产质押、企业集合债券等。</p><p>发展商圈融资是缓解中小商贸企业融资困难的重大举措，有助于增强中小商贸经营主体的融资能力，促进中小商贸企业健康发展；有助于促进商圈发展，增强经营主体集聚力，提升产业关联度，整合产业价值链，从而带动税收、就业增长和区域经济发展，实现搞活流通、扩大消费的战略目标；也有助于银行业金融机构和融资性担保机构等培养长期稳定的优质客户群，扩大授信规模，降低融资风险。</p><h4 id="供应链融资"><a href="#供应链融资" class="headerlink" title="供应链融资"></a>供应链融资</h4><p>供应链融资，是将供应链核心企业及其上下游配套企业作为一个整体，根据供应链中相关企业的交易关系和行业特点制定基于货权和现金流控制的“一揽子”金融解决方案的一种融资模式。供应链融资解决了上下游企业融资难、担保难的问题，而且通过打通上下游融资瓶颈，还可以降低供应链条融资成本，提高核心企业及配套企业的竞争力。</p><h4 id="绿色信贷"><a href="#绿色信贷" class="headerlink" title="绿色信贷"></a>绿色信贷</h4><p>绿色信贷，也称可持续融资或环境融资。它是指银行业金融机构为支持环保产业、倡导绿色文明、发展绿色经济而提供的信贷融资。绿色信贷重点支持节能环保、清洁生产、清洁能源、生态环境、基础设施绿色升级和绿色服务六大类产业。</p><h4 id="能效信贷"><a href="#能效信贷" class="headerlink" title="能效信贷"></a>能效信贷</h4><p>能效信贷，是指银行业金融机构为支持用能单位提高能源利用效率，降低能源消耗而提供的信贷融资。能效信贷包括用能单位能效项目信贷和节能服务公司合同能源管理信贷两种方式。</p><h1 id="资本成本与资本结构"><a href="#资本成本与资本结构" class="headerlink" title="资本成本与资本结构"></a>资本成本与资本结构</h1><h2 id="资本成本的概念"><a href="#资本成本的概念" class="headerlink" title="资本成本的概念"></a>资本成本的概念</h2><p><strong>资本成本是指资金使用者为筹集和使用资金所支付的代价</strong>，包括筹资费用和用资费用。</p><table><thead><tr><th>项目</th><th>解读</th></tr></thead><tbody><tr><td>筹资费用</td><td>筹资费用指在资金筹集过程中所支付的费用，这些费用都是一次性的，视为筹资数额的一项扣除，如委托证券经营机构代理  发行股票、债券所支付的代办费等</td></tr><tr><td>用资费用</td><td>用资费用指在资金使用期内<strong>按年或按月支付给资金供应者的报酬</strong>，如股息、红利、利息、租金等</td></tr></tbody></table><p>资本成本可用绝对数表示，也可用相对数表示。但为了便于比较和应用，一般采用相对数表示资本成本，它是年用资费用与净筹资额的比率，计算公式为：</p><p><strong>资本成本&#x3D;年用资费用&#x2F;净筹资额</strong></p><p><strong>净筹资额&#x3D;筹资总额-筹资费用&#x3D;筹资总额×(1-筹资费率)</strong></p><h2 id="资本成本的计算【★★】"><a href="#资本成本的计算【★★】" class="headerlink" title="资本成本的计算【★★】"></a>资本成本的计算【★★】</h2><h3 id="银行借款资本成本"><a href="#银行借款资本成本" class="headerlink" title="银行借款资本成本"></a>银行借款资本成本</h3><p><img src="/../../pic/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/image-20231107151646148.png" alt="image-20231107151646148"></p><h3 id="公司债券的资本成本"><a href="#公司债券的资本成本" class="headerlink" title="公司债券的资本成本"></a>公司债券的资本成本</h3><p><img src="/../../pic/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/image-20231107151748598.png" alt="image-20231107151748598"></p><h3 id="普通股资本成本"><a href="#普通股资本成本" class="headerlink" title="普通股资本成本"></a>普通股资本成本</h3><p>普通股资本成本的估计有两种方法：一是股利增长模型法，二是资本资产定价模型法。</p><p><strong>1.(固定)股利增长模型法</strong></p><p>假定资本市场有效，股票市场价格与价值相等。假定某股票本期支付股利为$D_0$,未来各期股利按$g$速度增长，下期的股利是$D_1$,目前股票市场价格为$P_0$,筹资费率为$f$,则普通股资本成本为：</p><p><img src="/../../pic/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/image-20231107151937128.png" alt="image-20231107151937128"></p><p><strong>2.资本资产定价模型法</strong></p><p>假定资本市场有效，股票市场价格与价值相等。无风险报酬率为R,市场平均报酬率为$R_m$,某股票贝塔系数为β,则普通股资本成本为：</p><p>$$K_s&#x3D;R+β(R_m-R)$$</p><h3 id="优先股"><a href="#优先股" class="headerlink" title="优先股"></a>优先股</h3><p><img src="/../../pic/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/image-20231107164611281.png" alt="image-20231107164611281"></p><h3 id="留存收益的资本成本"><a href="#留存收益的资本成本" class="headerlink" title="留存收益的资本成本"></a>留存收益的资本成本</h3><p>留存收益是由企业税后净利润形成的，是一种所有者权益，其实质是所有者向企业的追加投资。留存收益资本成本，表现为股东追加投资要求的报酬率，其计算与普通股成本相同，也分为股利增长模型法和资本资产定价模型法，不同点在于不考虑筹资费用。</p><h3 id="加权资本成本"><a href="#加权资本成本" class="headerlink" title="加权资本成本"></a>加权资本成本</h3><p>加权资本成本是指多元化融资方式下的综合资本成本，反映着<strong>企业资本成本整体水平的高低</strong>。在衡量和评价单一融资方案时，需要计算个别资本成本；在衡量和评价企业筹资总体的经济性时，需要计算企业的加权资本成本。</p><p>企业加权资本成本，是以各项个别资本在企业总资本中的比重为权数，对各项个别资本成本进行加权平均而得到的总资本成本。其中，权数的确定方法，通常有三个：</p><table><thead><tr><th>确定方法</th><th>解读</th></tr></thead><tbody><tr><td>账面价值权数</td><td>以各项个别资本的<strong>会计报表账面价值为基础</strong>来计算资本权数，确定各类资本占总资本的比重</td></tr><tr><td>市场价值权数</td><td>以各项<strong>个别资本的现行市价为基础</strong>来计算资本权数，确定各类资本占总资本的比重</td></tr><tr><td>目标价值权数</td><td>以各项<strong>个别资本预计的未来价值为基础</strong>确定资本权数，确定各类资本占总资本的比重，适用于未来的筹资决策，但  目标价值的确定难免具有主观性</td></tr></tbody></table><h2 id="杠杆效应"><a href="#杠杆效应" class="headerlink" title="杠杆效应"></a>杠杆效应</h2><p><strong>杠杆效应表现为：由于特定固定支出或费用的存在，当某一财务变量以较小幅度变动时，另一相关变量会以较大幅度变动。</strong></p><p>财务管理中的杠杆效应，包括经营杠杆、财务杠杆和总杠杆三种效应形式。</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>经营杠杆效应</td><td>由于固定性经营成本的存在，使企业的<strong>资产报酬(息税前利润)变动率大于业务量变动率</strong>的现象</td></tr><tr><td>财务杠杆效应</td><td>由于固定性资本成本的存在，而使得企业的<strong>普通股收益  (或每股收益)变动率大于息税前利润变动率</strong>的现象</td></tr><tr><td>总杠杆效应</td><td>由于固定性经营成本和固定性资本成本的共同存在，使企业的<strong>每股收益变动率大于业务量变动率</strong>的现象</td></tr></tbody></table><blockquote><p>息税前利润(Earnings Before Interest and Tax,EBIT),通俗理解为，扣除利息和所得税之前的利润。</p><table><thead><tr><th>符号</th><th>科目</th></tr></thead><tbody><tr><td></td><td>收入</td></tr><tr><td>-</td><td>经营成本费用</td></tr><tr><td>&#x3D;</td><td>息税前利润</td></tr><tr><td>-</td><td>利息费用</td></tr><tr><td>&#x3D;</td><td>利润总额</td></tr><tr><td>-</td><td>所得税费用</td></tr><tr><td>&#x3D;</td><td>净利润</td></tr></tbody></table></blockquote><blockquote><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>P(Price)</td><td>单位销售价格</td></tr><tr><td>V(variable cost)</td><td>单位变动成本</td></tr><tr><td>Q(Quantity)</td><td>产品销售数量</td></tr><tr><td>s(sale)&#x3D;Q×P</td><td>营业收入</td></tr><tr><td>F(Fixed)</td><td>固定经营成本总额</td></tr><tr><td>EBIT&#x3D;Q×(P-V)-F</td><td>息税前利润</td></tr><tr><td>I(Interest)</td><td>利息</td></tr><tr><td>D,(Dividend)</td><td>优先股股息</td></tr><tr><td>EPS&#x3D;[(EBIT-I)×(1-T)-D,]&#x2F;N</td><td>每股收益</td></tr></tbody></table></blockquote><h4 id="经营杠杆系数"><a href="#经营杠杆系数" class="headerlink" title="经营杠杆系数"></a>经营杠杆系数</h4><p><strong>经营杠杆系数是息税前利润变动率与业务量变动率的比值</strong>。其计算分为两个方法：</p><ol><li>定义公式$$\mathrm{DOL}&#x3D;\frac{\text { 息税前利润变动率 }}{\text { 业务量变动率 }}&#x3D;\frac{\Delta \mathrm{EBIT} &#x2F; \mathrm{EBIT}_0}{\Delta \mathrm{Q} &#x2F; \mathrm{Q}_0}$$</li><li>简化公式</li></ol><p>$$\mathrm{DOL}&#x3D;\frac{\text { 基期边际贡献 }}{\text { 基期息税前利润 }}&#x3D;\frac{\mathrm{M}_0}{\mathrm{M}_0-\mathrm{F}_0}&#x3D;\frac{\mathrm{EBIT}_0+\mathrm{F}_0}{\mathrm{EBIT}_0}$$</p><p><strong>经营杠杆放大了市场和生产等因素变化对利润波动的影响，经营杠杆系数越高，表明息税前利润受产销量变动的影响程度越大，经营风险也就越大。</strong>在息税前利润为正的前提下，经营杠杆系数最低为1,不会为负数；只要有固定性经营成本存在，经营杠杆系数总是大于1。</p><h4 id="财务杠杆系数-DFL"><a href="#财务杠杆系数-DFL" class="headerlink" title="财务杠杆系数(DFL)"></a>财务杠杆系数(DFL)</h4><p>财务杠杆系数是<strong>普通股每股收益变动率与息税前利润变动率的比值</strong>。其计算分为两个方法：</p><p>1.定义公式$$\mathrm{DFL}&#x3D;\frac{\text { 普通股每股收益变动率 }}{\text { 息税前利润变动率 }}&#x3D;\frac{\Delta \mathrm{EPS} &#x2F; \mathrm{EPS}_0}{\Delta \mathrm{EBIT} &#x2F; \mathrm{EBIT}_0}$$2.简化公式$$\mathrm{DFL}&#x3D;\frac{\text { 基期息税前利润 }}{\text { 基期利润总额 }}&#x3D;\frac{\mathrm{EBIT}_0}{\mathrm{EBIT}_0-\mathrm{I}}$$</p><p>其中，I为基期的利息费用。</p><p>财务杠杆放大了资产报酬变化对普通股收益的影响, 财务杠杆系数越高, 表明普通股收益的波动程度越大, 财务风险也就越大。</p><p>在企业有正的税后利润的前提下, 财务杠杆系数最低为1, 不会为负数; 只要有固定性资本成本存在, 财务杠杆系数总是大于1。</p><h3 id="总杠杆"><a href="#总杠杆" class="headerlink" title="总杠杆"></a>总杠杆</h3><p>总杠杆系数是经营杠杆系数和财务杠杆系数的乘积, 是普通股每股收益变动率与业务量变动率的比值。其计算分为两个方法:1.定义公式$$\mathrm{DTL}&#x3D;\frac{\text { 普通股每股收益变动率 }}{\text { 业务量变动率 }}&#x3D;\frac{\Delta \mathrm{EPS} &#x2F; \mathrm{EPS}_0}{\Delta \mathrm{Q} &#x2F; \mathrm{Q}_0}$$2.简化公式$$\mathrm{DTL}&#x3D;\frac{\text { 基期边际贡献 }}{\text { 基期利润总额 }}&#x3D;\frac{\text { 基期税后边际贡献 }}{\text { 基期税后利润 }}&#x3D;\frac{\mathrm{EBIT}_0+\mathrm{F}_0}{\mathrm{EBIT}_0-\mathrm{I}_0}$$</p><p><strong>总杠杆系数反映了经营杠杆和财务杠杆之间的关系, 用以评价企业的整体风险水平</strong>。在总杠杆系数一定的情况下, 经营杠杆系数与财务杠杆系数此消彼长。</p><h2 id="资本结构【★★】"><a href="#资本结构【★★】" class="headerlink" title="资本结构【★★】"></a>资本结构【★★】</h2><h3 id="资本结构的概念"><a href="#资本结构的概念" class="headerlink" title="资本结构的概念"></a>资本结构的概念</h3><p>资本结构是指企业资本总额中各种资本的构成及其比例关系。</p><h3 id="最优资本结构决策方法"><a href="#最优资本结构决策方法" class="headerlink" title="最优资本结构决策方法"></a>最优资本结构决策方法</h3><p>企业资本结构决策就是要确定最优资本结构。所谓最优资本结构，<strong>是指在适度财务风险的条件下，使企业加权平均资本成本最低，同时使企业价值最大的资本结构</strong>。</p><p>资本结构决策的方法主要包括比较资本成本法、每股收益无差别点分析法和公司价值分析法。</p><h4 id="比较资本成本法"><a href="#比较资本成本法" class="headerlink" title="比较资本成本法"></a>比较资本成本法</h4><p>通过计算和比较各种可能的筹资方案的加权资本成本, 选择加权资本成本最低的方案。</p><h4 id="每股收益无差别点分析法"><a href="#每股收益无差别点分析法" class="headerlink" title="每股收益无差别点分析法"></a>每股收益无差别点分析法</h4><p>(1) 基本观点:可以用每股收益的变化来判断资本结构是否合理, 即<strong>能够提高普通股每股收益的资本结构, 就是合理的资本结构</strong>。</p><p>(2) 决策方法:</p><p>第一步: 计算每股收益无差别点。所谓每股收益无差别点, 是指<strong>不同筹资方式下每股收益都相等时的息税前利润 (或业务量) 水平</strong>, 计算公式如下:</p><p><img src="/../../pic/3.%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/image-20231107201708940.png" alt="image-20231107201708940"></p><p>$EBIT$ 表示平衡点下的息税前利润; $D$ 表示优先股股息。</p><p>第二步：比大小，做决策。依据预期息税前利润 与每股收益无差别点的大小关系进行决策:</p><p>预期息税前利润 &gt; 每股收益无差别点, 应当选择债务筹资方案;</p><p>预期息税前利润 &lt;每股收益无差别点, 应当选择股权筹资方案。</p><h4 id="公司价值分析法"><a href="#公司价值分析法" class="headerlink" title="公司价值分析法"></a>公司价值分析法</h4><p>公司价值分析法, 是<strong>在考虑市场风险基础上, 以公司市场价值为标准，进行资本结构优化</strong>。即能够提升公司价值的资本结构, 则是合理的资本结构。同时,在公司价值最大的资本结构下，公司的加权资本成本也是最低的。</p><p>设：V表示公司价值； ${S}$ 表示权益资本价值；B表示债务资本价值。</p><p>公司价值等于资本的市场价值, 即: ${V}&#x3D;{S}+{B}$</p><p>为简化分析, 假设公司各期的EBIT保持不变, 债务资本的市场价值等于其面值，权益资本的市场价值可通过下式计算（假设不存在优先股）：</p><p>${S}&#x3D;({EBIT}-{I}) \times(1-{T}) &#x2F; {K}_{s}$</p><p>本质是将未来净利润当作现金流按照股权资本成本折现，求价值。</p><h1 id="股利分配"><a href="#股利分配" class="headerlink" title="股利分配"></a>股利分配</h1><h2 id="股利分配方式与支付程序"><a href="#股利分配方式与支付程序" class="headerlink" title="股利分配方式与支付程序"></a>股利分配方式与支付程序</h2><h3 id="股利的分配方式"><a href="#股利的分配方式" class="headerlink" title="股利的分配方式"></a>股利的分配方式</h3><table><thead><tr><th>类型</th><th>解读</th></tr></thead><tbody><tr><td>现金  股利</td><td>支付现金是企业向股东分配股利的基本形式</td></tr><tr><td>股票  股利</td><td>股票股利是公司<strong>以增发股票的方式所支付的股利</strong>，发放股票股利对  公司而言并没<strong>有现金流出，也不会导致公司的财产减少</strong></td></tr><tr><td>财产  股利</td><td>财产股利是公司以现金以外的资产支付的股利，主要有两种形式：  一是证券股利，即以本公司持有的其他公司的有价证券或政府公债  等证券作为股利发放；二是实物股利，即以公司的物资、产品或不  动产等充当股利</td></tr><tr><td>负债  股利</td><td>负债股利是公司以负债支付的股利，通常以公司的应付票据支付给  股东，在不得已的情况下，也有公司发行公司债券抵付股利</td></tr></tbody></table><h3 id="股利支付过程中的重要日期"><a href="#股利支付过程中的重要日期" class="headerlink" title="股利支付过程中的重要日期"></a>股利支付过程中的重要日期</h3><table><thead><tr><th>日期</th><th>含义</th></tr></thead><tbody><tr><td>股利宣告日</td><td>公司董事会将股东大会通过本年度利润分配方案的情况以  及股利支付情况予以公告的日期</td></tr><tr><td>股权登记日</td><td><strong>有权领取本期股利的股东资格登记截止日期</strong>。在这一天之后登记在册的股东，即使是在股利支付日之前买入的股票，也无权领取本期分配的股利</td></tr><tr><td>除息日  (登记次日)</td><td><strong>股利所有权与股票本身分离的日期</strong>，将股票中含有的股利  分配权利予以解除，即在除息日当日及以后买入的股票不再享有本次股利分配的权利。除息日通常是在登记日的下 一个交易日</td></tr><tr><td>股利支付日</td><td>公司确定的向股东正式发放股利的日期</td></tr></tbody></table><h2 id="股利分配政策"><a href="#股利分配政策" class="headerlink" title="股利分配政策"></a>股利分配政策</h2><table><thead><tr><th>维度</th><th>剩余股利政策</th><th>固定或稳定增长的股利政策</th><th>固定股利支付率的鼓励政策</th><th>低正常股利加额外股利政策</th></tr></thead><tbody><tr><td>优点</td><td>有助于降低再投资的资金成本，保持最佳的资本结构，实现企  业价值的长期最大化</td><td>稳定的股利向市场传递着公司正常发展的信息，有利于树立公司的良好形象，增强投资者对公司的信心，稳定股票的价格</td><td>体现了“多盈多分、少盈少分、无盈不分”的股利分配原则</td><td>赋予公司较大的灵活性，使公司在股利发放上留有余地，并具有较大的财务弹性</td></tr><tr><td>优点</td><td></td><td>有助于投资者安排股利收入和支出，有利于吸引那些打算进行  长期投资并对股利有很高依赖性的股东</td><td>公司每年按固定的比例从税后利润中支付现金股利，从企业的  支付能力的角度分析，这是一种稳定的股利政策</td><td>使那些依靠股利度日的股东每年至少可以得到虽然较低但比较稳  定的股利收入，从而吸引住这部分股东</td></tr><tr><td>优点</td><td></td><td>股票市场会受多种因素影响(包括股东的心理状态和其他要   求),为了将股利或股利增长率维持在稳定的水平上，即使推  迟某些投资方案或暂时偏离目标资本结构，也可能比降低股利  或股利增长率更为有利</td><td></td><td></td></tr><tr><td>缺点</td><td>若完全遵照执行剩余股利政策，股利发放额就会每年随着投资  机会和盈利水平的波动而波动</td><td>股利的支付与企业的盈利相脱节，可能会导致企业资金紧缺，    财务状况恶化。此外，在企业无利可分的情况下，依然实施固  定或稳定增长的股利政策，是违反《公司法》的行为</td><td>波动的股利很容易给投资者带来经营状况不稳定、投资风险较  大的不良印象，成为影响股价的不利因素</td><td>由于各年度之间公司盈利的波动使额外股利不断变化，容易给投  资者造成收益不稳定的感觉</td></tr><tr><td>缺点</td><td>不利于投资者安排收入与支出</td><td></td><td>容易使公司面临较大的财务压力，这是因为公司实现的盈利  多，并不能代表公司有足够的现金流用来支付较多的股利额</td><td>当公司在较长时间持续发放额外股利后，可能会被股东误认为  “正常股利”,一旦取消，传递出的信号可能会使股东认为这是  公司财务状况恶化的表现，进而导致股价下跌</td></tr><tr><td>缺点</td><td><strong>不利于公司树立良好的形象</strong></td><td></td><td>合适的固定股利支付率的确定难度比较大</td><td></td></tr></tbody></table><table><thead><tr><th>阶段</th><th>特征</th><th>股利政策选择</th></tr></thead><tbody><tr><td>初创  阶段</td><td>公司风险很高，急需大量资金投  入，融资能力差，资金成本高</td><td>为降低风险，公司应贯彻先发  展后分配的原则，剩余股利政策为最佳选择</td></tr><tr><td>高速  增长  阶段</td><td>公司的产品销售急剧上升，投资  机会快速增加，资金需求大而紧  迫，不宜宣派股利。但此时公司  的发展前景已相对较明朗，投资  者有分配股利的要求</td><td>为平衡这两方面的要求，应采取正常股利加额外股利政策，  股利支付方式应采用股票股利  的形式，避免现金支付</td></tr><tr><td>稳定  增长  阶段</td><td>公司产品的市场容量、销售收入  稳定增长，对外投资需求减少</td><td>公司已具备持续支付较高股利  的能力，理想的股利政策应是  固定或稳定增长的股利政策</td></tr><tr><td>成熟  阶段</td><td>产品市场趋于饱和，销售收入不  再增长，利润水平稳定。公司通  常已积累了一定的盈余和资金</td><td>为了与公司的发展阶段相适 应，公司可考虑采用固定股利  支付率政策</td></tr><tr><td>衰退  阶段</td><td>产品销售收入减少，利润下降，  公司为了不被解散或被其他公司  兼并重组，需要投入新的行业和  领域</td><td>公司已不具备较强的股利支付能力，应采用剩余股利政策</td></tr></tbody></table><h2 id="股票分割与股票回购"><a href="#股票分割与股票回购" class="headerlink" title="股票分割与股票回购"></a>股票分割与股票回购</h2><h3 id="股票分割"><a href="#股票分割" class="headerlink" title="股票分割"></a>股票分割</h3><p>1.股票分割的概念</p><p>股票分割又称拆股，即将一股股票拆分成多股股票的行为。股票分割一般<strong>只会增加发行在外的股票总数，但不会对公司的资本结构产生任何影响</strong>。</p><p>2.股票分割的作用</p><table><thead><tr><th align="left">作用</th><th align="left">解读</th></tr></thead><tbody><tr><td align="left">降低股票价格</td><td align="left">股票分割会使每股市价降低，买卖该股票所需资金量减少，从  而可以促进股票的流通和交易。流通性的提高和股东数量的增  加，会在一定程度上加大对公司股票恶意收购的难度</td></tr><tr><td align="left">降低股票价格</td><td align="left">降低股票价格还可以为公司发行新股做准备，因为股价太高会  使许多潜在投资者力不从心而不敢轻易对公司股票进行投资</td></tr><tr><td align="left">传递良好信息</td><td align="left">向市场和投资者传递“公司发展前景良好”的信号，有助于提高投资者对公司股票的信心</td></tr></tbody></table><table><thead><tr><th>维度</th><th>股票分割</th><th>股票股利</th></tr></thead><tbody><tr><td>相同点</td><td>在不增加股东权益的情况下增加了股份的数量</td><td>在不增加股东权益的情况下增加了股份的数量</td></tr><tr><td>不同点</td><td>股东权益总额及其内部结构都   不会发生任何变化，变化的只  是股票面值</td><td>虽不会引起股东权益总额的改  变，但股东权益的内部结构会发  生变化</td></tr></tbody></table><h3 id="股票回购"><a href="#股票回购" class="headerlink" title="股票回购"></a>股票回购</h3><p>1.股票回购的概念</p><p>股票回购是指上市公司出资将其发行在外的普通股以一定价格购买回来予以注销或作为库存股的一种资本运作方式。</p><p>2.股票回购的影响</p><p>(1)股票回购需要大量资金支付回购成本，容易造成<strong>资金紧张</strong>，<strong>降低资产流动性</strong>，影响公司的后续发展。</p><p>(2)股票回购无异于股东退股和公司资本的减少，也可能会使公司的发起人股东更注重创业利润的变现，从而不仅在一定程度上<strong>削弱了对债权人利益的保护，而且忽视了公司的长远发展，损害了公司的根本利益</strong>。</p><p>(3)股票回购容易导致公司<strong>操纵股价</strong>。公司回购自己的股票容易导致其利用内幕消息进行炒作，加剧公司行为的非规范化，<strong>损害投资者的利益</strong>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;筹资管理概述&quot;&gt;&lt;a href=&quot;#筹资管理概述&quot; class=&quot;</summary>
      
    
    
    
    <category term="税务师" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/"/>
    
    <category term="财务管理" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
    <category term="3.筹资与股利分配管理" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86/3-%E7%AD%B9%E8%B5%84%E4%B8%8E%E8%82%A1%E5%88%A9%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>1.财务管理-财务预测和财务预算</title>
    <link href="http://example.com/2023/11/07/%E7%A8%8E%E5%8A%A1%E5%B8%88/2.%E8%B4%A2%E5%8A%A1%E9%A2%84%E6%B5%8B%E4%B8%8E%E8%B4%A2%E5%8A%A1%E9%A2%84%E7%AE%97/"/>
    <id>http://example.com/2023/11/07/%E7%A8%8E%E5%8A%A1%E5%B8%88/2.%E8%B4%A2%E5%8A%A1%E9%A2%84%E6%B5%8B%E4%B8%8E%E8%B4%A2%E5%8A%A1%E9%A2%84%E7%AE%97/</id>
    <published>2023-11-07T03:21:35.014Z</published>
    <updated>2023-11-07T05:33:28.864Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="资金需要量预测"><a href="#资金需要量预测" class="headerlink" title="资金需要量预测"></a>资金需要量预测</h1><p>资金需要量预测是指企业根据生产经营的需求，<strong>对未来所需资金的估计和推测</strong>，它<strong>是企业制订融资计划的基础</strong>。</p><h2 id="因素分析法"><a href="#因素分析法" class="headerlink" title="因素分析法"></a>因素分析法</h2><p>因素分析法又称分析调整法, 是以有关项目基期年度的平均资金需要量为基础, 根据预测年度的生产经营任务和资金周转加速的要求进行分析调整, 来预测资金需要量的一种方法。</p><p>这种方法计算简便，容易掌握，但预测结果不太精确。它通常适用于品种繁多、规格复杂、资金用量较小的项目。因素分析法的计算公式为:$$资金需要量 &#x3D;( 基期资金平均占用额 - 不合理资金占用额 ) ×(1 \pm 预测期销售增减率 )×(1- 预测期资金周转速度变动率)$$</p><h2 id="销售百分比法"><a href="#销售百分比法" class="headerlink" title="销售百分比法"></a>销售百分比法</h2><p>销售百分比法，是<strong>假设某些资产、负债与销售额存在稳定的百分比关系，根据该假设预计外部资金需要量的方法</strong>。</p><p>企业的销售规模扩大时，要相应增加流动资产；如果销售规模增加很多，还必须增加长期资产。为取得扩大销售所需增加的资产，企业需要筹措资金。这些资金<strong>一部分来自随销售额同比例增加的流动负债，还有一部分来自预测期的收益留存，另一部分通过外部筹资取得</strong>。</p><table><thead><tr><th>项目</th><th>解读</th><th>举例</th></tr></thead><tbody><tr><td>敏感性  资产</td><td>与销售额保持稳定比例关系  的资产，有时称为“经营性  资产 ”</td><td>包括：库存现金、应收账款、存货等</td></tr><tr><td>敏感性  负债</td><td>与销售额保持稳定比例关系  的负债，有时称为“经营性负债”或“自发性负债”</td><td>包 括 ：应付票据、应付账款等；  不 包 括 ：短期借款、短期融资  券、长期负债等筹资性负债</td></tr></tbody></table><p><img src="/../../pic/2.%E7%A8%8E%E5%8A%A1%E5%B8%88/image-20231107125602896.png" alt="image-20231107125602896"></p><p>第一步:确定随销售额而变动的资产和负债项目。</p><p>第二步:确定有关项目与销售额的稳定比例关系。</p><p>第三步:确定需要增加的资金量。</p><p>需要增加的资金量&#x3D;增加的敏感性资产-增加的敏感性负债</p><p>增加的敏感性资产&#x3D;基期敏感性资产×收入增长率</p><p>或增加的敏感性资产&#x3D;增加的收入×（基期敏感性资产&#x2F;基期营业收入)</p><blockquote><p> 说明:如果存在非敏感性资产增加，需要增加的资金量需要考虑非敏感性资产增加的影响。</p></blockquote><p>第四步:确定增加的留存收益，即预计期的利润留存。预计期的利润留存&#x3D;预计期营业收入×预计期销售净利率×预计期利润留存率</p><p>第五步:确定所需要的外部筹资额。外部融资需求量&#x3D;需要增加的资金量-预计期的利润留存</p><h2 id="资金习性预测法"><a href="#资金习性预测法" class="headerlink" title="资金习性预测法"></a>资金习性预测法</h2><p>资金习性预测法，是指根据资金习性预测未来资金需要量的一种方法。</p><p>所谓<strong>资金习性</strong>，是指<strong>资金的变动同产销量变动之间的依存关系</strong>。按照资金同产销量之间的依存关系，可以把资金区分为<strong>不变资金</strong>、变动资金和<strong>半变动资金</strong>。</p><table><thead><tr><th>类型</th><th>特征</th></tr></thead><tbody><tr><td>不变资金</td><td>在一定的产销量范围内，不受产销量变动的影响而保持固定不  变的那部分资金</td></tr><tr><td>变动资金</td><td>随产销量的变动而同比例变动的那部分资金</td></tr><tr><td>半变动  资金</td><td>虽然受产销量变化的影响，但不成同比例变动的资金，可采用  一定的方法划分为不变资金和变动资金两部分</td></tr></tbody></table><h3 id="高低点法"><a href="#高低点法" class="headerlink" title="高低点法"></a>高低点法</h3><p>根据资金习性模型Y&#x3D;a+bX，利用历史数据中销售收入最高和销售收入最低的两期资料联立方程组，求解a和b。</p><p>b&#x3D;(最高收入期的资金占用量-最低收入期的资金占用量)&#x2F;(最高销售收入-最低销售收入)</p><p>a&#x3D;最高收入期的资金占用量-b×最高销售收入</p><p>或者：</p><p>a&#x3D;最低收入期的资金占用量-b×最低销售收入</p><h3 id="回归法"><a href="#回归法" class="headerlink" title="回归法"></a>回归法</h3><h1 id="利润预测"><a href="#利润预测" class="headerlink" title="利润预测"></a>利润预测</h1><h2 id="本量利分析"><a href="#本量利分析" class="headerlink" title="本量利分析"></a>本量利分析</h2><h3 id="本量利分析的含义"><a href="#本量利分析的含义" class="headerlink" title="本量利分析的含义"></a>本量利分析的含义</h3><p>本量利分析，是指以成本性态分析和变动成本法为基础，对成本、利润、业务量与单价等因素之间的依存关系进行分析，发现变动的规律性的一种方法。其中，“本”是指成本，包括固定成本和变动成本；“量”是指业务量，一般指销售量；“利”一般指利润。</p><h2 id="目标利润分析"><a href="#目标利润分析" class="headerlink" title="目标利润分析"></a>目标利润分析</h2><h2 id="利润敏感性分析"><a href="#利润敏感性分析" class="headerlink" title="利润敏感性分析"></a>利润敏感性分析</h2><h1 id="财务预算"><a href="#财务预算" class="headerlink" title="财务预算"></a>财务预算</h1><h2 id="全面预算"><a href="#全面预算" class="headerlink" title="全面预算"></a>全面预算</h2><p>全面预算包括经营预算、资本支出预算和财务预算三个部分。</p><p><strong>财务预算</strong>主要包括现金预算、预计利润表、预计资产负债表和预计现金流量表。<strong>财务预算</strong>的综合性最强，是预算的核心内容；财务预算的各项指标又依赖于经营预算和资本支出预算。</p><h3 id="财务预算【★★】"><a href="#财务预算【★★】" class="headerlink" title="财务预算【★★】"></a>财务预算【★★】</h3><h4 id="财务预算的内容"><a href="#财务预算的内容" class="headerlink" title="财务预算的内容"></a>财务预算的内容</h4><p>1.现金预算</p><p>现金预算又称现金收支预算，是反映企业在预算期内全部现金流入和现金流出，以及由此预计的现金收支所产生的结果的预算，是<strong>财务预算的核心</strong>。</p><p>2.预计利润表</p><p>预计利润表是反映和控制企业在预算期内损益情况和盈利水平的预算。</p><p>3.预计现金流量表</p><p>预计现金流量表是从现金流入和流出两个方面反映企业经营活动、投资活动和筹资活动所产生的现金流量的预算。</p><p>4.预计资产负债表</p><p>预计资产负债表是用来反映企业在计划期末预计的财务状况，它的编制须以计划期开始日的资产负债表为基础，然后结合计划期间业务预算、专门决策预算、现金预算和预计利润表进行编制。</p><h4 id="财务预算的编制方法"><a href="#财务预算的编制方法" class="headerlink" title="财务预算的编制方法"></a>财务预算的编制方法</h4><p>按出发点的特征不同——增量预算法与零基预算法</p><table><thead><tr><th align="left">维度</th><th align="left">增量预算法</th><th align="left">零基础预算法</th></tr></thead><tbody><tr><td align="left">含义</td><td align="left">以历史期实际经济活动及其预算为基础，通过调整历史期经济活动项目及金额形成预算的预算编制方法</td><td align="left">企业不以历史期经济活动及其预算为基础，以零为起点，从实际需要出发，形成预算的预算编制方法</td></tr><tr><td align="left">假定条件</td><td align="left">企业现有业务活动是合理的，不需要进行调整</td><td align="left"></td></tr><tr><td align="left">假定条件</td><td align="left">企业现有各项业务的开支水平是合理的，在预算期予以保持</td><td align="left"></td></tr><tr><td align="left">假定条件</td><td align="left">以现有业务活动和各项活动的开支水平，确定预算期各项活动  的预算数</td><td align="left"></td></tr><tr><td align="left">优点</td><td align="left">在预算内容上无需作较大的调整</td><td align="left">以零为起点编制，不受历史期的影响，能够灵活应对内外环境的变化，更贴近预算期企业经济活动需要。有助于增加预算编制透明度，有利于进行预算控制。</td></tr><tr><td align="left">缺点</td><td align="left">可能导致无效费用开支项目无法得到有效控制，造成预算上的  浪费</td><td align="left">适用于企业各项预算的编制，特别是不经常发生的预算项目或预算编制基础变化较大的预算项目</td></tr></tbody></table><p>按业务量基础的数量特征不同——固定预算法与弹性预算法</p><table><thead><tr><th>维度</th><th>固定预算法(静态预算法)。</th><th>弹性预算法(动态预算法)。</th></tr></thead><tbody><tr><td>含义</td><td>在编制预算时，只将预算期内正常、可实现的某一固定的业务  量水平作为唯一基础来编制预算的方法</td><td>在成本性态分析的基础上，按照预算期内可能的一系列业务量  水平编制系列预算的方法</td></tr><tr><td>优点</td><td></td><td>考虑了预算期可能的不同业务量水平，更贴近实际情况</td></tr><tr><td>缺点</td><td>适应性差、可比性差</td><td>编制工作量大</td></tr><tr><td>缺点</td><td></td><td>市场预测的准确性、预算项目与业务量之间依存关系的判断水平等会对其合理性造成较大影响</td></tr><tr><td>适用性</td><td>一般适用于经营业务稳定，生产产品产销量稳定，能准确预测  产品需求及产品成本的企业，也可用于编制固定费用预算</td><td>适用于企业各项预算的编制，特别是市场、产能等存在较大不确定性，且其预算项目与业务量之间存在明显的数量依存关系  的预算项目</td></tr></tbody></table><p>按预算期的时间特征不同——定期预算法与滚动预算法</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;资金需要量预测&quot;&gt;&lt;a href=&quot;#资金需要量预测&quot; class</summary>
      
    
    
    
    <category term="税务师" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/"/>
    
    <category term="财务管理" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
    <category term="2.财务预测和财务预算" scheme="http://example.com/categories/%E7%A8%8E%E5%8A%A1%E5%B8%88/%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86/2-%E8%B4%A2%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%92%8C%E8%B4%A2%E5%8A%A1%E9%A2%84%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/03/News/20231103/"/>
    <id>http://example.com/2023/11/03/News/20231103/</id>
    <published>2023-11-03T13:20:29.258Z</published>
    <updated>2023-11-03T13:28:49.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> US stocks recorded their best day in six months as bond yields <strong>tumbled</strong> after the Federal Reserve and other central banks signalled a possible end to the interest rate rise cycle that has hammered financial markets for more than a year. </p><p>Thursday’s rally for stocks and bonds — whose prices move inversely to yields — followed what investors viewed as dovish remarks by Fed chair Jay Powell on Wednesday after the US central bank held rates steady for a second consecutive meeting. </p><p>The dovish mood produced the biggest two-day fall in 10-year Treasury yields, a benchmark for global asset prices, since the US banking crisis of early March. At their lowest point of 4.63 per cent earlier on Thursday, it marked a 0.19 percentage point decline from Wednesday. </p><p>Solita Marcelli, chief investment officer for the Americas at UBS Wealth Management, said: “The meeting underlines our view that the Fed is likely done tightening and that markets had become too aggressive in pricing higher rates for longer.” The S&amp;P 500 stock index gained 1.9 per cent for its best one-day performance since March, helped by strong earnings from the likes of Starbucks, which ended the day up 9.5 per cent.</p><p> Powell emphasised the Fed was “proceeding carefully” with future rate rises, which investors took as a sign bond markets have largely succeeded in slowing down the US economy. However, he also warned the central bank “was not confident yet” that monetary policy was sufficiently restrictive to bring inflation back to its 2 per cent target. The Fed decided to keep its benchmark funds rate on hold at between 5.25 per cent and 5.5 per cent at its meeting that ended on Wednesday. On Thursday, the Bank of England also voted 6-3 to hold rates steady at 5.25 per cent while Norway’s central bank left its rates unchanged too. The scale of the investor reaction to the Fed chair’s comments underlined how anxious many are to see the end of the monetary tightening that have increased borrowing costs for households and businesses across the world. Previous Fed rate rises and a big expansion in the US government’s borrowing plans had contributed to the prolonged sell-off that last month pushed 10-year yields above 5 per cent for the first time in 16 years. If the shift lower in yields is sustained, it could have profound implications for governments’ and companies’ cost of capital after a long sell-off that has hit bondholders.  Investors have been wrongfooted in the past by prematurely calling an end to the Fed’s rate rise cycle. But Tiffany Wilding, managing director at bond investment house Pimco, argued Powell’s comments did not appear to be preparing the market for a possible rate rise in December, “and as a result you are getting some loosening in financial conditions”. The Treasury department announced on Wednesday it would slow the pace at which it issues longer-dated debt, which also pulled US government bond yields lower. Government bond markets also rallied across Europe on Thursday. Two-year UK gilt yields, which reflect interest rates expectations, fell 0.09 percentage points to 4.70 per cent, the lowest level since June. Benchmark 10-year gilt yields fell 0.15 percentage points to 4.35 per cent. Ten-year German bond yields — the benchmark for the eurozone — slipped 0.05 percentage points to 2.7 per cent after jobs data suggested the country’s economy was stagnating.</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt; US stocks recorded their best day in </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/03/%E8%BD%AF%E8%80%83/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/11/03/%E8%BD%AF%E8%80%83/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/</id>
    <published>2023-11-03T02:40:39.554Z</published>
    <updated>2023-11-03T09:17:29.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>◆用例图:主要考察参与者和用例的识别、用例之间的关系（包含include,扩展extend、泛化)。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103104203934.png" alt="image-20231103104203934"></p><p>类图:主要考察填类名、多重度、类之间的联系</p><p>◆<strong>多重度</strong>（有点类似于E-R图中的联系类型)含义如下:</p><p>1:1表示一个集合中的一个对象对应另一个集合中1个对象。</p><p>0到*:*表示一个集合中的一个对象对应另一个集合中的0个或多个对象。</p><p>1到*:表示一个集合中的一个对象对应另一个集合中的一个或多个对象。</p><p>*:表示一个集合中的一个对象对应另一个集合中的多个对象。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103104618976.png" alt="image-20231103104618976"></p><p>◆状态图主要描述<strong>状态之间的转换</strong>，主要考察的就是填状态名、填状态转换的条件，具体如图所示。</p><p>◆转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。状态图中转换和状态是两个独立的概念，如下∶图中方框代表状态，箭头上的代表<strong>触发事件</strong>，<strong>实心圆点为起点和终点</strong>。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111252555.png" alt="image-20231103111252555"></p><p>◆序列图:即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p><p>◆主要考察填对象名、消息名，消息就是一个个箭头上传递的，对象作为实体在最上端。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111405002.png" alt="image-20231103111405002"></p><p>◆通信图:是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图。</p><p>◆主要考察填对象、填消息。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111510006.png" alt="image-20231103111510006"></p><p>◆活动图:动态图，是一种特殊的状态图，展现了在系统内从一个活动到另一个活动的流程。活动的分岔和汇合线是一条水平粗线。主要考察填活动名称。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111542380.png" alt="image-20231103111542380"></p><h1 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h1><p>◆由前面的介绍可知，考察UML建模就是考察多种图形，对这些图形的考察一般都是缺失一些关键点，而后要求考生补图。</p><p>◆要求认真<strong>审题</strong>，根据题干说明补齐类名或者对象名或者消息名等等，记住类图和对象图中的多重度（互相独立的分析，掌握表示方法)、类之间的联系标识(多边形端为整体，直线端为个体)。</p><p>◆认真审题，审图，根据说明查缺补漏，一般来说有以下几种题型:</p><p>1、补充用例图:主要考察补充<strong>用例名称、参与者、用例之间的关系</strong>，只要认真审题，根据题中描述核对，都可以轻易得出答案。</p><p>2、补充类图:主要考察补充<strong>类名称</strong>，<strong>需要根据类之间的关系以及多重度来判断</strong>，需要<strong>牢记类之间关系的图形符</strong>号，尤其是组合、聚合和泛化的符号，并且观察符号上的多重度数字，与题目描述对应。</p><p>3、补充状态图:主要补充<strong>状态名称</strong>，根据题目描述可以轻易得出答案。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Q:看到一张类图都是空的，就懵了，该怎么办?A∶类和类之间的联系，尤其是泛化联系是非常重要的，也是解题的关键，要记住泛化联系的符号，而后去题目描述里找到具有父子关系的实体，基本上题目就一步步解出来了。其他如组合、聚合联系的符号也是解题关键。</p><p>Q:这种题目该怎么学习，学习到哪种程度呢?A∶:要求能拿到12分以上;看完视频对应专题课程后，立即去做历年真题，掌握技巧。</p><p>用例图主要用来描述角色以及角色与用例之间的<strong>连接关系</strong>。说明的是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了<strong>多个模型元素</strong>，如系统、参与者和用例，并且<strong>显示这些元素之间的各种关系</strong>，如<strong>泛化</strong>、<strong>关联</strong>和<strong>依赖</strong>。它展示了一个外部用户能够观察到的系统功能模型图。</p><p>【用途】：帮助开发团队以一种可视化的方式理解系统的功能需求。</p><h1 id="用例图详解"><a href="#用例图详解" class="headerlink" title="用例图详解"></a>用例图详解</h1><h2 id="用例图所包含的的元素"><a href="#用例图所包含的的元素" class="headerlink" title="用例图所包含的的元素"></a><strong>用例图所包含的的元素</strong></h2><p><strong>1.</strong> <strong>参与者(Actor)——</strong>与应用程序或系统进行交互的用户、组织或外部系统。<strong>用一个小人表示</strong>。</p><p>　　　　　　　　　　　　　　　　<img src="https://images0.cnblogs.com/blog2015/775886/201506/201151512167414.png" alt="img"></p><p><strong>2.</strong> <strong>用例(Use Case)——</strong>用例就是<u>外部可见的系统功能，对系统提供的服务进行描述</u>。<strong>用椭圆表示</strong>。</p><p>　　　　　　　　　　　　 <img src="https://images0.cnblogs.com/blog2015/775886/201506/201156222169755.png" alt="img"></p><p><strong>3. 子系统(Subsystem)——</strong>用来展示系统的一部分功能，这部分功能联系紧密。</p><p>　　　　<img src="https://images0.cnblogs.com/blog2015/775886/201506/201522249517205.png" alt="img"></p><h2 id="二、用例图所包含的的关系"><a href="#二、用例图所包含的的关系" class="headerlink" title="二、用例图所包含的的关系"></a>二、用例图所包含的的关系</h2><p>　　用例图中涉及的关系有：<strong>关联</strong>、<strong>泛化</strong>、<strong>包含</strong>、<strong>扩展</strong>。</p><p>　　如下表所示：</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201541429987815.png" alt="img"></p><p>　　<strong>a. 关联(Association)</strong></p><p>　　<strong>表示参与者与用例之间的通信，任何一方都可发送或接受消息。</strong></p><p>　　【箭头指向】：无箭头，将参与者与用例相连接，指向消息接收方</p><p>　　<img src="https://images0.cnblogs.com/blog2015/775886/201506/201545377481898.png" alt="img"></p><p>　　<strong>b. 泛化(Inheritance)</strong></p><p>　　就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。</p><p>　　【箭头指向】：指向父用例</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201746081706263.png" alt="img"></p><p>　　<strong>c. 包含(Include)</strong></p><p>　　包含关系用来<strong>把一个较复杂用例所表示的功能分解成较小的步骤</strong>。包含关系对典型的应用就是复用，也就是定义中说的情景。但是有时当某用例的事件流过于复杂时，为了简化用例的描述，我们也可以把某一段事件流抽象成为一个被包含的用例；相反，用例划分太细时，也可以抽象出一个基用例，来包含这些细颗粒的用例。这种情况类似于在过程设计语言中，将程序的某一段算法封装成一个子过程，然后再从主程序中调用这一子过程。</p><p>　　例如：业务中，总是存在着维护某某信息的功能，如果将它作为一个用例，那添加、修改以及删除都要在用例详述中描述，过于复杂；如果分成添加用例、修改用例和删除用例，则划分太细。这时包含关系可以用来理清关系。</p><p>　　【箭头指向】：指向分解出来的功能用例</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201813400459106.png" alt="img"></p><p>　　<strong>d. 扩展(Extend)</strong></p><p>　　扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中。扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。</p><p>对于一个扩展用例，可以在基用例上有几个扩展点。</p><p>　　【箭头指向】：指向基础用例</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201822539989736.png" alt="img"></p><p>　　<strong>e. 依赖(Dependency)</strong></p><p>　　以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。</p><p>　　【箭头指向】：指向被依赖项</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201825317797833.png" alt="img"></p><p>　　<strong>5. 项目(Artifact)</strong></p><p>　　用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，VS2010中引入了“项目”这样一个元素，以便让开发人员能够在用例图中链接一个普通文档。</p><p>　　用依赖关系把某个用例依赖到项目上：</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201834316387902.png" alt="img"></p><p>　　然后把项目-&gt;属性的Hyperlink设置到你的文档上；</p><p>　　这样当你在用例图上双击项目时，就会打开相关联的文档。</p><p>　　<strong>6. 注释(Comment)</strong></p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201837532489411.png" alt="img"></p><p>　　**包含(include)****、扩展(extend)**<strong>、泛化(Inheritance)</strong> <strong>的区别：</strong></p><p>　　条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；</p><p>　　直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。</p><p>　　对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。</p><p>　　对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</p><p>　　●泛化侧重表示子用例间的互斥性；</p><p>　　●包含侧重表示被包含用例对Actor提供服务的间接性；</p><p>　　●扩展侧重表示扩展用例的触发不定性；</p><p>　　另外一点需要提及的是：泛化中的子用例和扩展中的扩展用例均可以作为基本用例事件的备选择流而存在。</p><p><strong>三、几个用例图示例</strong></p><p><img src="https://pic001.cnblogs.com/images/2012/1/2012013015315117.gif" alt="img"></p><p>　　以下为某在线购物系统的用例图，对系统做出做了整体的描绘。</p><p>　　(1)系统整体用例图</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/11.jpg" alt="img"></p><p>(商品用例图)</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/22.jpg" alt="img"></p><p>（购买信息用例</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/test.jpg" alt="img"></p><p>**  (用户资料用例)**</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/44.jpg" alt="img">**</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/02/%E8%BD%AF%E8%80%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/11/02/%E8%BD%AF%E8%80%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-02T11:52:12.594Z</published>
    <updated>2023-11-02T13:29:24.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102195806879.png" alt="image-20231102195806879"></p><p>创建型模式；对象实例化的模式，创建型模式用于解耦对象的实例化过程。 </p><p>结构型模式；把类或对象结合在一起形成一个更大的结构。 </p><p>行为型模式：类和对象如何交互，及划分责任和算法。</p><h1 id="Ep-UML类-图"><a href="#Ep-UML类-图" class="headerlink" title="Ep_UML类 图"></a>Ep_UML类 图</h1><h2 id="1-1统一建模语言-Unified-Modeling-Language-是用来设计软件的可视化建模语言。"><a href="#1-1统一建模语言-Unified-Modeling-Language-是用来设计软件的可视化建模语言。" class="headerlink" title="1.1统一建模语言 (Unified  Modeling   Language) 是用来设计软件的可视化建模语言。"></a>1.1统一建模语言 (Unified  Modeling   Language) 是用来设计软件的可视化建模语言。</h2><p>UML类图学习目标:能看懂类图中各个类之间的线条、箭头代表什么意思后，看后面章节的设计模式结构图和期末画UML图没有任何问题。</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102200133286.png" alt="image-20231102200133286"></p><p>属性&#x2F;方法名称前加的 加号和减号表示了这个属性&#x2F;方法的【可见性】</p><h2 id="1-2UML-类图中表示可见性的符号有三种："><a href="#1-2UML-类图中表示可见性的符号有三种：" class="headerlink" title="1.2UML 类图中表示可见性的符号有三种："></a>1.2UML 类图中表示可见性的符号有三种：</h2><p>+:表示public</p><p>-:表示private</p><p>#:表示protected</p><p>属性的完整表示方式是：可见性名称：类型[&#x3D;默认值]</p><p>方法的完整表示方式是：可见性名称(参数列表)[: 返回类型] </p><h2 id="1-3类与类之间关系的表示方式"><a href="#1-3类与类之间关系的表示方式" class="headerlink" title="1 .3类与类之间关系的表示方式"></a>1 .3类与类之间关系的表示方式</h2><blockquote><p>实现、继承、聚合的使用最为频繁。</p></blockquote><h3 id="1-3-1关联关系"><a href="#1-3-1关联关系" class="headerlink" title="1.3.1关联关系"></a>1.3.1关联关系</h3><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学 生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合 关系和组合关系。我们先介绍关联。</p><p>关联又可以分为单向关联，双向关联，自关联 </p><h4 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h4><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102200827741.png" alt="image-20231102200827741"></p><p>单向关联用一个带箭头的实线表示。 上图表示每 个乘车人都有一个车票。</p><h4 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h4><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102200943761.png" alt="image-20231102200943761"></p><p> 双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类 图 中 ， 双 向 关 联 用 一 个 不 带 箭 头 的 直 线 表 示 。</p><p>上图中在Customer 类中维护一个List<Product>, 表示一个顾客可以购买多个商品；</p><p>在Product 类中维护一个Customer 类型的成员变量表示这个产品被哪个顾客所购买。</p><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102201056514.png" alt="image-20231102201056514"> </p><p>用一个带有箭头且指向自身的线表示。上图的意思就是Point类包含类型为Point的成员变量</p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系是整体和部分之间的关系。例如一个部门由多个员工组成；</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102201151641.png" alt="image-20231102201151641"></p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；</strong></p><p>例如，部门撤销了，人员不会消失，他们依然存在；</p><p>空心菱形</p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。 <strong>一旦整体对象不存在，部分对象也将不存在</strong></p><p>例如：公司不存在了，部门也将不存在了；</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203051928.png" alt="image-20231102203051928"></p><p>实心菱形</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>它是对象之间耦合度最弱的一种关联方式，是<strong>临时性的关联</strong>.某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问被依赖类中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的<strong>虚线</strong>来表示</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203140021.png" alt="image-20231102203140021"></p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系， 是父类与子类之间的关系， 是一种继承关系。</p><p>用带空心三角箭头的实线来表示</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203736041.png" alt="image-20231102203736041"></p><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>在这种关系中，类实现了接口所有的抽象操作。</p><p>实现关系使用带<strong>空心三角箭头的虚线来表示</strong>，箭头从实现类指向接口</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203812637.png" alt="image-20231102203812637"></p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps56.png" alt="img"> </p><h1 id="软-件-设-计-原-则"><a href="#软-件-设-计-原-则" class="headerlink" title="软 件 设 计 原 则"></a>软 件 设 计 原 则</h1><h2 id="2-1-开闭原则"><a href="#2-1-开闭原则" class="headerlink" title="2.1.开闭原则"></a>2.1.开闭原则</h2><p>开闭原则简单来说就是以前写过的代码你就不要动了，在我们实际的开发过程中修改代码是一件很危险 的事情，弄不好就引起一堆的问题，但是可以扩展以前的代码。这个其实就是代码要有很好的可扩展</p><p>性，咱们的需求每天都在变，要怎么做到不修改原有代码的情况下来进行扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c1ass car&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> string name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">car</span><span class="params">(string name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">()</span>&#123;</span><br><span class="line">system.out.println(<span class="string">&quot;&quot;</span>我速度最大是120KM/h<span class="string">&quot;) ;</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">public class Test99 &#123;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">public static void main(string[] args) &#123;</span></span><br><span class="line"><span class="string">car bmw = new car(&quot;</span>BMw<span class="string">&quot;&quot;</span>);</span><br><span class="line">bmw.driver();</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我 们 新 发 布 了 一 款BMW 概念车，想要修改他的最大速度为180km&#x2F;h, 该 怎 么 做 ?</p><p>我 们 不 要 直 接 修 改driver 方法，而是去做拓展，怎么做?</p><h2 id="2-2-单一职责原则"><a href="#2-2-单一职责原则" class="headerlink" title="2.2.单一职责原则"></a>2.2.单一职责原则</h2><h2 id="隔离接口原则"><a href="#隔离接口原则" class="headerlink" title="隔离接口原则"></a>隔离接口原则</h2><p>这一原则指导我们在开发的过程中一个类最好只干一方面的事情。</p><h2 id="2-4-里氏替换原则"><a href="#2-4-里氏替换原则" class="headerlink" title="2.4.里氏替换原则"></a>2.4.里氏替换原则</h2><p>在有继承关系的代码开发中，如果需要进行功能的扩展，不要在子类中改变父类中已经实现的方法， 而是通过新增方法来扩展父类的功能</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps73.png" alt="img"></p><h2 id="2-5-依赖倒置原则"><a href="#2-5-依赖倒置原则" class="headerlink" title="2.5.依赖倒置原则"></a>2.5.依赖倒置原则</h2><p>我们在定义类的成员变量、参数类型、返回值类型的时候，不要写某个具体的实现类，而尽量采用接口 或者抽象类，这样后续如果我们想改，很显然不需要改动这些代码，而只需要增加实现类就可以了。</p><h2 id="2-6-合成复用原则"><a href="#2-6-合成复用原则" class="headerlink" title="2.6.合成复用原则"></a>2.6.合成复用原则</h2><p>当父类发生改变时，其子类也会被动发生改变。</p><p>在编写代码时如果需要使用其它类，那么两个类之间尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps83.png" alt="img"></p><h2 id="2-7-迪米特法则"><a href="#2-7-迪米特法则" class="headerlink" title="2.7.迪米特法则"></a>2.7.迪米特法则</h2><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调 用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><h1 id="单-例-模-式"><a href="#单-例-模-式" class="headerlink" title="单 例 模 式"></a>单 例 模 式</h1><p>Singleton Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102205029002.png" alt="image-20231102205029002"></p><p>这个类<strong>提供了一种唯一访问对象的方式，可以直接访问， 不需要实例化该类的对象</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singletonPatternDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">string</span>[] args</span>) &#123;</span><br><span class="line"><span class="regexp">/ /</span>singleobject <span class="built_in">object</span> = <span class="keyword">new</span> <span class="title function_">singleobject</span>();编译时错误:构造函数 <span class="title function_">sing1eobject</span>(是不可见的</span><br><span class="line"><span class="comment">//获取唯一可用的对象</span></span><br><span class="line">singleobject <span class="built_in">object</span> = singleobject.<span class="title function_">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分为饿汉式:(太饿了,直接实例化instance)<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class sing1eton &#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span><span class="keyword"> static</span> singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>singleton(;private singleton o&#123;&#125;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> singleton getInstance( &#123;return instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">懒汉式:(比较懒,用我的时候我再实例化instance)</span><br><span class="line">线程不安全<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class sing1eton &#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span><span class="keyword"> static</span> singleton instance;private singleton o&#123;]&#125;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> synchronized singleton getInstance( &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">if </span>(instance -= nu11 &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">instance </span>=<span class="built_in"> new </span>singleton(;</span><br><span class="line">&#125;<span class="built_in"></span></span><br><span class="line"><span class="built_in">return </span>instance;</span><br><span class="line">&#125;</span><br><span class="line">线程安全<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class singleton &#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span> volatile<span class="keyword"> static</span> sing1eton singleton;private singleton (&#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> singleton getsingleton( &#123;if (singleton == nu11) &#123;</span><br><span class="line">synchronized (singleton.c1ass) &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">if </span>(singleton == nu17) &#123;</span><br><span class="line">singleton =<span class="built_in"> new </span>singleton(;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="built_in"></span></span><br><span class="line"><span class="built_in">return </span>singleton;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用 volatile 修饰是很有必要的，因为 singleton  &#x3D;new  Singleton()这句话可以分为三 步：</p><p>1.为 singleton 分配内存空间；</p><p>2.初始化 singleton;</p><p>3.将 singleton 指向分配的内存空间。</p><p>但是由于JVM具有指令重排的特性，执行顺序有可能变成1-3-2。指令重排在单线程下不会出 现问题，但是在多线程下会导 致一个线程获得一个未初始化的实例。例如：线程T1执行了 1和3,此时T2调用 getlnstance() 后发现 singleton 不为空，因此返回 singleton,  但是此时 的 singleton 还没有被初始化。使用 volatile 会禁止JVM 指令重排，从而保证在多线程下也能 正常执行</p><h1 id="工-厂-模-式"><a href="#工-厂-模-式" class="headerlink" title="工 厂 模 式"></a>工 厂 模 式</h1><p>Factory Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102205724885.png" alt="image-20231102205724885"> </p><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类， 工厂模式使其创建过程延迟到子类进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>创建一个接口。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤 <span class="number">2</span>创建实现接口的实体类。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">( &#123;system.out.print7n(<span class="string">&quot; Rectangle: : draw( method. &quot;</span>)</span>;&#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">square</span> <span class="keyword">implements</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">system.out.println(<span class="string">&quot; square : :draw( method. &quot;</span>);</span><br><span class="line">&#125;&#125;</span><br><span class="line">                     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">circle</span> imp1ements shape &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">system.out.println(<span class="string">&quot; circ1e : : draw( method. &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//步骤3创建一个工厂，生成基于给定信息的实体类的对象。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">shapeFactory</span> &#123;</span><br><span class="line"><span class="comment">//使用getshape 方法获取形状类型的对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> shape <span class="title function_">getshape</span><span class="params">(string shapeType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shapeType == nu11) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shapeType.equalsIgnorecase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">circle</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equa1sIgnorecase(<span class="string">&quot;RECTANGLE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectang1e</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equa7sIgnorecase(<span class="string">&quot;sQUARE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">squareo</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//步骤4通过传递类型信息来获取实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">shapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">shapeFactory</span>();</span><br><span class="line"><span class="comment">//获取 circle 的对象，并调用它的draw 方法</span></span><br><span class="line">        <span class="type">shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getshape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"><span class="comment">//调用circle 的draw方法</span></span><br><span class="line">        shape1.draw() ;</span><br><span class="line"><span class="comment">//获取Rectangle 的对象，并调用它的draw方法</span></span><br><span class="line">        <span class="type">shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getshape(<span class="string">&quot;RECTANGLE&quot;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">//调用Rectangle 的draw方法</span></span><br><span class="line"><span class="string">        shape2.draw();</span></span><br><span class="line"><span class="string">//获取Square 的对象，并调用它的draw 方法</span></span><br><span class="line"><span class="string">        shape shape3 = shapeFactory.getshape(&quot;</span>sQUARE<span class="string">&quot;);</span></span><br><span class="line"><span class="string">//调用Square 的draw方法</span></span><br><span class="line"><span class="string">        shape3.draw();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="抽-象-工-厂-模-式"><a href="#抽-象-工-厂-模-式" class="headerlink" title="抽 象 工 厂 模 式"></a>抽 象 工 厂 模 式</h1><p>Abstract Factory Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102211020547.png" alt="image-20231102211020547"> </p><p>提供一个创建一系列产品族的接口，而无需指定它们具体的类。</p><p>那什么是产品族? 看下图，不同的产品等级结构的一组产品组成产品族</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102211107521.png" alt="image-20231102211107521"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂，生产手机和平板两种东西：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">newPhone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Pad <span class="title function_">newPad</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：苹果工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">newphone</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;新牛出生!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Applephone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Pad <span class="title function_">newPad</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;蔬菜长成!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplePad</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：华为工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">newPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;新马出生!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Huaweiphone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Pad <span class="title function_">newPad</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.print1n(<span class="string">&quot;水果长成!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPad</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品：手机</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：平板</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Pad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：苹果手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplePhone</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是苹果Phone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：苹果Pad</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Applepad</span> <span class="keyword">implements</span> <span class="title class_">Pad</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是ApplePad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：华为手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huaweiphone</span> <span class="keyword">implements</span> <span class="title class_">phone</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是HuaweiPhone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：华为Pad</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huaweipad</span> <span class="keyword">implements</span> <span class="title class_">Pad</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是华为Pad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryPatternDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="type">Pad</span> <span class="variable">pad</span> <span class="operator">=</span> apple.newPad();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> apple.newphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建-造-者-模-式"><a href="#建-造-者-模-式" class="headerlink" title="建 造 者 模 式"></a>建 造 者 模 式</h2><p>Builder  Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102212451001.png" alt="image-20231102212451001"></p><p>将一个复杂的构建与其实现相分离，使得同样的构建过程可以创建不同的表示。</p><p>这个抽象建造方法就是一张建造的图纸，后面实现这个接口的类是具体的建造图纸，把具体的建造图纸用set注入的方式给指挥者类干活，最后根据具体图纸完成产品!</p><p>应用实例：1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出 所谓的“套餐”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">举例：一个产品由A B两种构件组成，</span><br><span class="line">产品1A ,B两个构件是金子做的，(不是瓜皮子A_^)</span><br><span class="line">产品2A ,B两个构件是碳纤维做的</span><br><span class="line">两种价格不一样</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builder</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">builder.BuildPartA();</span><br><span class="line">builder.BuildPartB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BuildPartA</span><span class="params">()</span>; <span class="comment">//产品的A部件</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BuildPartB</span><span class="params">()</span>; <span class="comment">//产品的B部件</span></span><br><span class="line">Product <span class="title function_">getResult</span><span class="params">()</span>; <span class="comment">//获取产品建造后结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteBuilder1</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"><span class="comment">//设置产品零件</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartA</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartA(<span class="string">&quot;碳纤维做的A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartB</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartB(<span class="string">&quot;碳纤维做的B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组建一个产品</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder2</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"><span class="comment">//设置产品零件</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartA</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartA(<span class="string">&quot;金子做的A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartB</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartB(<span class="string">&quot;金子做的B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组建一个产品</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String partA;</span><br><span class="line"><span class="keyword">private</span> String partB;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.partA = partA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setpartB</span><span class="params">(String partB)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.partB = partB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">system.out.print1n(<span class="string">&quot;我的组成部件-parta:&quot;</span>+partA+<span class="string">&quot;- partB:&quot;</span>+ partB);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder1</span>();</span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder2</span>();</span><br><span class="line"><span class="comment">//指挥者用ConcreteBuilder1的方法来建造产品</span></span><br><span class="line">director.builder(builder1);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> builder1.getResult();</span><br><span class="line">product1.show()</span><br><span class="line"><span class="comment">//指挥者用ConcreteBuilder2的方法来建造产品</span></span><br><span class="line">director.builder(builder2);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product2</span> <span class="operator">=</span> builder2.getResult();</span><br><span class="line">product2.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="适-配-器-模-式"><a href="#适-配-器-模-式" class="headerlink" title="适 配 器 模 式"></a>适 配 器 模 式</h1><p>Adapter   Pattern</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;img src=&quot;/../../pic/%E8%AE%BE%E8%AE%A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/01/%E8%BD%AF%E8%80%83/Java%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/11/01/%E8%BD%AF%E8%80%83/Java%E8%AF%AD%E6%B3%95/</id>
    <published>2023-11-01T12:17:08.634Z</published>
    <updated>2023-11-02T12:34:24.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="设计对象并使用"><a href="#设计对象并使用" class="headerlink" title="设计对象并使用"></a>设计对象并使用</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>●类(设计图) :是对象共同特征的描述;</p><p>●对象:是真实存在的具体东西。<strong>在Java中，必须先设计类，才能获得对象。</strong></p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101202446788.png" alt="image-20231101202446788"></p><p>总结：</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101202647693.png" alt="image-20231101202647693"></p><p>●类名首字母建议大写， 需要见名知意，驼峰模式。</p><p>●一个Java文件中可以定义多个class类, 且只能一 个类是public修饰，而且public修饰的类名必须成为代码文件名。实际开发中建议还是一个文件定义一个class类。</p><p>●<strong>成员变量的完整定义格式是 :修饰符-数据类型-变量名称&#x3D;初始化值;一般无需指定初始化值,存在默认值。</strong></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><a href="https://www.bilibili.com/video/BV1dR4y1o7ER?t=135.3&p=3">https://www.bilibili.com/video/BV1dR4y1o7ER?t=135.3&amp;p=3</a></p><blockquote><p> 封装、继承、多态是面向对象的三大特征。</p></blockquote><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</strong></p><p>比如人画圆，对象应该是圆，而不是人。</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101203539964.png" alt="image-20231101203539964"></p><h2 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h2><p>●是一个权限修饰符</p><p>●可以修饰成员 (成员变量和成员方法)</p><p>●被private修 饰的成员只能在本类中才能访问</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101205642618.png" alt="image-20231101205642618"></p><p>在设置age为私有成员后，直接调用age的值是不可行的。</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101205656548.png" alt="image-20231101205656548"></p><p>正确的案例如下：</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101205925575.png" alt="image-20231101205925575"></p><blockquote><p>私有变量只能在其被声明的类内部直接通过“点”（<code>.</code>）运算符进行访问。私有变量的可见性仅限于声明它们的类，并且对于其他类或外部代码是不可见的。</p><p>这是封装的一种体现，通过将变量声明为私有，可以隔离和保护类的内部实现细节。这样可以确保类的数据的安全性和一致性，并提供更好的控制和管理数据的方式。</p><p>如果需要在其他类中访问私有变量，可以通过在类中提供公共的访问方法（如“getter”方法）来间接地获取私有变量的值。通过公共访问方法，<strong>可以控制对变量的访问</strong>，并提供对私有变量的安全访问。</p><p>需要注意的是，私有变量只能在声明它们的类中直接访问，而不是“定义模块”，因为定义模块可能包含多个类。</p></blockquote><h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    </span><br><span class="line">name=name;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该段代码不能正确地给name赋值。</p><p><strong>就近原则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据就近原则，System.out.println(age);输出的age是方法中的age。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">System.out.println(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System.out.println(age);输出的age是成员变量age。</p><p><strong>this.age</strong>指的就是成员变量age。<strong>this的作用就是区分局部变量和成员变量</strong>。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法也叫作构造器、构造函数。</p><p>作用:<strong>在创建对象的时候给成员变量进行初始化的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    </span><br><span class="line">修饰符   类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点:</p><p>1.方法名与类名相同，大小写也要一致</p><p>2.没有返回值类型，连void都没有</p><p>3.没有具体的返回值(不能由retrun带回结果数据)</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101212838813.png" alt="image-20231101212838813"></p><p>如果没有写任何构造方法，虚拟机将会自动加入一个空参构造方法。</p><p>没创建一个对象，都会调用一次构造函数。</p><p><strong>构造方法注意事项</strong></p><p>如果没有定义构造方法， 系统将给出一个默认的无参数构造方法；如果定义了构造方法，系统将不再提供默认的构造方法。</p><p>带参构造方法, 和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载。</p><p>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法。</p><h1 id="标准-JavaBean"><a href="#标准-JavaBean" class="headerlink" title="标准 JavaBean"></a>标准 JavaBean</h1><h2 id="标准的JavaBean类"><a href="#标准的JavaBean类" class="headerlink" title="标准的JavaBean类"></a>标准的JavaBean类</h2><p>①类名需要见名知意。</p><p>②成员变量使用private修饰。</p><p>③提供至少两个构造方法。</p><p>●无参构造方法</p><p>●带全部参 数的构造方法</p><p>④成员方法。</p><p>●<strong>提供每一个成员 变量对应的setXxx()&#x2F; getXxx()</strong></p><p>●如果还有其他行为， 也需要写上。</p><h1 id="封装、继承、多态、抽象与接口"><a href="#封装、继承、多态、抽象与接口" class="headerlink" title="封装、继承、多态、抽象与接口"></a>封装、继承、多态、抽象与接口</h1><h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h2><p>封装意味着将数据的细节隐藏起来，仅公开有限的接口接口给用户。我们通过两种方式实现，第一种就是将类中的数据变为private，另一种便是提供get和set方法给外界，限制用户操作类数据的方式。</p><p>比如我们有一个Game类，其中有一个score数据：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Game</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义有很大的缺点：<strong>外界可以直接操作score数值</strong>，可以将其设置为无限大或无限小，甚至胡乱操作。我们就可以将其数据变为private，并创建get和set给外界来操作此数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Score Error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过创建getScore和setScore来限制用户操作score的方式，在setScore中，我们会检查数据的值是否符合我们的设定，如果违规（小于0或大于100），那么此操作就无法完成。<strong>通过封装，我们限制用户使用类的方式，只提供外界一个黑匣子，以保证数据的安全</strong>。</p><h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h2><p>在面对对象编程中，在我们已经创建了一个类后，而又想<strong>再创建一个与之相似的类，比如添加新的方法，或者修改原来的方法</strong>。我们不必从头开始，可以从原来的类派生出新的类，我们把原来的类称为父类或基类，而派生出来的类称为子类，<strong>子类则会继承父类的数据和方法</strong>。</p><p>让我们看一个简单的例子，首先我们定义一个Animal类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想创建一个 Dog 类，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;WangWang..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Dog类和Animal类几乎是一样的，只是 greet 方法略有不同，我们完全没必要创建一个新的类，可以直接创建子类（child class）来继承父类Animal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//调用父类的构造方法Animal（name）；-&gt;Animal.name=name;=&gt;Dog.name=name;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WangWang..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog类是从 Animal 类继承而来的，Dog类自动获得了 Animal 类的数据和方法，这些数据和方法必须是子类能够访问到的范围，被public和protected修饰的数据和方法就能被子类访问到。<strong>在Dog的构建函数中，我们调用了super(name)，这就意味着Dog调用了Animal的Animal(String name)函数，将自己的name数据初始化为参数name的数值。</strong></p><p>子类还可以对父类继承来的方法进行修改，Dog就对父类中的greet进行了重写（Override），并且还新增了一个方法 run。我们调用父类和子类对比一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">        animal.greet(); <span class="comment">// Hello, I am animal</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.greet(); <span class="comment">// WangWang..., I am dog</span></span><br><span class="line">        dog.run(); <span class="comment">// I am running!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h2><p><a href="https://www.bilibili.com/video/BV147411W7Af?t=824.9">https://www.bilibili.com/video/BV147411W7Af?t=824.9</a></p><p>多态的概念其实不难理解，它是指针对不同类型的参数进行相同的操作，<strong>根据对象（或类）类型的不同而表现出不同的行为</strong>。比如在我们刚学的继承中，子类可以拿到父类的数据和方法，也可以重写父类的方法，还可以新增自己特定的方法。有了继承，就能实现多态，便可以为不同的数据类型的实现提供统一的接口。比如我们再创建一个Animal的子类Cat：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;MiaoMiao..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建两个都是Animal类型的变量cat和dog，并将它们具体实例化成Cat和Dog类，那么当我们调用cat和dog的 greet 方法，它们则会自动调用实际类型的 greet 方法，做出不同的响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        cat.greet(); <span class="comment">// MiaoMiao..., I am cat</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.greet(); <span class="comment">// WangWang..., I am dog</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h2><p>数据抽象的意思是<strong>隐藏细节</strong>，只暴露最重要的信息给用户。<strong>抽象可以通过 abstract class 或 interface（接口）实现</strong>。abstract 关键字是一个用于类和方法的修饰符，我们<strong>无法创建 abstract class 类型的实例</strong>，这种抽象类只能被继承。而abstract method只能定义在abstract class中，这种方法没有具体执行内容。一个抽象类既可以有抽象方法也可以有正常的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zzz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们创建了一个抽象类Person，如果我们运行以下的代码则会报错，因为我们无法给抽象类创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p><strong>要使用抽象类，我们必须创建一个类继承它</strong>，比如我们创建一个Teenager继承Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teenager</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am a teenager.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，<strong>如果一个类继承了抽象类，那么此类必须要实现抽象类中定义的抽象方法，不然会报错</strong>，所以Teenager就必须要实现greet方法，下面是Teenager的调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Teenager</span> <span class="variable">teenager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teenager</span>();  </span><br><span class="line">        teenager.greet(); <span class="comment">// I am a teenager.</span></span><br><span class="line">        teenager.sleep(); <span class="comment">// Zzz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h2><p>另一个实现数据抽象的方式就是使用接口（interface）。<strong>一个接口就是完全的抽象类，其中只含有抽象方法，这些方法中是没有任何逻辑代码的</strong>。<u>类的主要作用便是定义一些特定的方法</u>，具体逻辑让正常的类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果要使用接口的方法，那么具体的类必须实现（implements）其接口</strong>。只要被实现，具体的类必须将接口方法的具体逻辑全部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to school.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m taking an exam.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口，我们可以再定义一个Employee类，并将其加到Person implements后，不同接口之间用逗号隔开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Employee</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSalary</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Student</span>, Employee &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to school&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m taking an exam&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to work.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I just got the salary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能从Person类中调用接口中全部的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">        person.goToSchool();</span><br><span class="line">        person.takeExam();</span><br><span class="line">        person.goToWork();</span><br><span class="line">        person.getSalary(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把接口理解为一个特定的属性，而这个属性有相对应的一些方法，通过实现（implements）接口，具体的类必须实现其属性相对应的特定方法，帮助实现数据的抽象化。我们要注意继承和接口所代表的逻辑关系，继承之间的关系是 is-a，也就意味着子类是父类的一个子集。实现接口的类和接口之间的关系是 has-a，意味着具体类拥有接口的一些功能。</p><h2 id="实践练习"><a href="#实践练习" class="headerlink" title="实践练习"></a>实践练习</h2><p>请创建一个Game类，其中包含score数据，请使用封装的概念来设计此类，并在其中创建一个displayInfo方法。然后再创建两个子类VideoGame，PhoneGame继承Game类，并分别重写displayInfo方法，然后调用这两个类的实例来查看区别。（display的逻辑可以很简单，打印出游戏的类型和分数即可）</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;设计对象并使用&quot;&gt;&lt;a href=&quot;#设计对象并使用&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/25/%E8%BD%AF%E8%80%83/New%20Text%20Document/"/>
    <id>http://example.com/2023/10/25/%E8%BD%AF%E8%80%83/New%20Text%20Document/</id>
    <published>2023-10-25T13:27:31.196Z</published>
    <updated>2023-10-26T00:37:54.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="E-R图转换为关系模式"><a href="#E-R图转换为关系模式" class="headerlink" title="E-R图转换为关系模式"></a>E-R图转换为关系模式</h2><p>E-R图中，有实体和联系两个概念，实体和实体之间的联系分为三种，即1:1,1:N,M:N，这三种情况，转换为关系模式的方法也不同。</p><p>◆首先，<strong>每个实体都要转换为一个关系模式</strong>，对于联系:</p><ul><li><p>一对一，<strong>联系作为一个属性随便加入哪个实体中</strong>;</p></li><li><p>一对多，联系可以单独转换为一个关系模式，也可以<strong>作为一个属性加入到N端中（N端实体包含1端的主键)</strong>;</p></li><li><p>多对多，联系<strong>必须单独转换为一个关系模式</strong>(<strong>且此关系模式应该包含两端实体的主键</strong>)。</p></li></ul><p>转换之后要注意:<strong>原来的两个实体之间的联系必须还存在</strong>，能够通过查询方式查到对方。</p><h2 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h2><p>◆数据库设计的考法也非常固定，<strong>第一小题补充E-R图，第二小题补充关系模式，第三小题是简单的情景问答题</strong>。同样也都不难，结合题目描述和E-R图的一些特点可以轻易得出答案，技巧如下:</p><p>1、补充E-R图:这是<strong>重中之重</strong>，E-R图如果弄错了，后续题目都有影响，主要是<strong>根据题目描述确认哪些实体之间有联系，联系类型是哪一种</strong>，而后进行连线即可，并不难。</p><p>2、补充关系模式:实际考察的是<strong>将E-R图转换为关系模式，补充缺失的属性</strong>，分成<strong>两步</strong>︰首先需要<strong>审题</strong>，题目会给出每个关系模式的属性信息，<strong>先将题目中的属性信息和问题对应，将缺少的属性全部补充</strong>;而后再<strong>按照规则转换</strong>，即前面所说的规则，按联系的三种对应方式决定要添加哪些字段。</p><blockquote><p>重点检查多对多和一对多的关系。</p></blockquote><p>3、情景问答:一般都是给出一段新的描述，要求新增一种实体-联系类型和关系模式，本质也是考察联系类型和E-R图转换为关系模式。</p><p>◆注意审题，常识以及E-R图转换为关系模式的原则(主要是联系的归属)。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Q: E-R图转换为关系模式时，总觉得不对怎么办?</p><p>A:学员在这种类型题目里唯一的模糊点就是这里，转换为关系模式，遵循两步法，首先以题目描述为主，然后再根据不同类型的转换原则去判断是否有遗漏。</p><p>Q:这种题目该怎么学习，学习到哪种程度呢?</p><p>A:要求能拿到12分以上;看完视频对应专题课程后，立即去做历年真题，掌握技巧。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>12.文老师-软件工程基础知识[需求分析]</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-10-14T12:06:16.000Z</published>
    <updated>2023-11-07T15:27:35.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>软件需求是指用户<strong>对系统在功能、行为、性能、设计约束等方面的期望</strong>。是<strong>指用户解决问题或达到目标所需的条件或能力</strong>，是<strong>系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力</strong>，以及反映这些条件或能力的文档说明。</p><blockquote><p>可以理解为客户需要什么。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>分为<strong>需求开发</strong>和<strong>需求管理</strong>两大过程。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016100905029.png" alt="image-20231016100905029"></p><blockquote><p>需求定义：需求规格说明书最为重要。</p><p>需求验证：和客户一起评审，让客户确认需求。</p><p>需求基线：需求验证之后，需求基线形成；如果再变更需求，就需要走变更流程。</p></blockquote><h3 id="系统角度分类"><a href="#系统角度分类" class="headerlink" title="系统角度分类"></a>系统角度分类</h3><p>◆<strong>业务需求</strong>:反映<strong>企业或客户对系统高层次的目标要求</strong>，通常<u>来自项目投资人、客户、市场营销部门或产品策划部门</u>。通过业务需求可以确定项目视图和范围。</p><blockquote><p>和具体的实现没有关系。</p></blockquote><p>◆<strong>用户需求</strong>:描述的是<strong>用户的具体目标，或用户要求系统必须能完成的任务</strong>。即描述了用户能使用系统来做什么。通常采取<u>用户访谈和问卷调查</u>等方式，对用户使用的场景进行整理，从而建立用户需求。</p><p>◆<strong>系统需求</strong>:<strong>从系统的角度来说明软件的需求</strong>，包括功能需求、非功能需求和设计约束等。【考点】</p><blockquote><p>技术人员能够实现的需求。</p></blockquote><ul><li><p>1)功能需求:也称为行为需求，规定了<strong>开发人员必须在系统中实现的软件功能</strong>，用户利用这些功能来完成任务，满足业务需要。</p></li><li><p>2)非功能需求:<strong>指系统必须具备的属性或品质</strong>，又可以细分为软件质量属性(如可维护性、可靠性、效率等)和其他非功能需求。</p></li></ul><blockquote><p>包括系统的性能，如网页打开时间。</p></blockquote><ul><li>3)设计约束:也称为限制条件或补充规约，通常是<strong>对系统的一些约束说明</strong>，例如必须采用国有自主知识产权的数据库系统，必须运行在UNIX操作系统之下等。</li></ul><blockquote><p>外部强制规定。</p></blockquote><h3 id="用户角度分类"><a href="#用户角度分类" class="headerlink" title="用户角度分类"></a>用户角度分类</h3><p>质量功能部署(QFD) 是一种<strong>将用户要求转化成软件需求的技术</strong>，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，QFD将软件需求分为三类，分别是常规需求、期望需求和意外需求。</p><p>(1) 常规需求。用户认为<strong>系统应该做到的功能或性能</strong>，实现越多用户会越满意。</p><p>(2)期望需求。用户<strong>想当然认为系统应具备的功能或性能，但并不能正确描述</strong>自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。</p><blockquote><p>客户不要求也应该实现的功能。</p></blockquote><p>(3)意外需求。意外需求也称为兴奋需求，是<strong>用户要求范围外的功能或性能</strong>(但通常是软件开发人员很乐意赋予系统的技术特性)，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103249677.png" alt="image-20231016103249677"></p><blockquote><p>三个描述的抽象程度不同，抽象程度由高到低排序为 业务需求、用户需求、功能需求。</p></blockquote><h1 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>需求获取</strong>是一个确定和理解不同的项目干系人的需求和约束的过程。</p><h2 id="常见的需求获取法【考点】"><a href="#常见的需求获取法【考点】" class="headerlink" title="常见的需求获取法【考点】"></a>常见的需求获取法【考点】</h2><p>(1)用户访谈: 1对1，最多1-3， <strong>有代表性的用户</strong>。其形式包括结构化和非结构化两种，<strong>对项目组人员要求较高</strong>；无法对所有人进行访谈，需求获取可能不全面。</p><p>(2)问卷调查:用户多，无法一一访谈；可能不精准。</p><p>(3)采样:从种群中系统地选出有代表性的样本集的过程。$样本数量&#x3D;0.25*(可信度因子&#x2F;错误率)^2$</p><p>(4)情节串联板:一系列图片，通过这些图片来讲故事。.</p><p>(5**)联合需求计划(JRP)** :<u>通过联合各个关键用户代表、系统分析师、开发团队代表一起，通过有组织的会议来讨论需求。</u>【开会】</p><p>(6)需求记录技术:任务卡片、场景说明、用户故事、Volere白卡。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103517223.png" alt="image-20231016103517223"></p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>需求分析: 一个好的需求应该具有<strong>无二义性、完整性</strong>、 一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员<strong>把杂乱无章的用户要求和期望转化为用户需求</strong>，这就是需求分析的工作。</p><h2 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h2><p>(1) 绘制系统上下文范围关系图</p><p>(2)创建用户界面原型</p><p>(3)分析需求的可行性</p><p>(4)确定需求的优先级</p><p>(5)为需求建立模型</p><p>(6)创建数据字典.</p><p>(7)使用QFD (质量功能部署)</p><h2 id="结构化的需求分析"><a href="#结构化的需求分析" class="headerlink" title="结构化的需求分析"></a>结构化的需求分析</h2><p>结构化特点:<strong>自顶向下，逐步分解，面向数据</strong>。</p><p>三大模型:<u><strong>功能模型(数据流图)、行为模型(状态转换图)、数据模型(E-R图)</strong></u>以及数据字典。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103753156.png" alt="image-20231016103753156"></p><p>状态转换图STD如下图所示:</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103947728.png" alt="image-20231016103947728"></p><p>◆数据流图描述<strong>数据在系统中如何被传送或变换，以及如何对数据流进行变换的功能或子功能，用于对功能建模</strong>，数据流图相关概念如图:</p><p>◆数据流图是可以分层的，从顶层(即<strong>上下文无关数据流</strong>)到0层、1层等,顶层数据流图只含有一个加工处理表示整个管理信息系统，描述了系统的输入和输出，以及和外部实体的数据交互。数据流图示例如下:</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016104045666.png" alt="image-20231016104045666"></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016104134231.png" alt="image-20231016104134231"></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016104123949.png" alt="image-20231016104123949"></p><h1 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>◆<strong>需求定义(软件需求规格说明书SRS)</strong> :是需求开发活动的产物，编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。SRS是软件开发过程中最重要的文档之一，对于任何规模和性质的软件项目都不应该缺少。</p><h2 id="◆需求定义方法"><a href="#◆需求定义方法" class="headerlink" title="◆需求定义方法"></a>◆需求定义方法</h2><p>(1)严格定义也称为预先定义，需求的严格定义<strong>建立在以下的基本假设</strong>之上:<strong>所有需求都能够被预先定义</strong>。开发人员与用户之间能够准确而清晰地交流。采用图形(或文字)可以充分体现最终系统。</p><p>(2)原型方法，<strong>迭代的循环型开发方式</strong>，需要注意的问题:并非所有的需求都能在系统开发前被准确地说明。项目干系人之间通常都存在交流上的困难，原型提供了<strong>克该服困难的一个手段</strong>。特点:需要实际的、可供用户参与的系统模型。有合适的系统开发环境。反复是完全需要和值得提倡的，需求一旦确定,就应遵从严格的方法。</p><h1 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h1><p>◆需求验证:也称为需求确认，目的是<strong>与用户一起确认需求无误</strong>，对需求规格说明书SAS进行评审和测试，包括两个步骤:</p><p>需求评审:正式评审和非正式评审。</p><p>需求测试:设计概念测试用例。【设计场景测试】</p><p>◆需求验证通过后，要请用户签字确认，作为验收标准之一，此时，这个<strong>需求规格说明书就是需求基线</strong>，不可以再随意更新，如果需要更改必须走需求变更流程。</p><h1 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h1><p>◆定义需求基线:<strong>通过了评审的需求说明书就是需求基线</strong>，下次如果需要变更需求，就需要按照流程来一步步进行。需求的流程及状态如下图所示:</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110530187.png" alt="image-20231016110530187"></p><h2 id="◆需求变更【考点】和风险"><a href="#◆需求变更【考点】和风险" class="headerlink" title="◆需求变更【考点】和风险"></a>◆需求变更【考点】和风险</h2><p>主要关心需求变更过程中的需求风险管理，带有风险的做法有:<strong>无足够用户参与、忽略了用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的SRS、不准确的估算</strong>。</p><p>◆变更产生的原因:<strong>外部环境的变化、需求和设计做的不够完整、新技术的出现、公司机构重组造成业务流程的变化。</strong></p><p>◆<strong>变更控制委员会CCB</strong>:也称为配置控制委员会，其任务时对建议的配置项变更做出评价、审批，以及监督已经批准变更的实施。对任何变更都能做出决定。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110445357.png" alt="image-20231016110445357"></p><p>双向跟踪，两个层次，如下图所示: </p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110637548.png" alt="image-20231016110637548"></p><p>◆正向跟踪表示用户原始需求是否都实现了，反向跟踪表示软件实现的是否都是用户要求的，不多不少，可以用原始需求和用例表格(需求跟踪矩阵)来表示:</p><p>◆若原始需求和用例有对应，则在对应栏打对号，若某行都没有对号，表明原始需求未实现，正向跟踪发现问题;若某列都没有对号，表明有多余功能用例，软件实现了多余功能，反向跟踪发现问题。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110707857.png" alt="image-20231016110707857"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;软件需求&quot;&gt;&lt;a href=&quot;#软件需求&quot; class=&quot;head</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>12.文老师-软件工程基础知识[系统设计]</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86[%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1]/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86[%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1]/</id>
    <published>2023-10-14T12:06:16.000Z</published>
    <updated>2023-10-28T02:55:25.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="处理流程设计"><a href="#处理流程设计" class="headerlink" title="处理流程设计"></a>处理流程设计</h1><h2 id="业务流程建模【不考】"><a href="#业务流程建模【不考】" class="headerlink" title="业务流程建模【不考】"></a>业务流程建模【不考】</h2><p>标杆瞄准:以行业领先的标杆企业为目标，结合本企业情况分析建模。</p><p>IDEF (一系列建模、分析和仿真方法的统称)。</p><blockquote><p>继承的建模方法。</p></blockquote><p>DEMO (组织动态本质建模法)</p><p>Petri网</p><p>业务流程建模语言: BPEL、 BPML、 BPMN、 XPDL。</p><p>基于服务的BPM:基于Web服务的思想对业务流程进行建模。</p><h2 id="处理流程设计（IDEF-）"><a href="#处理流程设计（IDEF-）" class="headerlink" title="处理流程设计（IDEF ）"></a>处理流程设计（IDEF ）</h2><p><strong>IDEFO: 业务流程(功能)建模;</strong></p><p>IDEF1:信息建模;</p><p><strong>IDEF1X: 数据建模(如ER模型) ;</strong></p><p><strong>IDEF2:仿真建模设计;</strong></p><p>IDEF3:过程描述获取;</p><p><strong>IDEF4:面向对象设计;</strong></p><p>IDEFS:本体论描述获取;</p><p>IDEF6:设计原理获取;</p><p>IDEF7:信息系统审计;</p><p><strong>IDEF8:用户界面建模;</strong></p><p>IDEF9:场景驱动信息系统设计;</p><p>IDEF10:实施架构建模;</p><p>IDEF11:信息制品建模;</p><p><strong>IDEF12:组织结构建模;</strong></p><p>IDEF13:三模式映射设计;</p><p>IDEF14:网络规划。</p><h2 id="流程表示工具【考点】"><a href="#流程表示工具【考点】" class="headerlink" title="流程表示工具【考点】"></a>流程表示工具【考点】</h2><p><strong>程序流程图(Program Flow Diagram,PFD)<strong>用一些图框表示各种操作，<u>它独立于任何一种程序设计语言</u>，比较直观、清晰，易于学习掌握。任何复杂的程序流程图都应该由</strong>顺序、选择和循环结构</strong>组合或嵌套而成。</p><p><strong>IPO图</strong>也是流程描述工具，用来描述构成软件系统的每个模块的<strong>输入、输出和数据加工</strong>。</p><blockquote><p>I:input,P:process,O:output</p></blockquote><p><strong>N-S图</strong>【又称“盒图”】容易表示<strong>嵌套和层次关系</strong>，并具有强烈的结构化特征。但是当问题很复杂时，N-S图可能很大，因此<strong>不适合于复杂程序的设计</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016225749101.png" alt="image-20231016225749101"></p><p><strong>问题分析图(PAD)</strong> 是一种支持<strong>结构化程序设计</strong>的图形工具。PAD具有清晰的逻辑结构、标准化的图形等优点，更重要的是，它<u>引导设计人员使用结构化程序设计方法，从而提高程序的质量</u>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016225753853.png" alt="image-20231016225753853"></p><blockquote><p>四种方法本质一样，知识表示方法不一样。</p></blockquote><p><strong>活动图</strong>【考点】</p><p>如下所示的软件项目<a href="https://so.csdn.net/so/search?q=%E6%B4%BB%E5%8A%A8%E5%9B%BE&spm=1001.2101.3001.7020">活动图</a>中，顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的权重表示活动的持续时间()天， 则完成该项目的最短时间为 （）天。在该活动图中，共有（）条关键路径。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231028091145730.png" alt="image-20231028091145730"></p><p>解析:</p><p>关键路径ABFJL、ADGIJL</p><p>关键路径是项目计划中最长的一套路径，通俗点说因为关键路径最长，所以只有保证它做完了，才能保证项目做完了，所以说它最“关键”。</p><p>算“最早时间”时，从左到右算，两数取大</p><p>最晚时间：关键路径的长度-从终点到该点最短的距离</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231028091243026.png" alt="image-20231028091243026"></p><p>求“关键路径”：</p><p>根据，最早时间&#x3D;最晚时间，的全部点去找关键路径</p><p>关键路径必然经过这些点</p><p>所以，ABFJL&#x3D;ADGIJL&#x3D;22</p><p><strong>松弛</strong>&#x3D;最晚开始时间-最早开始时间。</p><p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间(天），则完成该项目的最少时间为（)天。活动BD最多可以晚开始（)天而不会影响整个项目的进度。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231028090549586.png" alt="image-20231028090549586"></p><blockquote><p> <strong>活动图是描述一个项目中各个工作任务相互依赖关系的一种模型</strong>，项目的很多重要特性可以通过分析活动图得到，如估算项目完成时间，计算关键路径和关键活动等。</p></blockquote><p>根据上图计算出关键路径为A-B-D-G-I-K-L，其长度为22，关键路径上的活动均为关键活动。活动BD在关键路径上，因此松弛时间为0。</p><h2 id="业务流程重组BPR"><a href="#业务流程重组BPR" class="headerlink" title="业务流程重组BPR"></a>业务流程重组BPR</h2><p>BPR是对企业的业务流程进行<strong>根本性的再思考和彻底性的再设计</strong>，从而获得可以用诸如成本、质量、服务和速度等方面的业绩来衡量的显著性的成就。<strong>BPR设计原则、系统规划和步骤如下图所示</strong>:</p><blockquote><p>原有的流程彻底推倒，重新设计业务流程。</p></blockquote><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016230332985.png" alt="image-20231016230332985"></p><blockquote><p>记忆基本原则。</p></blockquote><h2 id="业务流程管理BPM"><a href="#业务流程管理BPM" class="headerlink" title="业务流程管理BPM"></a>业务流程管理BPM</h2><blockquote><p>是对现有业务流程的优化。</p></blockquote><p>BPM是一种以<strong>规范化的构造端到端的卓越业务流程为中心</strong>，以持续的<strong>提高组织业务绩效为目的</strong>的系统化方法。</p><p>BPM与BPR管理思想最根本的不同就在于<strong>流程管理并不要求对所有的流程进行再造</strong>。构造卓越的业务流程并不是流程再造，而是<strong>根据现有流程的具体情况，对流程进行规范化的设计。</strong></p><p>流程管理包含三个层面:<strong>规范流程、优化流程和再造流程</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016230719234.png" alt="image-20231016230719234"></p><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>◆系统设计主要目的:为系统制定蓝图，在各种技术和实施方法中权衡利弊,精心设计，合理地使用各种资源，<strong>最终勾画出新系统的详细设计方法</strong>。</p><p>◆系统设计方法:<strong>结构化设计方法，面向对象设计方法</strong>。</p><p>◆系统设计的主要内容:<strong>概要设计、详细设计</strong>。</p><blockquote><p>首先做概要设计，然后做详细设计。</p></blockquote><p>◆概要设计基本任务:又称为<strong>系统总体结构设计</strong>，是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，<strong>形成软件的模块结构图，即系统结构图</strong>。<strong>产出概要设计说明书</strong>。</p><p>◆详细设计的基本任务:**模块内详细算法设计、模块内数据结构设计、数据库的物理设计、其他设计(代码、输入&#x2F;输出格式、用户界面)**、编写详细设计说明书、评审。</p><h2 id="系统设计基本原理"><a href="#系统设计基本原理" class="headerlink" title="系统设计基本原理"></a>系统设计基本原理</h2><p>抽象化：不需要和具体实践结合得过于紧密。</p><p>自顶而下，逐步求精：先概要设计，后详细设计。</p><blockquote><p>实现的时候，自底向上。</p></blockquote><p>信息隐蔽：把模块封装起来，避免信息泄露。</p><p>模块独立(<strong>高内聚，低耦合</strong>)：要求模块内联系紧密，模块间联系尽量少。</p><p>若模块A和模块B通过外部变量来交换输入、输出信息，则这两个模块的耦合类型是( )耦合。</p><p>A数据B标记C控制D公共</p><blockquote><p>公共耦合是指<strong>多个模块都访问同一个公共数据环境</strong>，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。模块A和模块B<strong>通过公共数据环境中的外部变量来交换输入、输出信息，显然属于公共耦合</strong>。</p></blockquote><h2 id="系统设计原则"><a href="#系统设计原则" class="headerlink" title="系统设计原则"></a>系统设计原则</h2><p>保持模块的大小适中;</p><p>尽可能减少调用的深度：调用的深度越深，效率会降低。</p><p><strong>多扇入，少扇出</strong>：扇入指其他模块调用本模块，扇出指本模块调用其他模块。扇入多意味着价值大，复用多。扇出多意味着耦合度高。</p><p>单入口，单出口;</p><p>模块的作用域应该在模块之内;</p><p>功能应该是可预测的。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017101044147.png" alt="image-20231017101044147"></p><h1 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h1><h2 id="人机界面设计三大黄金原则"><a href="#人机界面设计三大黄金原则" class="headerlink" title="人机界面设计三大黄金原则"></a>人机界面设计三大黄金原则</h2><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017101151428.png" alt="image-20231017101151428"></p><blockquote><p>掌握三大原则即可，细节不用看。</p></blockquote><h1 id="测试原则和方法【考点】"><a href="#测试原则和方法【考点】" class="headerlink" title="测试原则和方法【考点】"></a>测试原则和方法【考点】</h1><p>◆系统测试是<strong>为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试</strong>。</p><blockquote><p>测试是找出错误，调试是找出问题发生的原因。</p></blockquote><h2 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h2><p>◆应尽早并不断的进行测试：如V模型。</p><p>◆测试工作应该避免由原开发软件的人或小组承担;</p><p>◆在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期的输出结果;</p><p>◆既包含有效、合理的测试用例，也包含<strong>不合理、失效的用例</strong>;</p><p>◆检验程序是否做了该做的事，且<strong>是否做了不该做的事</strong>;</p><p>◆严格按照测试计划进行;</p><p>◆妥善保存测试计划和测试用例;</p><p>◆测试用例可以重复使用或追加测试。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>◆软件测试方法可分为静态测试和动态测试。</p><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>◆静态测试:指被测试程序<strong>不在机器上运行</strong>，而采用<strong>人工检测和计算机辅助静态分析</strong>的手段对程序进行检测，包括对文档的静态测试和对代码的静态测试。</p><p>对文档的静态测试主要以<strong>检查单</strong>的形式进行，而对代码的静态测试，包括<strong>桌前检查、代码审查、代码走查</strong>的方式。使用这种方法能够有效地发现30%- 70%的逻辑设计和编码错误。</p><blockquote><p>桌前检查:根据文档要求对代码逻辑进行审查</p><p>代码审查：开会讨论。</p><p>代码走查：程序员担当计算机的角色，模拟计算机运行代码。</p></blockquote><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>◆动态测试:指在计算机上<strong>实际运行程序</strong>进行软件测试，一般采用白盒测试和黑盒测试方法。</p><p>黑盒测试法:<strong>功能性测试</strong>，不了解软件代码结构，根据功能设计用例，测试软件功能。</p><blockquote><p>假定不了解软件代码结构，只进行一些功能性测试。</p></blockquote><p>白盒测试法:<strong>结构性测试</strong>，明确代码流程，根据代码逻辑设计用例，进行用例覆盖。</p><blockquote><p>根据软件代码流程设计测试用例。</p></blockquote><p>灰盒测试：黑白两种的结合。</p><h1 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h1><p>(1)单元测试:也称为模块测试，测试的对象是<strong>可独立编译或汇编的程序模块</strong>、软件构件或OO软件中的类(统称为模块)，测试依据是<strong>软件详细设计说明书</strong>。</p><p>某财务系统的一个组件中，某个变量没有正确初始化，()最可能发现该错误</p><p>A单元测试B集成测试C接受测试D安装测试</p><blockquote><p>单元测试主要检查模块的以下5个特征∶(1)模块接口。</p><p>(2）局部数据结构。</p><p>(3）重要的执行路径。</p><p>( 4）出错处理。</p><p>(5)边界条件。</p><p>是否使用了尚未赋值或尚未初始化的变量属于检查局部数据结构的内容。</p></blockquote><p>(2)集成测试:目的是<strong>检查模块之间，以及模块和已集成的软件之间的接口关系</strong>，并验证已集成的软件是否符合设计要求。测试依据是<strong>软件概要设计文档</strong>。</p><p>(3)系统测试:<strong>测试对象是完整的、集成的计算机系统</strong>;测试的目的是在真实系统工作环境下，验证完成的软件配置项能否和系统正确连接，并满足系统&#x2F;子系统设计文档和软件开发合同规定的要求。测试依据是<strong>用户需求或开发合同</strong>。主要内容包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试、安装与反安装测试等，其中，最重要的工作是进行功能测试与性能测试。功能测试主要采用黑盒测试方法;性能测试主要指标有响应时间、吞吐量、并发用户数和资源利用率等。</p><p>(4)确认测试:主要用<strong>于验证软件的功能、性能和其他特性是否与用户需求一致</strong>。根据用户的参与程度，通常包括以下类型:</p><p>内部【就是软件开发方】确认测试:主要由<strong>软件开发组织内部按照SRS进行测试</strong>。</p><p>Alpha测试:<strong>用户在开发环境下进行测试</strong>。</p><p>Beta测试:<strong>用户在实际使用环境下进行测试</strong>，通过改测试后，产品才能交付用户。</p><p>验收测试【走的一个流程】:<strong>针对SRS， 在交付前以用户为主进行的测试</strong>。其测试对象为完整的、集成的计算机系统。验收测试的目的是，在真实的用户工作环境下，检验软件系统是否满足开发技术合同或SRS。验收测试的结论是用户确定是否接收该软件的主要依据。除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。</p><p>(5)配置项测试:测试对象是<strong>软件配置项</strong>，测试目的是<strong>检验软件配置项与SRS的一致性</strong>。测试的依据是SRS。在此之间，应确认被测软件配置项已通过单元测试和集成测试。</p><p>(6)<strong>回归测试</strong>【考点】:测试目的是测试<strong>软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性</strong>。</p><h2 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h2><p>◆自底向上:<strong>从最底层模块开始测试，需要编写驱动程序</strong>,而后开始逐-合并模块，最终完成整个系统的测试。优点是较早的验证了底层模块。</p><p>◆自顶向下:<strong>先测试整个系统，需要编写桩程序,而后逐步向下直至最后测试最底层模块</strong>。优点是较<strong>早的验证了系统的主要控制和判断点</strong>。</p><p>◆三明治:既有自底向上也有自顶向下的测试方法，<strong>二者都包括</strong>。<strong>兼有二者的优点，缺点是测试工作量大</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017123402441.png" alt="image-20231017123402441"></p><h1 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h1><h2 id="黑盒测试用例"><a href="#黑盒测试用例" class="headerlink" title="黑盒测试用例"></a>黑盒测试用例</h2><p><strong>黑盒测试用例</strong>:将程序看做一个 黑盒子，只知道输入输出，不知道内部代码，由此设计出测试用例，分为下面几类:</p><p>◆<strong>等价类划分</strong>:把所有的数据按照某种特性进行归类，而后在每类的数据里选取一个即可。</p><blockquote><p>用一个用例代替一个类，节省测试用例。</p></blockquote><p>等价类测试用例的设计原则:设<strong>计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类</strong>，重复这一步，直到所有的有效等价类都被覆盖为止;<strong>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类</strong>，重复这一步，直到所有的无效等价类都被覆盖为止。</p><blockquote><p>如果覆盖了两个无效等价类，那么就不容易判别出是出现了那个错误。</p></blockquote><p>◆<strong>边界值划分</strong>:将每类的边界值作为测试用例，<strong>边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值</strong>，如年龄范围为0-150，边界值为0, 150， -1, 151四个。</p><p>◆错误推测:没有固定的方法，凭经验而言，来推测有可能产生问题的地方，作为测试用例进行测试。</p><p>◆因果图:由一个结果来反推原因的方法，具体结果具体分析，没有固定方法。</p><h2 id="白盒测试用例"><a href="#白盒测试用例" class="headerlink" title="白盒测试用例"></a>白盒测试用例</h2><p><strong>白盒测试用例</strong>:知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面几种:</p><p>(1)<strong>语句覆盖SC</strong>:逻辑代码中的<strong>所有语句都要被执行一遍，覆盖层级最低</strong>，因为执行了所有的语句，不代表执行了所有的条件判断。</p><blockquote><p>赋值语句、条件语句都是语句。</p></blockquote><p>(2)<strong>判定覆盖DC</strong>:逻辑代码中的<strong>所有判断语句的条件的真假分支都要覆盖一次</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017124504278.png" alt="image-20231017124504278"></p><p>(3) 条件覆盖CC:针对每一个判断条件内的每一个独立条件都要执行一遍真和假。</p><p>(4)<strong>条件判定组合覆盖CDC: 同时满足判定覆盖和条件覆盖</strong></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017125100662.png" alt="image-20231017125100662"></p><p>(5)<strong>路径覆盖</strong>:逻辑代码中的<strong>所有可行路径都覆盖了，覆盖层级最高</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017130025502.png" alt="image-20231017130025502"></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017130234904.png" alt="image-20231017130234904"></p><p>答案：C.D</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017130505278.png" alt="image-20231017130505278"></p><p>答案：A;D</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>◆测试是发现错误，调试是找出错误的代码和原因。</p><p>◆调试需要确定错误的准确位置;确定问题的原因并设法改正;改正后要进行回归测试。</p><p>◆调试的方法有:<strong>蛮力法、回溯法</strong>(从出错的地方开始，向回找)、<strong>原因排除法</strong> (找出所有可能的原因，逐一进行排除，具体包括演绎法、归纳法、二分法)。</p><h1 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h1><p>◆<strong>软件的两种属性:外部属性指面向管理者和用户的属性，可直接测量</strong>，一般为性能指标。<strong>内部属性指软件产品本身的的属性，如可靠性等，只能间接测量。</strong></p><p>◆<strong>McCabe度量法</strong>【考点】:又称为环路复杂度，假设有向图中<strong>有向边数为m,节点数为n，则此有向图的环路复杂度为m-n+2</strong>.</p><p>注意m和n代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式，另外，针对一个程序流程图，每一一个分支边(连线)就是一条有向边，每一条语句 (语句框)就是一个顶点。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017131428004.png" alt="image-20231017131428004"></p><p>答案：B;11顶点，13个顶点，maccabe为14.</p><h1 id="系统转换【考点】"><a href="#系统转换【考点】" class="headerlink" title="系统转换【考点】"></a>系统转换【考点】</h1><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017131946222.png" alt="image-20231017131946222"></p><p>◆<strong>遗留系统</strong>是指任何基本上<strong>不能进行修改和演化以满足新的变化了的业务需求的信息系统</strong>，它通常具有以下特点:</p><p>(1)系统虽然完成企业中许多重要的业务管理工作，但仍然<strong>不能完全满足要求</strong>。一般实现业务处理电子化及部分企业管理功能，很少涉及经营决策。</p><p>(2)系统在性能上已经落后，采用的<strong>技术已经过时</strong>。例如，多采用主机&#x2F;终端形式或小型机系统，软件使用汇编语言或第三代程序设计语言的早期版本开发，使用文件系统而不是数据库。</p><p>(3)通常是大型的软件系统，已经融入企业的业务运作和决策管理机制之中，<strong>维护工作十分困难</strong>。</p><p>(4)没有使用现代信息系统建设方法进行管理和开发，现在基本上已经没有文档，<strong>很难理解</strong>。</p><p>◆系统转换是指新系统开发完毕，投入运行，取代现有系统的过程，需要考虑多方面的问题，以实现与老系统的交接，有以下三种转换计划:</p><ul><li><p><strong>直接转换</strong>:<strong>现有系统被新系统直接取代了</strong>，风险很大，适用于新系统不复杂，或者现有系统已经不能使用的情况。优点是节省成本。</p></li><li><p><strong>并行转换</strong>:<strong>新系统和老系统并行工作一段时间</strong>，新系统经过试运行后再取代，若新系统在试运行过程中有问题，也不影响现有系统的运行，风险极小，在试运行过程中还可以比较新老系统的性能，<u>适用于大型系统</u>。<u>缺点是耗费人力和时间资源，难以控制两个系统间的数据转换</u>。</p></li><li><p><strong>分段转换</strong>:<strong>分期分批逐步转换</strong>，是直接和并行转换的集合，<strong>将大型系统分为多个子系统，依次试运行每个子系统</strong>，成熟一个子系统， 就转换一个子系统。<u>同样适用于大型项目，只是更耗时，而且现有系统和新系统间混合使用，需要协调好接口等问题</u>。【目前采用的比较多】</p><h1 id="数据转换与迁移"><a href="#数据转换与迁移" class="headerlink" title="数据转换与迁移"></a>数据转换与迁移</h1></li></ul><p><strong>数据转换与迁移</strong>:将数据从旧数据库迁移到新数据库中。</p><p>有三种方法:<strong>系统切换前通过工具迁移、系统切换前采用手工录入、系统切换后通过新系统生成</strong>。</p><h1 id="系统维护【考点】"><a href="#系统维护【考点】" class="headerlink" title="系统维护【考点】"></a>系统维护【考点】</h1><blockquote><p>耗时最长，成本最高。</p></blockquote><p>◆系统的<strong>可维护性</strong>可以定义为<strong>维护人员理解、改正、改动和改进这个软件的难易程度</strong>，其评价指标如下:</p><p>(1)<strong>易分析性</strong>。软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</p><p>(2) <strong>易改变性</strong>。软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。</p><p>(3)<strong>稳定性</strong>。软件产品避免由于软件修改而造成意外结果的能力。</p><p>(4)<strong>易测试性</strong>。软件产品使已修改软件能被确认的能力。</p><p>◆系统维护包括<strong>硬件维护、软件维护和数据维护</strong>，其中软件维护类型如下:</p><p><strong>正确性维护</strong>:发现了bug而进行的修改。</p><p><strong>适应性维护</strong>:由于外部环境发生了改变，被动进行的对软件的修改和升级。</p><p><strong>完善性维护</strong>:基于用户主动对软件提出更多的需求，修改软件，增加更多的功能，使其比之前的软件功能、性能更高，更加完善。</p><p><strong>预防性维护</strong>:对未来可能发生的bug进行预防性的修改。</p><h1 id="系统评价【从未考过】"><a href="#系统评价【从未考过】" class="headerlink" title="系统评价【从未考过】"></a>系统评价【从未考过】</h1><h2 id="系统评价分类"><a href="#系统评价分类" class="headerlink" title="系统评价分类"></a>系统评价分类</h2><p>立项评价:系统开发前的预评价，分析是否立项开发，做可行性评价。</p><p>中期评价:项目开发中期每个阶段的阶段评审。或者项目在开发中途遇到重大变故，评价是否还要继续。</p><p>结项评价:系统投入正式运行后，了解系统是否达到预期的目的和要求而对系统进行的综合评价。</p><h2 id="系统评价的指标"><a href="#系统评价的指标" class="headerlink" title="系统评价的指标"></a>系统评价的指标</h2><p>(1)从信息系统的组成部分出发，信息系统是一个由人机共同组成的系统，所以可以按照运行效果和用户需求(人)、系统质量和技术条件(机)这两条线索构造指标。</p><p>(2)从信息系统的评价对象出发，对于开发方来说，他们所关心的是系统质量和技术水平;对于用户方而言，关心的是用户需求和运行质量:系统外部环境则主要通过社会效益指标来反映。</p><p>(3)从经济学角度出发，分别按系统成本、系统效益和财务指标3条线索建立指标。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017181950988.png" alt="image-20231017181950988"></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017182013871.png" alt="image-20231017182013871"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;处理流程设计&quot;&gt;&lt;a href=&quot;#处理流程设计&quot; class=&quot;</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象技术</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2023-10-14T12:06:16.000Z</published>
    <updated>2023-10-28T05:37:36.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="面向对象开发【非常重要】"><a href="#面向对象开发【非常重要】" class="headerlink" title="面向对象开发【非常重要】"></a>面向对象开发【非常重要】</h1><blockquote><p>在采用面向对象技术开发系统时，主要步骤有面向对象分析、面向对象设计、面向对象程序设计和面向对象测试。</p><p><strong>面向对象分析（OOA）</strong>主要包括︰认定对象、组织对象、描述对象间的相互作用、定义对象的操作、定义对象的内部信息。</p><p>**面向对象设计(OOD)**是<u>设计分析模型和实现相应源代码</u>。</p><p><strong>面向对象程序设计</strong>选择合适的面向对象程序设计语言，<u>将程序组织为相互协作的对象集合</u>，每个对象表示某个类的实例，类通过继承等关系进行组织。</p><p><strong>面向对象测试</strong>是尽可能早的开始进行系统测试，以发现系统中可能存在的错误并进行修复，进而保证系统质量。</p><p>分析阶段的目的是为了获得对应用问题的理解，确定系统的功能、性能要求，在此阶段主要关注系统的行为，明确系统需要提供什么服务。</p><p>在设计阶段，采用面向对象技术将OOA所创建的分析模型转化为设计模型,其目标是定义系统构造蓝图。</p><p>在实现阶段（面向对象程序设计)，系统实现人员选用一种面向对象程序设计语言，采用对象、类及其相关概念进行程序设计，即<strong>实现系统</strong>。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>(1)对象:由<strong>数据及其操作所构成的封装体</strong>，是系统中用来<strong>描述客观事务的一个实体</strong>，是构成系统的一个基本单位。一个对象通常可以由<strong>对象名、属性和方法</strong>3个部分组成。</p><blockquote></blockquote><p>(2)类:现实世界中<strong>实体的形式化描述</strong>，类将该实体的属性(数据)和操作(函数)封装在一起。<strong>对象是类的实例，类是对象的模板</strong>。</p><blockquote><p>类是对象的抽象。一般是基于类建立模型。</p></blockquote><p>类可以分为三种:<strong>实体类、接口类(边界类)和控制类</strong>。</p><p>实体类的对象表示<strong>现实世界中真实的实体</strong>，如人、物等。</p><p>接口类(边界类)的对象<strong>为用户提供一种与系统合作交互的方式</strong>，分为人和系统两大类，其中人的接口可以是显示屏、窗口、Web窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。</p><p>控制类的对象用来<strong>控制活动流，充当协调者</strong>。</p><blockquote><p>控制业务流，防止发生混乱；就如规定学生交卷的顺序。</p></blockquote><p>(3)抽象:通过<strong>特定的实例抽取共同特征以后形成概念的过程</strong>。它<strong>强调主要特征，忽略次要特征</strong>。一个对象是现实世界中一个实体的抽象，一个类是一组对象的抽象，抽象是一种单一化的描述，它强调给出与应用相关的特性，拋弃不相关的特性。</p><p>(4)封装:是一种<strong>信息隐蔽技术</strong>，将相关的概念组成一个单元模块，并通过一个名称来引用。面向对象封装是将数据和基于数据的操作封装成一个整体对象,<strong>对数据的访问或修改只能通过对象对外提供的接口进行</strong>。</p><blockquote><p>以下关于封装在软件复用中所充当的角色的叙述，正确的是(A)。</p><p>A封装使得其他开发人员不需要知道一个软件组件内部如何工作</p><p>B封装使得软件组件更有效地工作</p><p>C封装使得软件开发人员不需要编制开发文档</p><p>D封装使得软件组件开发更加容易</p><p>封装是一种信息隐藏技术，其目的是使对象（组件）的使用者和生产者分离，也就是使其他开发人员无需了解所要使用的软件组件内部的工作机制，只需知道如何使用组件,即组件提供的功能及其接口。</p></blockquote><p>(5)继承:表示<u><strong>类之间的层次关系(父类与子类)</strong></u>，这种关系使得某类对象可以继承另外一类对象的特征， 又可分为单继承和多继承。</p><blockquote><p>多重继承是编程语言中的概念，多重继承指的是一个类可以继承另外一个类，而另外一个类又可以继承别的类，比如A类继承B类，而A类又可以继承C类，这就是多重继承。多重继承可能造成混淆的情况，出现二义性的成员。</p></blockquote><p>(6) 多态:<strong>不同的对象收到同一个消息时产生完全不同的结果</strong>。包括<strong>参数多态</strong>(不同类型参数多种结构类型)、<strong>包含多态</strong>(父子类型关系)、<strong>过载多态(又称重载多态)、强制多态(强制类型转换)<strong>四种类型。多态</strong>由继承机制支持</strong>，将通用消息放在抽象层，具体不同的功能实现放在低层。</p><blockquote><p>一个函数名，不同的子类实现了不同的方法。</p></blockquote><blockquote><p>选择题多态分为参数多态、包含多态、过载多态和强制多态四种不同形式，其中()多态在许多语言中都存在，最常见的例子就是子类泛型化。</p><p>A参数B包含C过载D强制</p><p>面向对象系统中，在收到消息时，对象要予以响应。多态( polymorphism )是不同的对象收到同一消息可以进行不同的响应，产生完全不同的结果，<strong>用户可以发送一个通用的消息，而实现细节则由接收对象自行决定，使得同一个消息就可以调用不同的方法</strong>，即一个对象具有多种形态。Cardelli和Wegner将多态分为4种不同的形式:参数多态、包含多态、过载多态和强制多态。其中<strong>参数多态是应用比较广的多态，包含多态在许多语言中都存在</strong>，最常见的例子就是子类型化。<strong>过载多态是同一个名字在不同的上下文中所代表的含义</strong></p><p>参数多态︰应用广泛、最纯的多态。</p><p>包含多态∶同样的操作可用于一个类型及其子类型。包含多态一般需要进行运行时的类型检查。</p><p>强制多态∶编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。</p><p>过载多态∶同一个名（操作符、函数名)在不同的上下文中有不同的类型。</p></blockquote><blockquote><p>多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次。一个对象发送通用消息请求服务时，要根据接收对象的具体情况将求的操作与实现的方法进行连接，即动态绑定，以实现在这些低层次上生成的对传给用消息以不同的响应。</p><p>在面向对象方法中，支持多态的是( )。</p><p>A静态分配B动态分配C静态类型D动态绑定</p></blockquote><p>(7)接口:描述对操作规范的说明，其<strong>只说明操作应该做什么</strong>，并没有定义操作如何做。</p><p>(8)消息:体现<strong>对象间的交互</strong>，通过它向目标对象发送操作请求。</p><p>(9)覆盖:子类在原有父类接口的基础上，用<strong>适合于自己要求的实现去置换父类中的相应实现</strong>。即在子类中重定义一个与父类同名同参的方法。</p><p>(10)函数重载:与覆盖要区分开，函数重载与子类父类无关，且<strong>函数是同名不同参数</strong>。</p><blockquote><p>重载，简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p></blockquote><p>(11)绑定是一个把<strong>过程调用和响应调用所需要执行的代码加以结合的过程</strong>。在一般的程序设计语言中，绑定是在<strong>编译时进行的，叫作静态绑定</strong>。动态绑定则是在<strong>运行时进行的</strong>，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。</p><blockquote><p>选择题某些程序设计语言中，在运行过程中当一个对象发送消息请求服务时，根据接收对象的具体情况将请求的操作与实现的方法进行连接，称为( ) 。</p><p>A静态绑定B通用绑定C动态绑定D过载绑定</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>例题1.在某销售系统中，客户采用扫描二维码进行支付。若采用面向对象方法开发该销售系统，则客户类属于()类，二维码类属于()类。</p><p>A.接口</p><p>B.实体</p><p>C.控制</p><p>D.状态</p><p>A.接口</p><p>B.实体</p><p>C.控制</p><p>D.状态</p><p>答案:BA</p><h2 id="面向对象的分析"><a href="#面向对象的分析" class="headerlink" title="面向对象的分析"></a>面向对象的分析</h2><p>面向对象的分析是为了<strong>确定问题域，理解问题</strong>。包含五个活动:<strong>认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息</strong>。</p><h2 id="面向对象需求建模"><a href="#面向对象需求建模" class="headerlink" title="面向对象需求建模"></a>面向对象需求建模</h2><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231017185417477.png" alt="image-20231017185417477"></p><blockquote><p>两种模型和模型的步骤要记住。</p></blockquote><h2 id="面向对象的设计"><a href="#面向对象的设计" class="headerlink" title="面向对象的设计"></a>面向对象的设计</h2><p>◆面向对象的设计:是<strong>设计分析模型和实现相应源代码</strong>，设计问题域的解决方案，与技术相关。</p><p>OOD同样应遵循抽象、信息隐蔽、功能独立、模块化等设计准则。</p><h2 id="面向对象的分析模型"><a href="#面向对象的分析模型" class="headerlink" title="面向对象的分析模型"></a>面向对象的分析模型</h2><p>◆面向对象的<strong>分析模型</strong>主要由<strong>顶层架构图、用例与用例图、领域概念模型构成</strong>;</p><p><strong>设计模型</strong>则<strong>包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</strong></p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231017185523719.png" alt="image-20231017185523719"></p><blockquote><p>架构图就是体系图。</p></blockquote><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><p>(1)<strong>单一责任原则</strong>。就一个类而言，应该<strong>仅有一个引起它变化的原因</strong>。即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p><p>(2)<strong>开放一封闭原则</strong>。软件实体(类、模块、函数等)应该是<strong>可以扩展的，即开放的;但是不可修改的，即封闭的</strong>。</p><blockquote><p>可以增加功能，但是不能修改原有代码。</p></blockquote><p>(3)<strong>里氏替换原则</strong>。<strong>子类型必须能够替换掉他们的基类型</strong>【就是父类型】。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p><blockquote><p>就是子类能替换父类。</p></blockquote><p>(4)<strong>依赖倒置原则</strong>。<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。即，高层模块不应该依赖于低层模块，二者都应该依赖于抽象。</p><blockquote><p>对象应该依赖于类，类不应该依赖于对象。</p></blockquote><p>(5)<strong>接口分离原则</strong>。<strong>内部的实现必须与接口分离</strong>。接口属于客户，不属于它所在的类层次结构。即:<strong>依赖于抽象，不要依赖于具体</strong>，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化。</p><blockquote><p>选择题下列关于一个类的静态成员的描述中，不正确的是( )。</p><p>A类的静态方法只能访问该类的静态数据成员</p><p>B静态数据成员可被该类的所有方法访问</p><p>C该类的对象共享其静态数据成员的值</p><p>D该类的静态数据成员的值不可修改</p><p>试题解析</p><p>面向对象开发方法中，静态成员的含义是所修饰的成员是属于类的，而不是属于某对象的。<strong>静态数据成员对该类只有一份，该类的所有对象共享静态数据成员</strong>，可被该类的所有方法访问，其值可以修改，但是不论是通过对象还是类对静态数据成员值的修改，都会反应到整个类。类的静态方法只能访问该类的静态数据成员。</p></blockquote><p>对象的<strong>状态</strong>包括这个对象的所有属性（通常是静态的)以及每个属性当前的值（通常是动态的)﹔为了将一个对象与其它所有对象区分开来，我们通常会给它起一个“标识”﹔<strong>行为</strong>是对象根据它的状态改变和消息传递所采取的行动和所作出的反应;对象的行为代表了其外部可见的活动;操作代表了一个类提供给它的对象的一种服务。</p><blockquote><p>选择题对象的(A)标识了该对象的所有属性(通常是静态的）以及每个属性的当前值（通常是动态的)。</p><p>A状态B唯一IDC行为D语义</p></blockquote><h2 id="面向对象软件的测试层次"><a href="#面向对象软件的测试层次" class="headerlink" title="面向对象软件的测试层次"></a>面向对象软件的测试层次</h2><p>一般来说，对面向对象软件的测试可分为下列4个层次进行。</p><p>(1)<strong>算法层</strong>。测试<strong>类中定义的每个方法</strong>，基本上相当于传统软件测试中的单元测试。</p><blockquote><p>测试类中的每一个函数。</p></blockquote><p>(2)<strong>类层</strong>。测试封装<strong>在同一个类中的所有方法与属性之间的相互作用</strong>。在向面对象软件中类是基本模块，因此可以认为这是面向对象测试中所特有的模块测试。</p><p>(3)<strong>模板层</strong>。测试一组协同工作的类之间的相互作用，大体上相当于传统软件测试中的集成测试，但是也有面向对象软件的特点(例如，对象之间通过发送消息相互作用)。</p><p>(4) <strong>系统层</strong>。<strong>把各个子系统组装成完整的面向对象软件系统</strong>，在组装过程中同时进行测试。</p><p><strong>面向对象的分析模型主要由顶层架构图、用例与用例图和( )构成:设计模型则包含以()表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的( )和用以描述流程化处理过程的活动图等。</strong></p><p>A.数据流模型</p><p>B.领域概念模型</p><p>C.功能分解图</p><p>D.功能需求模型</p><p>A.模型视图控制器</p><p>B.组件图</p><p>C.包图</p><p>D.2层、3层或N层</p><p>A.序列图</p><p>B.协作图</p><p>C.流程图</p><p>D.状态图</p><p>答案:B.C.D</p><p>在面向对象设计的原则中、( D)原则是指抽象不应该依赖予细节，细节应该依赖于抽象，即应针对接口编程，而不是针对实现编程。</p><p>A.开闭B.里氏替换C.最少知识D.依赖倒置</p><p>答案: D</p><h1 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h1><p>◆<strong>UML (统一建模语言)</strong> :是一种<strong>可视化的建模语言，而非程序设计语言</strong>，支持从需求分析开始的软件开发的全过程。</p><p>◆从总体上来看，UML的结构包括<strong>构造块、规则和公共机制</strong>三个部分。</p><p>(1)构造块。UML有三种基本的构造块，分别是<strong>事务、关系和图</strong> 。事物是UML的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合。</p><p>(2)公共机制。公共机制是指达到特定目标的公共UML方法。【不考】</p><p>(3)规则。规则是构造块如何放在一起的规定。【不考】</p><h2 id="事物的类型"><a href="#事物的类型" class="headerlink" title="事物的类型"></a>事物的类型</h2><p>◆结构事物:模型的静态部分，如类、接口、用例、构件等;</p><p>◆行为事物:模型的动态部分，如交互、活动、状态机;</p><p>◆分组事物:模型的组织部分，如包;</p><p>◆注释物:模型的解释部分，依附于一个元素或一组元素之上对其进行约束或解释的简单符号。</p><blockquote><p>选择题在面向对象分析与设计中，()是应用领域中的核心类，一般用于保存系统中的信息以及提供针对这些信息的相关处理行为;(&#x2F;)是系统内对象和系统外参与者的联系媒介;(&#x2F;)主要是协调上述两种类对象之间的交互。</p><p>A)控制类B边界类C实体类D软件类</p><p><strong>实体类</strong>主要负责数据和业务逻辑;<strong>边界类</strong>负责和用户进行交互，即用户界面;<strong>控制类</strong>则负责实体类和界面类的交互。</p></blockquote><h2 id="事物的关系【考点】"><a href="#事物的关系【考点】" class="headerlink" title="事物的关系【考点】"></a>事物的关系【考点】</h2><p>◆依赖:<strong>一个事物的语义依赖于另一个事物的语义的变化而变化</strong></p><p>◆关联:是一种结构关系，描述了一组链，链是对象之间的连接。分为<strong>组合和聚合</strong>，都是<strong>部分和整体的关系</strong>，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。</p><blockquote><p>组合事物之间关系更强，具有共同的生命周期；总体不存在时，部分也就不存在了，反之亦然。</p><p>聚合关系不具有共同的生命周期，总体可以缺失部分而继续存在。</p></blockquote><p>◆泛化:<strong>一般&#x2F;特殊的关系</strong>，子类和父类之间的关系</p><p>◆实现:<strong>一个类元指定了另一个类元保证执行的契约</strong>。</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231017192315672.png" alt="image-20231017192315672"></p><blockquote><p>上图六种符号要记忆！</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018183751993.png" alt="image-20231018183751993"></p><p>答案：A.C.D</p><blockquote><p>选择题如下所示的UML类图中，Car和Boat类中的move ( B)方法()了’Transport类中的move( )方法。</p><p><img src="/../../pic/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231024130620582.png" alt="image-20231024130620582"></p><p>A继承B覆盖（重置)C重载D聚合</p><p>一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况，即继承关系。继承是父类和子类之间共享数据和方法的机制。父类描述了这些子类的公共属性和方法。一个子类可以继承它的父类（或祖先类）中的属性和方法，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和方法，也可以重新定义父类中己经定义的方法，即重置或覆盖（ overriding )。<strong>UML类图中，如果父类中已有方法名在子类中不出现，表示子类继承父类中的方法;如果父类中已有方法名在子类中出规了，就表示子类在继承父类接口定义的前提下，用适合于自己要求的实现去置换父类中的相应实现，即覆盖了父类中的方法。</strong></p></blockquote><h2 id="UML2-0图"><a href="#UML2-0图" class="headerlink" title="UML2.0图"></a>UML2.0图</h2><p>UML2.0图，书上是13种，有的说法还包含制品图，一共14种，了解即可，总分类如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018191720595.png" alt="image-20231018191720595"></p><p><strong>类图</strong>:静态图，为系统的<strong>静态设计视图</strong>，展现一组<strong>对象、接口、协作和它们之间的关系</strong>。UML类图如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192045517.png" alt="image-20231018192045517"></p><p>◆<strong>对象图</strong>:静态图，展现<strong>某一时刻一组对象及它们之间的关系</strong>，为类图的某一快照。<u>在没有类图的前提下，对象图就是静态设计视图</u>。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192122744.png" alt="image-20231018192122744"></p><blockquote><p>UML图中，对象图展现了() , ( &#x2F; )所示对象图与下图所示类图不一致。</p><p><img src="/../../pic/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231028133558013.png" alt="image-20231028133558013"></p><p>A.一组对象、接口、协作和它们之间的关系B.一组用例、参与者以及它们之间的关系C.某一时刻一组对象以及它们之间的关系D.以时间顺序组织的对象之间的交互活动</p><p>对象图︰展现了某一个时刻一组对象以及它们之间的关系。类图︰<strong>展现了一组对象、接口、协作和它们之间的关系。</strong>用例图︰展现了一组用例、参与者以及它们之间的关系。序列图︰是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p></blockquote><p><strong>用例图</strong>【考点】:静态图，展现了<strong>一组用例、参与者以及它们之间的关系</strong>。用例图中的参与者是人、硬件或其他系统可以扮演的角色；用例是参与者完成的一系列操作，用例之间的关系有<strong>扩展、包含、泛化</strong>【特有的】。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192306817.png" alt="image-20231018192306817"></p><blockquote><p>用例可以理解为参与者拥有的功能。用例图是用来需求建模的。</p><p>包含：要进行A，必须先完成B，则称A包含B。</p><p>扩展：要进行A，可以选择是否先完成B，则称A扩展B。B是可做可不做的。</p><p>泛化：父子关系。</p></blockquote><p>◆序列图:即顺序图，动态图，是场景的图形化表示，描述了<strong>以时间顺序组织的对象之间的交互活动</strong>。有<strong>同步消息</strong>（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示)，<strong>异步消息</strong>（发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示)、<strong>返回消息</strong>(由从右到左的虚线箭头表示)三种。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192835164.png" alt="image-20231018192835164"></p><p>通信图:动态图，<strong>即协作图，强调参加交互的对象的组织</strong>。如下:</p><blockquote><p>反映对象之间的信号传递。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193122999.png" alt="image-20231018193122999"></p><p>◆状态图:动态雷，展现了一个状态机，描述单个对象在多个用例中的行为，包括简单状态和组合状态。转换可以通过<strong>事件触发器触发</strong>【如按下播放器的播放按钮，播放器开始播放】，事件触发后相应的<strong>监护条件</strong>会进行检查【如检查收音机电源是否接通，不满足的话就不会产生状态转换】。状态图中转换和状态是两个独立的概念，如下:图中方框代表状态，筋头上的代表触发事件，实心圆点为起点和终点。</p><blockquote><p>两个黑点表示初始状态和结束状态。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193222627.png" alt="image-20231018193222627"></p><p>◆活动图:动态图，是一种<strong>特殊的状态图</strong>，展现了在<strong>系统内从一个活动到另一个活动的流程</strong>。活动的分岔和汇合线是一条水平粗线。牢记下图中<strong>并发分岔、并发汇合、监护表达式、分支、流</strong>等名词及含义。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。</p><blockquote><p>并发分岔：并行做几种操作。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193640762.png" alt="image-20231018193640762"></p><p>◆构件图(组件图)：静态图，为<strong>系统静态实现视图，展现了一组构件之间的组织和依赖</strong>。如下:</p><blockquote><p>供接口：半圆；需接口：整圆</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193948972.png" alt="image-20231018193948972"></p><p>选择题：UML构件图( component diagram)展现了一组构件之间的组织和依赖，专注于系统的静态（)视图，图中通常包括构件、接口以及各种关系。</p><p>A.关联B.实现C.机构D.行为</p><blockquote><p>构件图(Component Diagram )展现了一组构件之间的组织和依赖。构件图专注于系统的<strong>静态实现视图</strong>。</p></blockquote><p>◆部署图:静态图，为<strong>系统静态部署规图</strong>，部署图<strong>物理模块</strong>的节点分布。它与构件图相关，通常一个结点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018194135608.png" alt="image-20231018194135608"></p><h2 id="视图（UML-4-1视图"><a href="#视图（UML-4-1视图" class="headerlink" title="视图（UML 4+1视图)"></a>视图（UML 4+1视图)</h2><blockquote><p>视图是图的一个抽象。视图提出的概念由图来实现</p></blockquote><p>(1)逻辑视图。逻辑视图也称为<strong>设计视图</strong>，它表示了设计模型中在架构方面具有重要意义的部分，即<strong>类、子系统、包和用例实现的子集</strong>。</p><p>(2)进程视图。进程视图是<strong>可执行线程和进程作为活动类的建模</strong>，它是逻辑视图的一次执行实例<strong>，描述了并发与同步结构</strong>。</p><p>(3)实现视图。实现视图对组成基于系统的<strong>物理代码的文件和构件进行建模</strong>。</p><p>(4)部署视图。部署视图<strong>把构件部署到一组物理节点上</strong>，表示软件到硬件的映射和分布结构。</p><p>(5)用例视图。用例视图是<strong>最基本的需求分析模型</strong>。</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018194300135.png" alt="image-20231018194300135"></p><p>用例(use case)用来描述系统对事件做出响应时所采取的行动。用例之间是具有相关性的。在一个会员管理系统中，会员注册时可以采用电话和邮件两种方式。用例“会员注册”和“电话注册”、“邮件注册”之间是（C)关系。</p><p>A.包含(include)</p><p>B.扩展(extend) </p><p>c.泛化 (generalize)</p><p>D.依赖(depends on)</p><p>以下关于UML状态图的叙述中，不正确的是（B )A、活动可以在状态内执行，也可以在迁移时执行</p><p>B、若事件触发一个没有特定监护条件的迁移，则对象离开当前状态</p><p>C、迁移可以包含事件触发器，监护条件和状态</p><p>D、事件触发迁移</p><blockquote><p>迁移:一个状态到另一个状态的转换。</p></blockquote><p>在UML提供的系统视图中，(A）是逻辑视图的一次执行实例，描述了并发与同步结构;(D）是最基本的需求分析模型。</p><p>A进程视图</p><p>B.实现视图</p><p>C.部署视图</p><p>D.用例视图</p><p>A．进程视图</p><p>B.实现视图</p><p>c.部署视图</p><p>D.用例视图</p><p>如下所示的UML图是(D)，图中（Ⅰ)表示(B) ，图中（ⅠⅠ))表示(B)。</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018195031463.png" alt="image-20231018195031463"></p><p>A．序列图</p><p>B．状态图c．通信图D．活动图</p><p>A．合并分叉</p><p>B．分支</p><p>c．合并汇合</p><p>D．流</p><p>A．分支条件</p><p>B．监护表达式</p><p>c．动作名</p><p>D．流名称</p><h1 id="设计模式【重要】"><a href="#设计模式【重要】" class="headerlink" title="设计模式【重要】"></a>设计模式【重要】</h1><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018195659471.png" alt="image-20231018195659471"></p><p>架构模式:软件设计中的<strong>高层决策</strong>，例如C&#x2F;S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策。</p><p>设计模式:每一个设计模式描述了一个在我们周围<strong>不断重复发生的问题</strong>，<strong>以及该问题的解决方案的核心</strong>。这样，你就能一次又一次地使用该方案而不必做重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便的复用成功的的设计和体系结构。四个基本要素:<strong>模式名称、问题（应该在何时使用模式）、解决方案（设计的内容）、效果（模式应用的效果）</strong>。</p><p>惯用法:是最低层的模式，<strong>关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系</strong>。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用一计数就是C++语言中的一种惯用法。</p><blockquote><p>考试考察方法有三种：1.三大类有哪些模式：把创建和结构型记住，剩下的是行为型。2.考察哪些场景适合用哪种模式。3.设计模式的图形。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018201750330.png" alt="image-20231018201750330"></p><blockquote><p>构造器：类和类的构造分离。如在游戏创建一个人物【需要设计五官、衣服等】，这个人物就是一个复杂类。构造身体不同部分的特征就是类的构造。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018202556216.png" alt="image-20231018202556216"></p><blockquote><p><strong>桥接模式</strong>：课程资料可以以电子或纸质等载体分发，课程资料内容可以是文字的，也可以以图片形式。电子或者纸质是抽象，文字和图片是实现。他们之间可以有电子-文字，电子-照片等四种组合方式。</p></blockquote><blockquote><p>组合模式：强调部分和整体之间的关系。</p></blockquote><blockquote><p>代理模式：软件的快捷方式。</p></blockquote><p>(&#x2F;)设计模式能够动态地给一个对象添加一些额外的职责而无需修改此对象的结构;(&#x2F;)设计模式定义一个用于创建对象的接口，让子类决定实例化哪一个类;欲使一个后端数据模型能够被多个前端用户界面连接，采用(D)模式最适合。</p><p>A装饰器（Decorator )B享元( Flyweight )C观察者( Observer )D中介者(Mediator )</p><p>因使用大量的对象而造成很大的存储开销时，适合采用()模式进行对象共享，以减少对象数量从而达到较少的内存占用并提升性能。</p><p>A组合(Composite )B享元( Flyweight )C迭代器（Iterator )D备忘( Memento )</p><blockquote><p>组合(Composite )模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户<strong>对单个对象和组合对象的使用具有一致性</strong>。适用于∶想表示对象的部分-整体层次结构;希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>外观(Facade)模式<strong>为子系统中的一组接口提供一个一致的界面</strong>，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。适用于:要<strong>为一个复杂子系统提供一个简单接口时</strong>，子系统往往因为不断演化而变得越来越复杂﹔客户程序与抽象类的实现部分之间存在着很大的依赖性;当需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。</p><p>享元( Flyweight )模式运用共享技术有效地支持大量细粒度的对象。适用于:一个应用程序使用了大量的对象﹔完全由于使用大量的对象，造成很大的<strong>存储开销</strong>;对象的大多数状态都可变为外部状态﹔如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象︰应用程序不依赖于对象标识。</p><p>装饰器（Decorator)模式描述了以透明围栏来支持修饰的类和对象的关系，<strong>动态地给一个对象添加一些额外的职责,从增加功能的角度来看，装饰器模式相比生成子类更加灵活</strong>。适用于∶在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责﹔处理那些可以撤销的职责;当不能采用生成子类的方式进行扩充时。</p><p>工厂方法(Factory Method )定义一个用于创建对象的接口，让子类决定将哪一个类实例化，使一个类的实例化延迟到其子类。适用于︰当一个类不知道它所必须创建的对象的类的时候﹔当一个类希望由它的子类来指定它所创建的对象的时候;当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p>观察者（Observer )模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。适用于∶当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用;当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时;当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</p><p><strong>中介者</strong>( Mediator)用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。适用于:一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解;一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象;想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲<strong>使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适</strong>。</p><p>迭代器（Itcrator )提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。适用于:<strong>访问一个聚合对象的内容而无须暴露它的内部表示</strong>﹔支持对聚合对象的多种遍历;<strong>为遍历不同的聚合结构提供一个统一的接口</strong>。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018205415132.png" alt="image-20231018205415132"></p><blockquote><p>命令模式强调”可撤销“。</p><p>解释器模式通俗而言就是虚拟机，可以进行一些自定义操作。</p><p>迭代器模式：不暴露对象内部的细节。</p><p>中介模式：”不直接引用“。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231023212723092.png" alt="image-20231023212723092"></p><blockquote><p>备忘录模式：就是一个存档再读档的过程。</p></blockquote><blockquote><p>观察者模式：类似订阅微信公众号。观察者就是订阅者，被观察者就是公众号。</p></blockquote><blockquote><p>状态模式：类似随着会员等级变化，权限也随之变化。</p></blockquote><blockquote><p>策略模式：接口不需要改变，只需要改变算法。</p></blockquote><blockquote><p> 骨架就是一个模板，使用模板创建具体的类。</p></blockquote><blockquote><p>访问者模式：不同的阶段会有不同的行为（操作），而数据通常是不变的，因此把数据和操作分离。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231023213501673.png" alt="image-20231023213501673"></p><p>答案：DABA</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231023213807339.png" alt="image-20231023213807339"></p><p>答案：CAAB</p><p>某些设计模式会引入总是被用作参数的对象。例如(A)对象是一个多态accept方法的参数。</p><p>A.VisitorB.CommandC.MementoD.Obscrver</p><blockquote><p>很多行为模式注重封装变化。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样，当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。一些模式引入总是被用作参数的对象。有些模式定义一些可作为令牌进行传递的对象，这些对象将在稍后被调用。</p><p>在Visitor模式中，一个Visitor对象是一个多态的accept操作的参数，这个操作作用于该Visitor对象访问的对象。</p><p>在Command模式中，令牌代表一个请求;</p><p>在Memento模式中，它代表在一个对象在某个特定时刻的内部状态。</p><p>在这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会认识到这一点。</p><p>在Observer模式中，通过引入Observer和Subject对象来分布通信。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;面向对象开发【非常重要】&quot;&gt;&lt;a href=&quot;#面向对象开发【非常</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>9.文老师-数据结构</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-10-14T12:06:15.000Z</published>
    <updated>2023-11-02T09:09:01.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014182707252.png" alt="image-20231014182707252"></p><p>线性结构:每个元素<strong>最多只有一个出度和一个入度</strong>，表现为一条线状。线性表<strong>按存储方式【存储结构】分为顺序</strong><strong>表和链表</strong>。</p><ul><li><p>顺序存储:用一组<strong>地址连续的存储单元</strong>依次存储线性表中的数据元素，使得<strong>逻辑上相邻的元素物理上也相邻</strong>。</p></li><li><p>链式存储:存储各数据元素的结点的**<u>地址并不要求是连续的</u><strong>，数据元素逻辑上相邻,物理上分开；</strong>一个节点分为数据域和指针域，数据域记录了当前节点的数据，指针域记录了下一个相邻节点的物理地址**。</p></li></ul><p>顺序存储和链式存储的对比如下图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014183449722.png" alt="image-20231014183449722"></p><p>◆在空间方面，因为链表还需要存储指针，因此有空间浪费存在。</p><p>◆在时间方面，当需要<strong>对元素进行破坏性操作(插入、删除)时，链表效率更高</strong>，<u>因为其只需要修改指针指向即可，而顺序表因为地址是连续的，当删除或插入一个元素后，后面的其他节点位置都需要变动</u>。</p><p>◆而当需要对元素进行**不改变结构操作时(读取)，顺序表效率更高,**因为其物理地址是连续的，如同数组一般，只需按索引号就可快速定位，而链表需要从头节点开始，一个个的查找下去。</p><p><strong>选择题</strong>若对线性表的最常用操作是访问任意指定序号的元素，并在表尾加入和删除元素，则适宜采用(A )存储。</p><p>A.顺序表B.单链表C.双向链表D.哈希表</p><blockquote><p>线性表的元素在逻辑上是一个线性序列，若最常用的操作是访问任意指定序号的元素，而且其插入和删除元素的操作均在表尾进行，不需要移动其他元素，则其存储结构采用顺序表最为合适。</p></blockquote><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>队列、栈结构如下图；</p><p><strong>队列是先进先出，分队头和队尾;</strong></p><p><strong>栈是先进后出，只有栈顶能进出。</strong></p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014214721898.png" alt="image-20231014214721898"></p><h3 id="循环队列【考点】"><a href="#循环队列【考点】" class="headerlink" title="循环队列【考点】"></a>循环队列【考点】</h3><p><a href="https://www.bilibili.com/video/BV1cg411c7Rh?t=19.5">https://www.bilibili.com/video/BV1cg411c7Rh?t=19.5</a></p><p>设循环队列Q的容量为MAXSIZE,初始时队列为空，且Q.rear 和Q.front都等于0。</p><blockquote><p>队头指针永远指向队列第一个元素的地址。队尾指针永远指向队列最后一个元素的下一个元素的地址。</p><p>队头指针——&gt;读操作——&gt;指向当前元素</p><p>队尾指针——&gt;写操作——&gt;指向队列最后一个元素的空闲区域</p></blockquote><p>元素<strong>入队时</strong>修改<strong>队尾</strong>指针，即令Q.rear&#x3D;(Q.rear+1)%MAXSIZE.【%指取余操作】</p><p>元素<strong>出队时</strong>修改<strong>队头</strong>指针，即令Q.front&#x3D;(Q.front+ 1)%MAXSIZE。</p><p>根据队列操作的定义，当出队操作导致队列变为空时,有Q.rear&#x3D;&#x3D;Q.front;若入队操作导致队列满，则Q.rear&#x3D;&#x3D;Q.front。此时无法区分队列空还是队列满。</p><p>在队列空和队列满的情况下，循环队列的队头、队尾指针指向的位置是相同的，此时仅仅根据Q.rear和Q.front之间的关系无法断定队列的状态。为了区别队空和队满的情况，可采用以下两种处理方式:</p><p>其一是设置一个标志，以区别头、尾指针的值相同时队列是空还是满;</p><p>其二是**<u>牺牲一个存储单元，约定以“队列的尾指针所指位置的下一个位置是队头指针时”表示队列满</u>**，如图所示，而头、尾指针的值相同时表示队列为空。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014215959474.png" alt="image-20231014215959474"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1.对于线性表，相对于顺序存储，采用链表存储的缺点是(A) 。</p><p>A.数据元素之间的关系需要占用存储空间，导致存储密度不高</p><p>B.表中结点必须占用地址连续的存储单元，存储密度不高</p><p>C.插入新元素时需要遍历整个链表，运算的时间效率不高</p><p>D.删除元素时需要遍历整个链表，运算的时间效率不高</p><p>2.若一个栈初始为空，其输入序列是1，2, 3, …. n-1, n,其输出序列的第一个元素为k(1≤ k≤ [n&#x2F;2」),则输出序列的最后一个元素是(D)</p><p>A.值为n的元素</p><p>B.值为1的元素</p><p>C.值为n-k的元素</p><p>D.不确定的</p><ol start="3"><li></li></ol><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014221225325.png" alt="image-20231014221225325"></p><p>答案：D</p><ol start="4"><li></li></ol><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014221612909.png" alt="image-20231014221612909"></p><p>答案：B</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一种<strong>特殊的线性表</strong>，其数据元素都为字符。</p><p>◆空串:长度为的字符串，没有任何字符。</p><p>◆空格串:由一个或多个空格组成的串，空格是空白字符,占一个字符长度。</p><blockquote><p>空格是一个空白字符。</p></blockquote><p>◆子串:串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串，空串是任意串的子串。</p><p>◆串的模式匹配:子串的定位操作，用于<strong>查找子串在主串中第一次出现的位置的算法</strong>。</p><h3 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h3><h4 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h4><p><strong>朴素的模式匹配算法</strong>:也称为布鲁特——福斯算法， 其基本思想是<strong>从主串的第1个字符起与模式串的第1个字符比较，若相等，则继续逐个字符进行后续的比较;否则从主串中的<u>第2个字符起</u>与模式串的第1个字符重新比较</strong>，直至模式串中每个字符依次和主串中的一个连续的字符序列相等时为止，此时称为匹配成功，否则称为匹配失败。</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>KMP算法：对基本模式匹配算法的改进，其改进之处在于:每当匹配过程中出现<strong>相比较的字符不相等时，不需要回溯主串的字符位置指针，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的距离</strong>，再继续进行比较。</p><p>当模式串中的字符 pj 与主串中相应的字符Si不相等时，因其前j个字符(“p…pj-1”)已经获得了成功的匹配，所以**若模式串中”p0…pk-1”与”pj-k…pj-1”相同，这时可令pk与si进行比较，<u>从而使i无须回退</u>**。</p><p>在KMP算法中，依据b。若令next[j]&#x3D;k,则next[j]表示当模式串中的pj与主串中相应字符不相等时，<strong>令模式串的nex[j]与主串的相应字符进行比较</strong>。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>在字符串的KMP模式匹配算法中，需先求解模式串的next函数值，其定义如下式所示，j表示模式 串中字符的序号 (从 1 开始)。若模式串 $p$ 为 “abaac”，则其next函数值为 ()。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015111921751.png" alt="image-20231015111921751"></p><p>A. 01234B. 01122C. 01211D. 01111</p><p>解析:考查字符串的模式匹配算法。关键在于理解公式，而后从1开始代入，过程如下:</p><p> j&#x3D;1时p1为a，此时输出next[1]&#x3D;0,</p><p>j&#x3D;2时p2为b，比较中间的判断条件，1&lt;k&lt;j, 但j&#x3D;2， 故k为空，故next[2]&#x3D;1,</p><p>j&#x3D;3时p3&#x3D;a,此时k只能等于2，p1不等于p2,故不能满足中间的情况，此时next[3]&#x3D;1,</p><p>再取j&#x3D;4，k可以等于2或3，判断发现k&#x3D;2时满足但k&#x3D;3不满足，故next[4]&#x3D;2,</p><p>再取j&#x3D;5，k可以等于2或3或4，比较p1p2Lpk 1和右边那个等式，发现k&#x3D;2时成立，next[5]&#x3D;2。 </p><p>故答案应该为B: 01122 。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是<strong>定长线性表在维度上的扩展</strong>, 即<strong>线性表中的元素又是一个线性表</strong>。 N维数组是一种 “同构” 的数据结构, 其<strong>每个数据元素类型相同、结构一致</strong>。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113002293.png" alt="image-20231015113002293"></p><p>其可以表示为行向量形式或者列向量形式线性表，单个关系最多只有一个前 驱和一个后继, 本质还是线性的。</p><p>数组结构的特点: <strong>数据元素数目固定; 数据元素类型相同; 数据元素的下标 关系具有上下界的约束且下标有序。</strong></p><p>数组数据元素固定, 一般不做插入和删除运算, <strong>适合于采用顺序结构</strong>。</p><p>数组存储地址的计算,特别是二维数组，要注意理解，假设每个数组元素占用存储长度为len，起始地址为a，存储地址计算如下(<strong>默认从0开始编号</strong>) :</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113252350.png" alt="image-20231015113252350"></p><blockquote><p>考试中直接取特殊值求答案。</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>特殊矩阵:矩阵中的元素(或非0元素)的分布有定的规律。常见的特殊矩阵有对称矩阵、三角矩阵和对角矩阵。</p><p>稀疏矩阵:在一个矩阵中，若非零元素的个数远远少于零元素个数，且非零元素的分布没有规律。</p><p><strong>存储方式为三元组结构，即存储每个非零元素的(行，列，值)。</strong></p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113930675.png" alt="image-20231015113930675"></p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015114316509.png" alt="image-20231015114316509"></p><blockquote><p>特殊值代入计算。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015114817931.png" alt="image-20231015114817931"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广，<strong>是由0个或多个单元素或子表组成的有限序列</strong>。</p><p>广义表与线性表的区别:线性表的元素都是结构上不可分的单元素,而<strong>广义表的元素既可以单元素，也可以是有结构的表</strong>。</p><p>广义表一般记为: LS&#x3D; (a1, a2, .. an)。其中LS是表名，ai是表元素，它可以是表(称为子表)，也可以是数据元素(称为原子)。其中n是**广义表的长度(也就是最外层包含的元素个数)<strong>，n&#x3D;0的广义表为空表;而</strong>递归定义的重数就是广义表的深度，即定义中所含括号的重数(单边括号的个数，原子的深度为0，空表的深度为1)**。</p><blockquote><p>一般计算单边括号的个数就能得到表的深度。</p></blockquote><p>head()和tail():<strong>取表头</strong>(<strong>广义表第一个表元素</strong>，可以是子表也可以是单元素)和<strong>取表尾</strong>(**广义表中，除了第一个表元素之外的其他所有表元素构成的<u>表</u>**，非空广义表的表尾必定是一个表, 即使表尾是单元素)操作。</p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>树是n个节点的有限集合(n&gt;&#x3D;0) ，当n&#x3D;0时称为空树，在任一颗非空树中，<strong>有且仅有一个根节点</strong>。其余结点可分为m(m&gt;&#x3D;0)个互不相交的有限子集T1，T2, … Tm，其中，每个Ti又都是一棵树，井且称为根结点的子树。</p><h3 id="树的基本概念如下"><a href="#树的基本概念如下" class="headerlink" title="树的基本概念如下"></a>树的基本概念如下</h3><p>(1)<strong>双亲、孩子和兄弟</strong>。结点的子树的根称为该结点的孩子;相应地，该结点称为其子结点的双亲。具有相同双亲的结点互为兄弟。</p><p>(2)<strong>结点的度</strong>。一个结点的子树的个数记为该结点的度。例如A的度为3，B的度为2，C的度为0，D的度为1。</p><blockquote><p>就是该节点的出度。</p></blockquote><p>(3)<strong>叶子结点</strong>。叶子结点也称为终端结点，<strong>指度为0的结点</strong>。例如，E、 F、C、G都是叶子结点。</p><p>(4)<strong>内部结点</strong>。度不为0的非根结点，也称为分支结点或非终端结点。除根结点以外，分支结点也称为内部结点。例如，B、D都是内部结点。</p><p>(5)<strong>结点的层次</strong>。根为第一层，根的孩子为第二层，依此类推，若某结点在第i层，则其孩子结点在第1+1层。例如，A在第1层，B、C、D在第2层，E、F和G在第3层。</p><p>(6)<strong>树的高度</strong>。一棵树的最大层数记为树的高度(或深度)。例如，图中所示树的高度为3。</p><p>(7)<strong>有序(无序)树</strong>。若将树中结点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树，否则称为无序树。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015120007862.png" alt="image-20231015120007862"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>二叉树是n个节点的有限集合,它或者是空树，或者是由一个根节点及<strong>两颗互不相交的且分别称为左、右子树的二叉树所组成</strong>。</p><blockquote><p>子树个数小于等于2.</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015122445611.png" alt="image-20231015122445611"></p><p>两种特殊的二叉树:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015122546634.png" alt="image-20231015122546634"></p><p><strong>满二叉树</strong>：除叶子节点外，每个节点的度都为2。</p><p><strong>完全二叉树</strong>：完全二叉树有n层，n-1层是满的，最后一层从左到右是不间断的。</p><p><strong>非完全二叉树</strong>：完全二叉树有n层，n-1层是满的，最后一层从左到右是间断的。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>二叉树有一些性质如下, 要求掌握, 在实际考试中可以用特殊值法验证。</p><p>(1) 二叉树<strong>第 $i$ 层 $(i \geq 1)$ 上至多有 $2 ^{i-1}$ 个节点</strong>。</p><p>(2) <strong>深度为 $k$ 的二叉树至多有 $2^{k}-1$ 个节点 $(k \geq 1)$</strong> 。</p><p>(3) <strong>对任何一棵二叉树, 若其终端节点数为 $n_0$, 度为2的节点数为 $n_2$, 则 $n_0&#x3D;n_2+1$</strong> 。</p><blockquote><p>此公式可以画一个简单的二叉树使用特殊值法快速验证, 也可以证明如下: 设一棵二叉树上叶结点数为 $n_0$, 单分支结点数为 $n_1$, 双分支结点数为 $ {n}_2$, 则总的点数 $&#x3D;n_0+n_1+n_2$ 。在一棵二叉树中, 所有结点的分支数(即度数)应等于单分支结点 数加上双分支结点数的 2 倍, 即总的分支数 $&#x3D;n_1+2 n_2$ 。由于二叉树中除根结点以外, 每个结点都有唯一的一个分支指向它, 因此二叉树中: 总的分支数&#x3D;总结点数 -1 。</p></blockquote><p>(4) <strong>具有 $n$ 个节点的完全二叉树的深度为 $\lfloor\log 2 n\rfloor+1$</strong> 。【向下取整】</p><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><p>顺序存储，就是<strong>用一组连续的存储单元存储二叉树中的节点</strong>，按照<strong>从上到下，从左到右的顺序依次存储每个节点</strong>。</p><blockquote><p>一般只适用于完全二叉树和满二叉树。</p></blockquote><p>对于深度为k的完全二叉树，除第k层外，其余每层中节点数都是上一层的两倍，由此，从一个节点的编号可推知其双亲、左孩子、右孩子结点的编号。假设有编号为i的节点，则有:</p><p>若i&#x3D;1，则该节点为根节点，无双亲;</p><p>若i&gt;1， 则该节点的双亲节点为[i&#x2F;2]【向下取整】。</p><p>若2i&lt;&#x3D;n，则该节点的左孩子编号为2i,否则无左孩子。</p><p>若2i+1&lt;&#x3D;n，则该节点的右孩子编号为2i+1，否则无右孩子。</p><p>显然，<strong>顺序存储结构对完全二叉树而言既简单又节省空间，而对于一般二叉树则不适用</strong>。因为在顺序存储结构中，以节点在存储单元中的位置来表示节点之间的关系，那么对于一般的二叉树来说，也必须按照完全二叉树的形式存储，也就是要<strong>添上一些实际并不存在的“虚节点”，这将造成空间的浪费</strong>。</p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>由于二叉树中节点包含有数据元素、左子树根、右子树根及双亲等信息，因此可以用<strong>三叉链表</strong>或<strong>二叉链表</strong>(即一个节点含有三个指针或两个指针)来存储二叉树，链表的头指针指向二叉树的根节点。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015135005935.png" alt="image-20231015135005935"></p><blockquote><p>三个指针一个指向双亲节点，另外两个指向左右孩子。</p></blockquote><blockquote><p>空指针也占用一个存储单元。</p></blockquote><blockquote><p>当二叉树包含k个结点时，链表中每个结点有两个孩子指针，共2k个，每个指针表示了一个父子关系。非空二叉树中除了跟结点外，每个结点都有.唯一的父结点，因此2k个孩子指针中用k-1个表示了结点的父子关系，其余的k+1个孩子指针都为空指针。</p></blockquote><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>◆一颗非空的二叉树由根节点、左子树、右子树三部分组成。遍历这三E部分，也就遍历了整颗二叉树。这三部分遍历的基本顺序是先左子树后右子树，但根节点顺序可变，<strong>以根节点访问的顺序为准有下列三种遍历方式</strong>:</p><p><strong>先序(前序)遍历</strong>:根左右。</p><p><strong>中序遍历</strong>:左根右。</p><p><strong>后序遍历</strong>:左右根。</p><p>示例:前序: 12457836 中序: 42785136 后序: 48752631</p><blockquote><p>中序、后序从叶节点开始访问。</p></blockquote><p>◆层次遍历:按层次，从上到下，从左到右。◆反向构造_ &#x3D;叉树:仅仅有前序和后序是无法构造二叉树的，必须要是和中序遍历的集合才能反向构造出二叉树。构造时，前序和后序遍历可以确定根节点，中序遍历用来确定根节点的左子树节点和右子树节点，而后按此方法进行递归，直至得出结果。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015135239186.png" alt="image-20231015135239186"></p><h3 id="反向构造二叉树"><a href="#反向构造二叉树" class="headerlink" title="反向构造二叉树"></a>反向构造二叉树</h3><p>仅仅有前序和后序是无法构造二叉树的，<strong>必须要是和中序遍历的集合才能反向构造出二叉树</strong>。</p><blockquote><p>中序+前序或 中序+后续 才能反向构造二叉树。</p></blockquote><p>构造时，前序和后序遍历可以确定根节点，<strong>中序遍历用来确定根节点的左子树节点和右子树节点</strong>，而后按此方法进行递归，直至得出结果。</p><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p>一个高度为h的满二叉树的结点总数为2^h-1, 从根结点开始，自上而下、同层次结点从左至右，对结点按照顺序依次编号，即根结点编号为1,其左、右孩子结点编号分别为2和3,再下一层从左到右的编号为4，5，6, 7,依此类推。那么，在一棵满二叉树中，对于编号为m和n的两个结点，若n&#x3D;2m+1，则(D)</p><p>A.m是n的左孩子</p><p>B.m是n的右孩子</p><p> C.n是m的左孩子 </p><p>D.n是m的右孩子</p><p>某二叉树如图所示，若进行顺序存储(即用一维数组元素存储该二叉树中的结点且通过下标反映结点间的关系，例如，<strong>对于下标为i的结点,其左孩子的下标为2i、右孩子的下标为2i+1</strong>)，则该数组的大小至少为(D) ;若采用三叉链表存储该二叉树(各个结点包括结点的数据、父结点指针、左孩子指针、右孩子指针)，则该链表的所有结点中空指针的数目为(B)。 </p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142322242.png" alt="image-20231015142322242"></p><p>A.6B.10C.12.D.15A.6B.8C.12D.14</p><blockquote><p>把上图二叉树补为完全二叉树。2^4-1&#x3D;15。</p><p>一共有6个节点，每个节点有三个指针域。</p></blockquote><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>引入线索二叉树是为了<strong>保存二叉树遍历时某节点的前驱节点和后继节点的信息</strong>，二叉树的链式存储只能获取到某节点的左孩子和右孩子结点，无法获取其遍历时的前驱和后继节点，因此可以<strong>在链式存储中再增加两个指针域【四叉链表】</strong>，使其分别指向前驱和后继节点，但这样太浪费存储空间，考虑下述实现方法:</p><p>若<strong>n个节点的二叉树使用二叉链表存储，则必然有n+1个空指针域</strong>，利用这些空指针域来存放节点的前驱和后继节点信息，为此，需要增加两个标志，以区分指针域存放的到底是孩子结点还是遍历节点，如下:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142736066.png" alt="image-20231015142736066"></p><p>若二叉树的二叉链表采用上述结构, 则称为<strong>线索链表</strong>, 其中指向前驱、后继节点的指针称为线索，加上线索的二叉树称为线索二叉树。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142906222.png" alt="image-20231015142906222"></p><h3 id="哈夫曼树-x2F-最优二叉树【考点】"><a href="#哈夫曼树-x2F-最优二叉树【考点】" class="headerlink" title="哈夫曼树&#x2F;最优二叉树【考点】"></a>哈夫曼树&#x2F;最优二叉树【考点】</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>最优二叉树又称为哈夫曼树，是一类<strong>带权路径长度最短的树</strong>，相关概念如下:</p><blockquote><p>一个节点到另外一个结点的通路叫路径。</p></blockquote><p>◆ 路径:树中一个结点到另一个结点之间的通路。</p><p>◆结点的路径长度:路径上的分支数目。</p><p>◆树的路径长度:<strong>根节点到达每一个叶子节点之间的路径长度之和</strong>。</p><p>◆权:<strong>节点代表的值</strong>。</p><p>◆结点的带权路径长度:<strong>该结点到根结点之间的路径长度乘以该节点的权值</strong>。</p><p>◆树的带权路径长度(<strong>树的代价</strong>):<strong>树的所有叶子节点的带权路径长度之和</strong>。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015143629621.png" alt="image-20231015143629621"></p><h4 id="哈夫曼树的求法"><a href="#哈夫曼树的求法" class="headerlink" title="哈夫曼树的求法"></a>哈夫曼树的求法</h4><p>给出一组权值，<strong>将其中两个最小的权值作为叶子节点，其和作为父节点，组成二叉树，而后删除这两个叶子节点权值，并将父节点的值添加到该组权值中</strong>。重复进行上述步骤，直至所有权值都被使用完。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015144052502.png" alt="image-20231015144052502"></p><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>若需要构造哈夫曼编码(要保证<strong>左节点值小于右节点的值</strong>，才是<strong>标准的哈夫曼树</strong>) <strong>将标准哈夫曼树的左分支设为0,右分支设为1,写出每个叶节点的编码</strong>，会发现，哈夫曼编码前缀不同，因此不会混淆，同时也是最优编码。</p><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015150748271.png" alt="image-20231015150748271"></p><p>答案：AC</p><h3 id="查找二叉树（排序二叉树）【考点】"><a href="#查找二叉树（排序二叉树）【考点】" class="headerlink" title="查找二叉树（排序二叉树）【考点】"></a>查找二叉树（排序二叉树）【考点】</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015154438092.png" alt="image-20231015154438092"></p><p>◆查找二叉树上的每个节点都存储一个值，且<strong>每个节点的所有左孩子结点值都小于父节点值，而所有右孩子结点值都大于父节点值</strong>，是一个有规律排列的二叉树，这种数据结构可以<strong>方便查找</strong>【每一次都把查找范围缩小一半】、插入等数据操作。</p><p>◆二叉排序树的查找效率取决于二叉排序树的深度，<strong>对于结点个数相同的二叉排序树，平衡二叉树的深度最小</strong>，而<strong>单枝树的深度是最大的，故效率最差</strong>。【深度越大比较的次数越多】</p><p>◆平衡二叉树又称为<strong>AVL</strong>树【查找效率最高，深度最小】，它或者是一棵空树，或者是具有下列性质的二叉树。它的左子树和右子树都是平衡二叉树，<strong>且左子树和右子树的高度之差的绝对值不超过1</strong>。若将二叉树结点的<strong>平衡因子(Balance Factor, BF)定义为该结点左子树的高度减去其右子树的高度</strong>，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要树上有一个结点的平衡因子的绝对值大于1,则该二叉树就是不平衡的。</p><h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><p>某二叉树的先序遍历列为cabfedg,中序遍历序列为abcdefg,则二叉树是(C)。</p><p>A.完全二叉树</p><p>B.最优二叉树</p><p>C.平衡二叉树</p><p>D.满二叉树</p><blockquote><p>通过cabfedg确定c是根节点，进而把abcdefg分为左右子树：左子树：ab，右子树：defg；</p><p>通过前序遍历ab知道a是根结点，fedg知道f是右子树根节点。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015155253456.png" alt="image-20231015155253456"></p><p>答案：C</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>◆无向图:图的结点之间连接线是<strong>没有箭头的，不分方向</strong>。</p><p>◆有向图:图的结点之间<strong>连接线是箭头，区分A到B，和B到A是两条线</strong>。</p><p>◆完全图:无向完全图中，<strong>节点<u>两两之间</u>都有连线</strong>，n个结点的连线数为（n-1）+(n-2)+…+1&#x3D; n(n-1)&#x2F;2;有向完全图中，节点两两之间都有互通的两个箭头，n个节点的连线数为n(n-1)。</p><p>◆度、出度和入度:顶点的度是<strong>关联与该顶点的边的数目</strong>。在有向图中，<u>顶点的度为出度和入度之和</u>。</p><p>◆路径:存在一条通路，可以从一个顶点到达另一个顶点。</p><p>◆子图:<strong>有两个图G&#x3D;(V, E)和G’&#x3D;(V’, E’)，如果V’∈V且E’∈E，则称G’为G的子图</strong>。</p><blockquote><p>V是定点结合，E是边的集合。</p></blockquote><p>◆连通图和连通分量:<strong>针对无向图</strong>。若从顶点v到顶点u之间是有路径的，则说明v和u之间是连通的，若无向图中任意两个顶点之间都是连通的，则称为连通图。无向图G的<u>极大连通子图</u>称为其连通分量。</p><p>◆强连通图和强连通分量:<strong>针对有向图</strong>。若有向图任意两个顶点间都互相存在路径，即存在v到u，也存在u到v的路径，则称为强连通图。有向图中的极大连通子图称为其强连通分量。</p><p>◆网:<strong>边带权值的图称为网</strong>。</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p><strong>邻接矩阵</strong>:假设一个图中有<strong>n个节点， 则使用n阶矩阵来存储这个图中各节点的关系,规则是若节点i到节点j有连线，则矩阵Ri,j&#x3D;1, 否则为0</strong>，示例如下图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015165419622.png" alt="image-20231015165419622"></p><blockquote><p>无向图的邻接矩阵是一个对角阵。</p></blockquote><p>适合边比较多的图。</p><p><strong>邻接链表</strong>:用到了两个数据结构,先用一个一维数组将图中所有顶点存储起来，而后，对此一维数组的每个顶点元素，使用链表挂上其出度到达的结点的编号和权值，示例如下图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015165801499.png" alt="image-20231015165801499"></p><p>存储特点:<strong>图中的顶点数决定了邻接矩阵的阶和邻接表中的单链表数目，边数的多少决定了单链表中的结点数</strong>，<strong>而不影响邻接矩阵的规模</strong>，因此采用何种存储方式与有向图、无向图没有区别，要看图的边数和顶点数，<strong>完全图适合采用邻接矩阵存储</strong>。</p><blockquote><p>有向图只考虑出度。</p></blockquote><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>◆图的遍历是<strong>指从图的任意节点出发</strong>，<strong>沿着某条搜索路径对图中所有节点进行访问且只访问一次</strong>,分为以下两种方式:</p><blockquote><p>图的遍历方式不唯一。</p></blockquote><p>◆深度优先遍历:<strong>从任一顶点出发,遍历到底，直至返回，再选取任一其他节点出发</strong>，重复这个过程直至遍历完整个图;</p><p>◆广度优先遍历:先访问完一个顶点的所有邻接顶点，<strong>而后再依次访问其邻接顶点的所有邻接顶点</strong>，类似于层次遍历。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015170314834.png" alt="image-20231015170314834"></p><h3 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h3><p>假设有n个节点，那么这个图的最小生成树有n-1条边(不会形成环路，是树非图)，这n-1条边应该会将所有顶点都连接成一个树，井且这些边的权值之和最小，因此称为最小生成树。共有下列两种算法:</p><h4 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h4><p><strong>普里姆算法</strong>:从<strong>任意顶点出发，找出与其邻接的边权值最小的，此时此边的另外一个顶点自动加入树集合中，而</strong><strong>后再从<u>这个树集合的所有顶点</u>中找出与其邻接的边权值最小的</strong>，同样此边的另外一个顶点加入树集合中，依次递归，直至图中所有顶点都加入树集合中，此时此树就是该图的最小生成树。普里姆算法的时间复杂度为0(n^2)，<strong>与图中的边数无关，因此该算法适合于求边稠密的网的最小生成树</strong>。</p><blockquote><p>最小生成树不唯一。但最终的权值之和相等。在面临多个相同的权值时，对权值的选择要保证不能形成一个环，如果形成一个环，既不符合定义了。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015170655573.png" alt="image-20231015170655573"></p><h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><p>克鲁斯卡尔算法(推荐) :这个算法是<strong>从边出发的</strong>，因为本质是选取权值最小的n-1条边，因此，就将边按权值大小排序，依次选取权值最小的边，直至囊括所有节点，要注意，每次选边后要检查<strong>不能形成环路</strong>。克鲁斯卡尔算法的时间复杂度为0(eloge)，与图中的顶点数无关，因此该算法<strong>适合于求边稀疏的网的最小生成树</strong>。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015171605178.png" alt="image-20231015171605178"></p><blockquote><p>Prim算法从扩展顶点开始，每次总是“贪心的”选择与当前顶点集合中距离域短的顶点，而Kruscal算法从扩展边开始，每次总是“ 贪心的”选择剩余的边中最小权重的边，因此两个算法都是基于贪心策略进行的。Prim算法的时间复杂度为0( n2)，其中n为图的顶点数，该算法的计算时间与图中的边数无关，因此该算法适合于求边稠密的图的最小生成树；</p><p>Kruscal算法的时间复杂度为0( mlgm)，其中m为图的边数，该算法的计算时间与图中的顶点数无关，因此该算法适合于求边稀疏的图的最小生成树。当图稠密时，用Prim算法效率更高。但若事先没有关于图的拓扑特征信息时，无法判断两者的优劣。由于一个图的最小生成树可能有多棵，因此不能保证用这两种算法得到的是同一棵最小生成树。</p></blockquote><h3 id="拓扑序列【考点】"><a href="#拓扑序列【考点】" class="headerlink" title="拓扑序列【考点】"></a>拓扑序列【考点】</h3><p>若<strong>图中一个节点入度为0，则应该最先执行此活动，而后删除掉此节点和其关联的有向边，再去找图中其他没有入度的结点，执行活动，依次进行</strong>，示例如下(有点类似于进程的前趋图原理)</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015171944618.png" alt="image-20231015171944618"></p><h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172250039.png" alt="image-20231015172250039"></p><p>答案：AB</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172257703.png" alt="image-20231015172257703"></p><p>答案：A</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172520892.png" alt="image-20231015172520892"></p><p>答案：CA</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172749299.png" alt="image-20231015172749299"></p><p>答案:C</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>◆顺序查找的思想:将待查找的关键字为key的元素从头到尾与表中元素进行比较，如果中间存在关键字为key的元素，则返回成功;否则，则查找失败。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015173203799.png" alt="image-20231015173203799"></p><p>时间复杂度为O(n);</p><h2 id="折半查找【考点】"><a href="#折半查找【考点】" class="headerlink" title="折半查找【考点】"></a>折半查找【考点】</h2><p>◆只适用于待查找序列中的元素是<strong>有序排列</strong>的情况。</p><p>◆设查找表的元素存储在一维数组r[1..n]中，在表中元素已经按照关键字递增(或递减)方式排序的情况下，进行折半查找的方法是:</p><p>1、首先将待查元素的关键字(key) 值与表r中间位置上(下标为mid)记录的关键字进行比较，若相等，则查找成功;</p><p>2、若key&gt;r[mid].key，则说明待查记录只可能在后半个子表r[mid+1..n]中，下一步应在后半个子表中查找;</p><p>3、若key&lt;r[mid].key， 说明待查记录只可能在前半个子表r[1..mid-1]中，下一步应在r的前半个子表中查找;</p><p>4、重复上述步骤，逐步缩小范围，直到查找成功或子表为空失败时为止。</p><p>要注意两点:<u><strong>中间值位置求出若为小数，应该向下取整</strong></u>，即4.5&#x3D;4， 非四舍五入;中间值已经比较过不相等，在划分下一次比较区间时，<strong>无需将中间值位置再纳入下一次比较区间</strong>。</p><p>时间复杂度为O(log2n)。</p><h2 id="哈希表-x2F-散列表【考点】"><a href="#哈希表-x2F-散列表【考点】" class="headerlink" title="哈希表&#x2F;散列表【考点】"></a>哈希表&#x2F;散列表【考点】</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>哈希表通过一个以<strong>记录的关键字</strong>为自变量的函数(称为<strong>哈希函数</strong>)得到<strong>该记录的存储地址</strong>，所以在哈希表中进行查找操作时，需要用同一哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获得有关信息再判定查找是否成功。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>当多个关键字产生同一个地址时，则产生<strong>哈希冲突</strong>。</p><blockquote><p>解决哈希冲突的算法sha-256，md5</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015180624273.png" alt="image-20231015180624273"></p><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>哈希函数产生了冲突的解决方法如下:</p><p><a href="https://www.bilibili.com/video/BV1D54y177MP?t=10.0">https://www.bilibili.com/video/BV1D54y177MP?t=10.0</a></p><p>1.<strong>开放定址法</strong>: Hi&#x3D;(H(key)+di) % m，i&#x3D;1, 2….. k&lt;(k&lt;&#x3D;m-1).其中，H(key)为哈希函数; m为哈希表表长; di为增量序列。</p><p>常见的增量序列有以下3种。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015181550933.png" alt="image-20231015181550933"></p><p><strong>线性探测法：</strong></p><p>添加元素时，使用散列函数确定元素的插入位置，如果此空间有值：</p><p>1.该值是所要插入元素的关键码，不进行插入。</p><p>2.产生冲突，依次查看其后的下一个桶，如果发现空位置插入新元素。</p><p>注意：</p><p>散列表的载荷因子：a &#x3D; 插入元素个数 &#x2F; 散列表的长度</p><p>a是散列表装满程度的标志因子。对于开放地址法，载荷因子非常重要，应严格限制在 0.7~0.8 以下。超过 0.8 ，查表时的CPU缓存按照指数曲线上升。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>2.链地址法。它在查找表的每一个记录中增加一个链域，链域中存放下一个具有相同哈希函数值的记录的存储地址。利用链域，<strong>就把若干个发生冲突的记录链接在一个链表内</strong>。当链域的值为NULL时，表示已没有后继记录了。因此，对于发生冲突时的查找和插入操作就跟线性表一样了。</p><p>3.再哈希法:在同义词发生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生聚集现象，但增加了计算时间。</p><p>4.建立一个公共溢出区。无论由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入到公共溢出区中。</p><h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015181950594.png" alt="image-20231015181950594"></p><p>答案：A</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015182204804.png" alt="image-20231015182204804"></p><p>答案：B</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>◆要注意的是，前提条件是<strong>前i-1个元素是有序的，第1个元素依次从第i-1个元素往前比较，直到找到一个比第1个元素值小的元素，而后插入，插入位置及其后的元素依次向后移动。</strong></p><p>◆当给出一队无序的元素时，首先，应该将第1个元素看做是一个有序的队列，而后从第2个元素起，按插入排序规则，依次与前面的元素进行比较，直到找到一个小于他的值，才插入。示例如下图所示:</p><p>下图中，59依次向前比较，先和68比较，再和57比较,发现57比他小，才插入。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015182516357.png" alt="image-20231015182516357"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>针对较大的数据排序。</p></blockquote><p>◆希尔排序又称“<strong>缩小增量排序</strong>”，是<strong>对直接插入排序方法的改进</strong>。</p><p>◆希尔排序的基本思想是:先<strong>将整个待排记录序列分割成若干子序列</strong>，然后<strong>分别进行直接插入排序</strong>，待整个序列中的记录<strong>基本有序时</strong>，<strong>再对全体记录进行一次直接插入排序</strong>。</p><p>◆具体做法是:<strong>先取一个小于n的整数d1作为第一个增量</strong> ,把文件的全部记录分成d1个组，<strong>将所有距离为d1倍数的记录放在同一个组中，在各组内进行直接插入排序</strong>;然后取第二个增量d2(d2 &lt;d1),重复上述分组和排序工作，依此类推，直至所取的增量di&#x3D;1(di &lt;di-1&lt;… &lt;d2 &lt;d1),即所有记录放在同一组<strong>进行直接插入排序为止</strong>。</p><p>◆按上述，希尔排序实际是<strong>为了解决大数据的排序问题</strong>，当待排序的数据很多时，使用直接插入排序效率很低，因此，采取分组的方法，使问题细化，可以提高效率,适用于多数据。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030201350758.png" alt="image-20231030201350758"></p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p><a href="https://www.bilibili.com/video/BV1Lp4y1Y75f?t=229.0">https://www.bilibili.com/video/BV1Lp4y1Y75f?t=229.0</a></p><p>◆n个记录进行简单选择排序的基本方法是:<strong>通过n - i(1&lt;&#x3D;i&lt;&#x3D;n)次关键字之间的比较,从n-i+ 1个记录中选出关键字最小的记录，并和第i个记录进行交换</strong>，当i等于n时所有记录有序排列。</p><p>◆按上述，<strong>本质就是每次选择出最小的元素进行交换</strong>，主要是选择比较过程,交换过程只有一次。示例如下:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030202554023.png" alt="image-20231030202554023"></p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231102170901023.png" alt="image-20231102170901023"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>对于 $n$ 个元素的关键字序列 </p><p>$$K_1, K_2, …, K_n$$</p><p>, 当且仅当满足下列关系时称其为堆, 其中 $2i$ 和 $2i+1$ 需不大于 $n$ 。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030203649882.png" alt="image-20231030203649882"></p><blockquote><p>左侧为小根堆：，右侧为大根堆。</p></blockquote><p>堆排序的基本思想是: 对一组待排序记录的关键字, 首先按堆的定义排成一个序列 (即建立初始堆), 从而可以输出堆顶的最大关键字 (对于大根堆而言), 然后将剩余的关键字再调整成新堆, 便得到次大的关键字, 如此反复, 直到全部关键字排成有序序列为止。</p><p>为序列(55,60,40,10,80,65,15,5,75) 建立初始大根堆的过程如图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030204036239.png" alt="image-20231030204036239"></p><blockquote><p>找到最后一个非叶子节点，比较该根节点和其孩子节点大小，并交换位置。</p></blockquote><p>◆由上图可知，<strong>首先将给出的数组按完全二叉树规则建立</strong>，而后，找到此完全二叉树的<strong>最后一个非叶子节点(也即最后一颗子树)<strong>，比较</strong>此非叶子节点和其两个孩子结点的大小</strong>，若小，则与其孩子结点中最大的结点进行交换;依据此规则再去找倒数第二个非叶子节点;这是只有一层的情况，当涉及到多层次时,又打破了之前的堆，因此,又要进行变换。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030204741673.png" alt="image-20231030204741673"></p><p> ◆建立初始堆后，开始排序，每次取走堆顶元素(必然是最大的)，而后将堆中最后一个元素移入堆顶，而后按照初始建堆中的方法与其孩子结点比较大小,依次向下判断交换成为一个新的堆，再取走堆顶元素，重复此过程。</p><p>◆堆排序适用于在多个元素中找出前几名的方案设计，因为堆排序是选择排序,而且选择出前几名的效率很高。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030205026957.png" alt="image-20231030205026957"></p><p>◆n个记录进行冒泡排序的方法是:首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序,则交换这两个记录的值，然后比较第二个记录和第三个记录的关键字,依此类推，直至第n - 1个记录和第n个记录的关键字比较过为止。</p><p>上述过程称为<strong>一趟冒泡排序</strong>，<strong>其结果是关键字最大的记录被交换到第n个记录的位置上</strong>。然后进行第二趟冒泡排序，<strong>对前n-1个记录进行同样的操作，其结果是关键字次大的记录被交换到第n - 1个记录的位置上</strong>。最多进行n-1趟,所有记录有序排列。<strong>若在某趟冒泡排序过程没有进行相邻位置的元素交换处理，则可结束排序过程</strong>。</p><p>◆示例给的是<strong>从后往前排序，也是可以的</strong>，需要从最后两个元素开始进行比较，将较小的元素交换到前面去，依次进行比较交换。比较是为了交换，交换次数很多。区分冒泡排序和简单选择排序。</p><blockquote><p>简单排序只有一次交换；冒泡排序有多次交换，效率比较低。</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030212746661.png" alt="image-20231030212746661"></p><p>◆快速排序是将n个记录分成两块，再递归，实际分成两块的方法如图所示:设定一个基准为57,设定<strong>两个指针</strong>high&#x3D;1, low&#x3D;n, 从low指向的第n个元素开始，与基准值进行比较，若小于基准值，则与基准进行交换low–,此时，转而从high指向的第1个元素开始和基准值进行比较，若大于基准值，则和基准值进行交换，此时，又转而从low指向的值和基准进行比较,重复上述过程。</p><blockquote><p>基准值越靠近中位数越好。默认为待排序序列第一个值。</p></blockquote><blockquote><p>每一次交换元素后，指针都会变化。</p></blockquote><p>◆要注意的是:每次都是和基准值进行比较，因此最终是以基准值为中间，将队列分成两块。只有当和基准值发生了交换，才变换high和low指针的计数，否则，会一直low–下去。</p><p>◆上图中，最终以57为界，左边都是小于57的元素,右边都是大于57的元素，完成一次快速排序,接着对两块再分别进行递归即可。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>◆所谓“归并，是将两个或两个以上的有序文件合并成为一个新的有序文件。归并排序的一种实现方法是把<strong>一个有n个记录的无序文件看成是由n个长度为1的有序子文件组成的文件，然后进行两两归并</strong>，得到[n&#x2F;21]个长度为2或1的有序文件,再两两归并，如此重复，直至最后形成包含n个记录的有序文件为止。这种反复将两个有序文件归并成一个有序文件的排序方法称为<strong>两路归并排序</strong>。</p><p>◆要仔细理解上述过程，一般归并排序都是用来合并多个线性表的，<strong>对单列数据，二路归并排序可以对元素进行两两合并</strong>，示例如下:</p><p>◆对第三次归并，将52与28比较，28小,放入新表头, 52再与33比较, 33放入新表，52再与72比较, 52放入新表, 57再与72比较，57放入新表….</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030213950141.png" alt="image-20231030213950141"></p><h2 id="基数排序【不考】"><a href="#基数排序【不考】" class="headerlink" title="基数排序【不考】"></a>基数排序【不考】</h2><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030214531213.png" alt="image-20231030214531213"></p><p>基数排序是基于多个关键字来进行多轮排序的，本质也是将问题细分，如图例子，分别按个位、干位、百位的大小作为关键字进行了三轮排序，最终得出结果。</p><h2 id="内部排序算法总结【重要】"><a href="#内部排序算法总结【重要】" class="headerlink" title="内部排序算法总结【重要】"></a>内部排序算法总结【重要】</h2><blockquote><p>内部排序就是在内存内排序。</p></blockquote><p>(1)若待排序的记录数目n较小，可采用直接插入排序和简单选择排序。由于直接插入排序所需的记录移动操作较简单选择排序多，因此当记录本身信息量较大时，用简单选择排序方法较好。</p><p>(2)若待排序记录按关键字<strong>基本有序，则宜采用直接插入排序或冒泡排序</strong>。</p><p>(3)<strong>当n很大且关键字的位数较少时，采用链式基数排序较好</strong>。</p><p>(4)若n较大，则应采用时间复杂度为O(nlogn)的排序方法，例如快速排序、堆排序或归并排序。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030214628503.png" alt="image-20231030214628503"></p><blockquote><p>稳定性是指在排序时，重复的元素位置不改变。</p></blockquote><blockquote><p>O(1)是指常量空间，即所需要的空间几乎不变化。</p></blockquote><blockquote><p>log默认以2为底。快速排序有二分的思想，时间复杂度为nlogn.</p></blockquote><blockquote><p>归并排序需要一个新表，需要辅助空间。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030215546973.png" alt="image-20231030215546973"></p><blockquote><p>排序是一类最基本的操作，因此要求考生熟悉一些典型的排序算法，包括其算法思想、时空复杂度以及应用场合。若数据基本有序，插入排序应该是最佳选择，输入数据是否有序对归并和计数排序算法并没有影响。对传统的快速排序算法，输入数据有序反而使其效率最低。若关键字取值范围较小，则计数排序是最佳选择，因为在该情况下该管注的时间旨垫底为线性时间</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>11.文老师-软件工程基础知识.md</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-10-14T12:06:15.000Z</published>
    <updated>2023-10-28T01:38:53.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="信息系统生命周期"><a href="#信息系统生命周期" class="headerlink" title="信息系统生命周期"></a>信息系统生命周期</h1><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015193753582.png" alt="image-20231015193753582"></p><p>◆软件工程基本原理:用分阶段的生命周期计划严格管理、坚持进行阶段评审、实现严格的产品控制、采用现代程序设计技术、结果应能清楚的审查、开发小组的人员应少而精、承认不断改进软件工程实践的必要性。</p><p>◆**软件工程的基本要素:<u>方法、工具过程</u>**。</p><p>◆软件生存周期:可行性分析与项目开发计划、需求分析、概要设计(选择系统解决方案，规划子系统)、详细设计(设计子系统内部具体实现)、编码、测试、维护。</p><h2 id="信息系统五阶段生命周期【考点】"><a href="#信息系统五阶段生命周期【考点】" class="headerlink" title="信息系统五阶段生命周期【考点】"></a>信息系统五阶段生命周期【考点】</h2><p>◆1.系统规划阶段:任务是对组织的环境、目标及现行系统的状况进行<strong>初步调查</strong>,根据组织目标和发展战略确定信息系统的发展战略，<strong>对建设新系统的需求做出分析和预测</strong>，同时考虑建设新系统所受的各种约束，研究建设新系统的必要性和可能性。根据需要与可能，给出制建系统的备选方案。</p><p>输出:**可行性研究报告、<u>系统设计任务书</u>**。</p><p>◆2.系统分析阶段: 任务是根据系统设计任务书所确定的范围，<strong>对现行系统进行详细调查</strong>，描述现行系统的业务流程，指出现行系统的局限性和不足之处,确定新系统的基本目标和逻辑功能要求，即提出新系统的逻辑模型。系统分析阶段又称为<strong>逻辑设计阶段</strong>。这个阶段是<strong>整个系统建设的关键阶段</strong>，也是信息系统建设与一般工程项目的重要区别所在。<strong>得出系统的逻辑模型</strong>。</p><p>输出:系统说明书【也称需求说明书】。</p><p>◆3.系统设计阶段:系统分析阶段的任务是回答系统“做什么”的问题，而<strong>系统设计阶段要回答的问题是”怎么做”</strong>。该阶段的任务是根据系统说明书中规定的功能要求，具体设计实现逻辑模型的技术方案，也就是设计新系统的物理模型。这个阶段又称为<strong>物理设计阶段</strong>，可分为<strong>总体设计(概要设计)和详细设计</strong>两个子阶段。</p><p>输出**:系统设计说明书(概要设计、详细设计说明书)**</p><p>◆4.系统实施阶段:是将设计的系统付诸实施的阶段。这一阶段的任务包括计算机等设备的购置、安装和调试、程序的编写和调试、人员培训、数据文件转换、系统调试与转换等。这个阶段的特点是几个互相联系、互相制约的任务同时展开，必须精心安排、合理组织。系统实施是按实施计划分阶段完成的，每个阶段应写出实施进展报告。系统测试之后写出<strong>系统测试分析报告</strong>。</p><p>输出:<strong>实施进展报告、系统测试分析报告</strong>。</p><p>◆5.系统运行和维护阶段:系统投入运行后，需要经常进行维护和评价，记录系统运行的情况，根据一定的规则对系统进行必要的修改，评价系统的工作质量和经济效益。</p><h1 id="能力成熟度模型"><a href="#能力成熟度模型" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h1><h2 id="能力成熟度模型CMM"><a href="#能力成熟度模型CMM" class="headerlink" title="能力成熟度模型CMM"></a>能力成熟度模型CMM</h2><blockquote><p>用来衡量公司开发软件的能力。</p></blockquote><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015194859347.png" alt="image-20231015194859347"></p><h2 id="能力成熟度模型集成CMMI"><a href="#能力成熟度模型集成CMMI" class="headerlink" title="能力成熟度模型集成CMMI"></a>能力成熟度模型集成CMMI</h2><p>是若干过程模型的综合和改进，不仅仅软件，而是支持<strong>多个工程学科和领域的</strong>、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率。</p><p>CMMI两种表示方法:</p><p>(1)<strong>阶段式模型</strong>【考点】:类似于CMM，它关注组织的成熟度，五个成熟度模型如下:</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015195644955.png" alt="image-20231015195644955"></p><p>（2）连续式模型:关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200040621.png" alt="image-20231015200040621"></p><h1 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h1><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><blockquote><p>开发中小型系统较多，现在逐渐被淘汰。适合需求明确的情况。</p></blockquote><p>◆瀑布模型(SDLC):瀑布模型是一个经典的软件生命周期模型,一般将软件开发分为:可行性分析(计划)、需求分析、 软件设计(概要设计、详细设计)、编码(含单元测试)、测试、运行维护等几个阶段。</p><p>◆瀑布模型特点</p><p>(1)从<strong>上一项开发活动接受该项活动的工作对象作为输入</strong>。</p><p>(2)利用这一输入， <strong>实施该项活动应完成的工作内容</strong>。</p><p>(3)给出该项活动的<strong>工作成果，作为输出</strong>传给下一项开发活动。</p><p>(4)对<strong>该项活动的实施工作成果进行评审</strong>。若其工作成果得到确认，则继续进行下一项开发活动;否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200121645.png" alt="image-20231015200121645"></p><h2 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h2><blockquote><p>螺旋模型和风险挂钩。</p></blockquote><p>◆螺旋模型是一个演化软件过程模型，将原型实现的迭代特征与线性顺序(瀑布)模型中控制的和系统化的方面结合起来。在螺旋模型中，软件开发是一系列的增量发布。</p><p>◆开发过程具有周期性重复的螺旋线状。四个象限分别标志每个周期所划分的四阶段:<strong>制订计划、<u>风险分析</u>、实施工程和客户评估</strong>。螺旋模型强调了风险分析，<strong>特别适用于庞大而复杂的、高风险的系统</strong>。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200443829.png" alt="image-20231015200443829"></p><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><blockquote><p>V模式认为每一阶段都应该进行测试。</p></blockquote><p>◆V模型从整体.上看起来，就是一个V字型的结构， 由左右两边组成。左边的下画线分别代表了需求分析、概要设计、详细设计、编码。右边的上画线代表了单元测试、集成测试、系统测试与验收测试。V模型的特点如下:</p><p>(1)单元测试的主要目的是针对编码过程中可能存在的各种错误;【单边】</p><p>(2)集成测试的主要目的是针对详细设计中可能存在的问题;【吉祥】</p><p>(3)系统测试主要针对概要设计，检查系统作为一个整体是否有效地得到运行;【膝盖】</p><p>(4)验收测试通常由业务专家或者用户进行，以确认产品能真正符合用户业务上的需要。【延续】</p><p>(5) V模型用于需求明确和需求变更不频繁的情形。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200733419.png" alt="image-20231015200733419"></p><h2 id="原型化模型"><a href="#原型化模型" class="headerlink" title="原型化模型"></a>原型化模型</h2><p>◆原型化模型第一步就是<strong>创建一个快速原型</strong>，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论和分析，最终弄清楚当前系统的需求，进行了充分的了解之后，在原型的基础上开发出用户满意的产品。</p><blockquote><p>适用于需求不明确的情况。</p></blockquote><p>◆原型法认为在很难一下子全面准确地提出用户需求的情况下，原型应当具备的特点如下。</p><p>(1)实际可行</p><p>(2)具有最终系统的基本特征</p><p>(3)构造方便、快速，造价低。原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的。</p><p><strong>例题</strong>以下关于快速原型模型优点的叙述中，不正确的是（)</p><p>A有助于满足用户的真实需求</p><p>B适用于大型软件系统的开发</p><p>C开发人员快速开发出原型系统，因此可以加速软件开发过程。节约开发成本</p><p>D原型系统已经通过与用户的交互得到验证，因此对应的规格说明文档能正确描述用户需求</p><blockquote><p>快速原型模型比较适合于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。<strong>开发大型软件系统适用螺旋模型或者RUP模型</strong>。</p></blockquote><h2 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h2><p>◆增量模型:首先开发核心模块功能，而后与用户确认，之后再开发次核心模块的功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发,优先级最高的服务最先交付。</p><p>◆特点:但由于并不是从系统整体角度规划各个模块，因此不利于模块划分。难点在于如何将客户需求划分为多个增量。与原型不用的是增量模型的<strong>每一次增量版本都可作为独立可操作的作品</strong>，而原型的构造一般是为了演示。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015201403427.png" alt="image-20231015201403427"></p><h2 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h2><p>◆喷泉模型:是一种以用户需求为动力，以对象作为驱动的模型,适合于<strong>面向</strong><strong>对象</strong>的开发方法。使开发过程具有迭代性和无间隙性。</p><h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><p>基于构件的开发模型CBSD:利用<strong>预先包装的构件来构造应用系统</strong>。构件可以是组织内部开发的构件，也可以是商品化成品软件构件。特点是增强了复用性，在系统开发过程中，会构建-个构件库, 供其他系统<strong>复用</strong>，因此可以提高可靠性，节省时间和成本。</p><h2 id="形式化方法模型"><a href="#形式化方法模型" class="headerlink" title="形式化方法模型"></a>形式化方法模型</h2><p>形式化方法模型:建立在<strong>严格数学基础</strong>上的一种软件开发方法,主要活动是生成计算机软件形式化的数学规格说明。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015201633281.png" alt="image-20231015201633281"></p><p>答案：A D</p><h1 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h1><h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><p>◆结构是指系统内各个组成要素之间的相互联系、相互作用的框架。</p><p>◆结构化方法也称为生命周期法,是-种传统的信息系统开发方法，由<strong>结构化分析</strong>(Structured Analysis,SA)、<strong>结构化设计</strong>(Structured Design, SD)和<strong>结构化程序设计</strong>(Structured Programming, SP) 三部分有机组合而成，其精髓是自顶向下、逐步求精和模块化设计。</p><blockquote><p>面向数据流。</p></blockquote><h3 id="结构化方法的主要特点"><a href="#结构化方法的主要特点" class="headerlink" title="结构化方法的主要特点"></a>结构化方法的主要特点</h3><p>(1)<strong>开发目标清晰化</strong>。结构化方法的系统开发遵循”用户第一”的原则。</p><p>(2)<strong>开发工作阶段化</strong>。每个阶段工作完成后，要<strong>根据阶段工作目标和要求进行审查</strong>，这使各阶段工作有条不紊地进行，便于项目管理与控制。</p><p>(3)<strong>开发文档规范化</strong>。结构化方法每个阶段工作完成后，要<strong>按照要求完成相应的文档</strong>，以保证各个工作阶段的衔接与系统维护工作的遍历。</p><p>(4)<strong>设计方法结构化</strong>。在系统分析与设计时，从整体和全局考虑，<strong>自顶向下地分解</strong>;在系统实现时,根据设计的要求，先编写各个具体的功能模块，然后，<strong>自底向上逐步实现整个系统</strong>。</p><h3 id="结构化方法的不足与局限"><a href="#结构化方法的不足与局限" class="headerlink" title="结构化方法的不足与局限"></a>结构化方法的不足与局限</h3><p>(1)<strong>开发周期长</strong>:按顺序经历各个阶段,直到实施阶段结束后，用户才能使用系统。</p><p>(2)<strong>难以适应需求变化</strong>:不适用于需求不明确或经常变更的项目。</p><p>(3)**很少考虑数据结构:**结构化方法是一 种面向过程，面向数据流的开发方法，很少考虑数据结构。</p><h3 id="结构化方法常用工具"><a href="#结构化方法常用工具" class="headerlink" title="结构化方法常用工具"></a>结构化方法常用工具</h3><p>结构化方法一般利用图形表达用户需求，常用工具有<strong>数据流图、数据字典、结构化语言、判定表以及判定树</strong>等。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>◆面向对象(Object-Oriented, OO)方法认为，客观世界是由各种对象组成的，<strong>任何事物都是对象，每一个对象都有自己的运动规律和内部状态，都属于某个对象类</strong>，是该对象类的一个元素。复杂的对象可由相对简单的各种对象以某种方式而构成，不同对象的组合及相互作用就构成了系统。</p><blockquote><p>类是对象的集合体，就像乘用车是汽车的一个对象。</p></blockquote><h3 id="面向对象方法的特点"><a href="#面向对象方法的特点" class="headerlink" title="面向对象方法的特点"></a>面向对象方法的特点</h3><p>(1)使用OO方法构造的系统具有<strong>更好的复用性</strong>【类的继承】，其关键在于建立一个全面、合理、统一的模型(<strong>用例模型和分析模型</strong>)。</p><p>(2) OO方法也划分阶段，但其中的<strong>系统分析、系统设计和系统实现</strong>三个阶段之间已经<strong>没有“缝隙”</strong>。也就是说，这<strong>三个阶段的界限变得不明确</strong>，某项工作既可以在前一个阶段完成，也可以在后一个阶段完成;前一个阶段工作做得不够细，在后一个阶段可以补充。</p><p>(3)面向对象方法可以<strong>普遍适用于各类信息系统的开发</strong>。</p><h3 id="面向对象方法的不足之处"><a href="#面向对象方法的不足之处" class="headerlink" title="面向对象方法的不足之处"></a>面向对象方法的不足之处</h3><p><strong>必须依靠一定的面向对象技术支持，在大型项目的开发上具有一定的局限性，<u>不能涉足系统分析以前的开发环节</u>。</strong></p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a><strong>现状</strong></h3><p>当前， 一些大型信息系统的开发，通常是<strong>将结构化方法和 OO方法结合起来</strong>。首先，使用结构化方法进行自顶向下的整体划分;然后，自底向上地采用 OO方法进行开发。因此，结构化方法和 OO方法仍是两种在系统开发领域中相互依存的、不可替代的方法。</p><h2 id="原型化方法"><a href="#原型化方法" class="headerlink" title="原型化方法"></a>原型化方法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>◆原型化方法也称为<strong>快速原型法</strong>，或者简称为<strong>原型法</strong>。它是一种根据用户初步需求，利用系统开发工具，<strong>快速地建立一个系统模型展示给用户</strong>，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。</p><p>◆按是<strong>否实现功能</strong>分类:分为水平原型(行为原型，功能的导航)【没有实现功能】、垂直原型(结构化原型，实现了部分功能)。</p><p>◆按<strong>最终结果</strong>分类:分为抛弃式原型【后续抛弃该原型】、演化式原型【后续在该原型基础上改进】。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015215139241.png" alt="image-20231015215139241"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>原型法可以使系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益。</p><p>原型法是<strong>以用户为中心来开发系统</strong>的，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加了用户的满意度，提高了系统开发的成功率。</p><p>由于用户参与了系统开发的全过程，<strong>对系统的功能和结构容易理解和接受</strong>，有利于系统的移交，有利于系统的运行与维护。</p><h3 id="原型法的不足之处"><a href="#原型法的不足之处" class="headerlink" title="原型法的不足之处"></a>原型法的不足之处</h3><p><strong>开发的环境要求高。管理水平要求高【指和客户交流的过程要求高】。</strong></p><p>◆由以上的分析可以看出，原型法的优点主要在于能更有效地确认用户需求。从直观上来看，原型法适用于那些需求不明确的系统开发。事实上，<strong>对于分析层面难度大、技术层面难度不大的系统，适合于原型法开发</strong>。</p><p>◆从严格意义上来说，目前的原型法不是一种独立的系统开发方法，而<strong>只是一种开发思想</strong>，它只支持在系统开发早期阶段快速生成系统的原型，没有规定在原型构建过程中必须使用哪种方法。因此，它不是完整意义上的方法论体系。这就注定了原型法必须与其他信息系统开发方法结合使用。</p><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p> 敏捷开发是一种<strong>以人为核心、迭代、循序渐进的开发方法</strong>，相对于传统软件开发方法的“非敏捷”，更<strong>强调程序员团队与业务专家之间的紧密协作、面对面的沟通(认为比书面的文档更有效)、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。</strong></p><blockquote><p>一般针对中小型项目。</p></blockquote><p>◆敏捷软件开发宣言:</p><p>1.个体和交互胜过过程和工具</p><p>2.可以工作的软件胜过面面俱到的文档</p><p>3.客户合作胜过合同谈判</p><p>4.响应变化胜过遵循计划</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015215429304.png" alt="image-20231015215429304"></p><p>◆结对编程:<strong>一个程序员开发，另一个程序在一旁观察审查代码</strong>，能够有效的提高代码质量，在开发同时对代码进行初步审查，共同对代码负责。</p><p>◆自适应开发:强调开发方法的<strong>适应性</strong>(Adaptive) 。不象其他方法那样有很多具体的实践做法，它更<strong>侧重为软件的重要性提供最根本的基础</strong>，并从更高的组织和管理层次来阐述开发方法为什么要具备适应性。</p><p>◆水晶方法:<strong>每一个不同的项目都需要一套不同的策略、约定和方法论</strong>。</p><p>◆特性驱动开发:是一套<strong>针对中小型软件开发项目的开发模式</strong>。是一个<strong>模型驱动的快速迭代开发过程</strong>，它强调的是简化、实用、易于被开发团队接受，适用于需求经常变动的项目。</p><p>◆极限编程XP:核心是<strong>沟通、简明、反馈和勇气</strong>。因为知道计划永远赶不上变化，XP<strong>无需开发人员在软件开始初期做出很多的文档</strong>。XP提<strong>倡测试先行</strong>，为了将以后出现bug的几率降到最低。</p><p>◆并列争球法SCRUM:是一种<strong>迭代的增量化过程</strong>，把<strong>每段时间(30天)一次的迭代称为一个“冲刺”</strong>，并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品。</p><blockquote><p>每30天更新一个版本。</p></blockquote><h2 id="统一过程-RUP"><a href="#统一过程-RUP" class="headerlink" title="统一过程(RUP)"></a>统一过程(RUP)</h2><p>提供了在开发组织中<strong>分派任务和责任的纪律化方法</strong>。它的目标是<strong>在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品</strong>。</p><p>◆3个显著特点:<u><strong>用例驱动、以架构为中心、迭代和增量</strong></u>。</p><blockquote><p>用例:指一个具体的实际的场景。</p></blockquote><p>◆4个流程:<strong>初始阶段、细化阶段、构建阶段和交付阶段</strong>。每个阶段结束时都要安排一次技术评审，以确定这个阶段的目标是否已经达到。</p><blockquote><p>起始阶段专注于项目的初创活动。</p><p>精化阶段理解了最初的领域范围之后，进行需求分析和架构演进。构建阶段关注系统的构建，产生实现模型。</p><p>移交阶段关注于软件提交方面的工作，产生软件增量。</p><p>产生阶段运行软件并监控软件的持续使用，提供运行环境的支持，提交并评估缺陷报告和变更请求。</p></blockquote><p>◆适用:<strong>一个通用过程框架</strong>，可以用于种类广泛的软件系统、不同的应用领域、不同的组织类型、不同性能水平和不同的项目规模。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015221026149.png" alt="image-20231015221026149"></p><h1 id="软件产品线"><a href="#软件产品线" class="headerlink" title="软件产品线"></a>软件产品线</h1><p>◆软件产品线是一个产品集合，这些产品<strong>共享一个公共的、可管理的特征集，这个特征集能满足特定领域的特定需求</strong>。软件产品线是一个十分适合专业的开发组织的软件开发方法，能有效地提高软件生产率和质量，缩短开发时间，降低总开发成本。</p><p>核心资源:包括所有产品所共用的软件架构，通用的构件、文档等。</p><p>产品集合:产品线中的各种产品。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015221451366.png" alt="image-20231015221451366"></p><h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><h2 id="软件复用"><a href="#软件复用" class="headerlink" title="软件复用"></a>软件复用</h2><p>◆软件复用是<strong>将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费</strong>。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是<strong>代码级复用</strong>，被复用的知识专指程序，后来扩大到包括<strong>领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面</strong>。</p><h2 id="逆向工程-1"><a href="#逆向工程-1" class="headerlink" title="逆向工程"></a>逆向工程</h2><p>软件的逆向工程是<strong>分析程序，力图在比源代码更高抽象层次上建立程序的表示过程</strong>，逆向工程是<strong>设计的恢复过程</strong>。逆向工程的四个级别:</p><p><strong>实现级</strong>:包括程序的抽象语法树、符号表、过程的设计表示。</p><p>结构级:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构。</p><p><strong>功能级</strong>:包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型。</p><p><strong>领域级</strong>:包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如E-R模型。</p><p>其中，<strong>领域级抽象级别最高，完备性最低，实现级抽象级别最低，完备性最高。</strong></p><blockquote><p>完备性与具体实现相关，完备性越高与代码实现关系越高。</p></blockquote><p>◆与逆向工程相关的概念有重构、设计恢复、再工程和正向工程。</p><p>(1)重构是指在<strong>同一抽象级别上转换系统描述形式</strong>。</p><p>(2)设计恢复是指借助工具从<strong>已有程序中抽象出有关数据设计</strong>、总体结构设计和过程设计等方面的信息。</p><p>(3)再工程是指<strong>在逆向工程所获得信息的基础上，修改或重构已有的系统，产生系统的一个新版本</strong>。再工程是<strong>对现有系统的重新开发过程</strong>，<strong>包括逆向工程、新需求的考虑过程和正向工程三个步骤</strong>。它不仅能从已存在的程序中重新获得设计信息，而且还能使用这些信息来重构现有系统，以改进它的综合质量。在利用再工程重构现有系统的同时，一般会增加新的需求，包括增加新的功能和改善系统的性能。</p><p>(4)正向工程是指不仅从现有系统中恢复设计信息，<strong>而且使用该信息去改变或重构现有系统</strong>，以改善其整体质量。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015222541672.png" alt="image-20231015222541672"></p><blockquote><p> 软件系统工具通常可以按软件过程活动将软件工具分为软件开发工具、软件维护工具、软件管理和软件支持工具。</p><p>软件开发工具:需求分析工具、设计工具、编码与排错工具。</p><p>软件维护工具:版本控制工具、文档分析工具、开发信息库工具、<strong>逆向工程工具</strong>、再工程工具。</p><p>软件管理和软件支持工具:项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;信息系统生命周期&quot;&gt;&lt;a href=&quot;#信息系统生命周期&quot; cla</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>10.算法分析与设计</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20/</id>
    <published>2023-10-14T12:06:09.000Z</published>
    <updated>2023-11-02T08:34:20.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p>算法(Algorithm) 是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一 个或多个操作。 此外，一个算法还具有下列5个重要特性。</p><p>(1)<strong>有穷性</strong>。一个算法必须总是(对任何合法的输入值)在执行有穷步之后结束,且每一步都可在有穷时间内完成。</p><p>(2)<strong>确定性</strong>。算法中的每一条指令必须有确切的含义，理解时不会产生二义性。并且在任何条件下，算法只有唯一的一 条执行路径，即对于<u>相同的输入只能得出相同的输出</u>。</p><p>(3)<strong>可行性</strong>。一个算法是可行的，即算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p><p>(4)<strong>输入</strong>。一个算法<strong>有零个或多个输入</strong>，这些输入取自于某个特定的对象的集合。</p><p>(5)<strong>输出</strong>。一个算法有<strong>一个或多个输出</strong>，这些输出是同输入有着某些特定关系的</p><h2 id="算法的复杂度【考点】"><a href="#算法的复杂度【考点】" class="headerlink" title="算法的复杂度【考点】"></a>算法的复杂度【考点】</h2><p>◆算法的时间复杂度分析:主要是<strong>分析算法的运行时间</strong>，即算法<strong>执行所需要的基本操作数</strong>。<strong>不同规模的输入所需要的基本操作数是不相同</strong>。在算法分析中,可以<strong>建立以输入规模n为自变量的函数T(n)来表示算法的时间复杂度</strong>。</p><p>◆即使对于<strong>相同的输入规模，数据分布不相同也影响了算法执行路径的不同</strong>，因此所需要的执行时间也不同。根据不同的输入，将算法的时间复杂度分析分为3种情况:最佳情况、最坏情况、平均情况。</p><p>◆<strong>渐进符号</strong>:以输入规模n为自变量建立的时间复杂度实际上还是较复杂的，例如an^2+bn+c,不仅与输入规模有关,还与系数a、b和c有关。此时可以<strong>对该函数做进一步的抽象， 仅考虑运行时间的增长率或称为增长的量级</strong>，如忽略上式中的低阶项和高阶项的系数，仅考虑n^2。 当输入规模大到只有与运行时间的增长量级有关时，就是在研究算法的渐进效率。也就是说，从极限角度看，只关心算法运行时间如何随着输入规模的无限增长而增长。下面简单介绍3 种常用的标准方法来简化算法的渐进分析。</p><p>![image-20231030222245314](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;4.png)</p><blockquote><p>时间复杂一般看循环的次数。</p></blockquote><p>常数级：没有循环，复杂度就是O(1)</p><p>线性级：对应O(n)，和输入成正比关系。一般有一个一重循环。</p><p>对数级：含有折半和两两归并的一般是对数级。</p><p>平方级：嵌套有两个循环体。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>◆递归是指子程序(或函数)直接调用自己或通过一系列调用语句间接调用自己，是一种描述问题和解决问题的常用方法。递归有两个基本要素:边界条件即确定递归到何时终止，也称为递归出口;递归模式，即大问题是如何分解为小问题的，也称为递归体。</p><p>![image-20231030223426150](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030223426150.png)</p><p>◆阶乘函数可递归地定义为:</p><p>◆阶乘函数的自变量n的定义域是非负整数。递归式的第一式给出了 这个函数的一个初始值，是递归的边界条件。递归式的第二式是用较小自变量的函数值来表示较大自变量的函数值的方式来定义n的阶乘，是递归体。n!可以递归地计算如下:</p><p>int Factorial(int num）if(num&#x3D;&#x3D;0)return1;if(num&gt;0)return num *Factorial（num - 1）;</p><p>![image-20231030223756879](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030223756879.png)</p><p>![image-20231030224038187](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030224038187.png)</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><blockquote><p>分治法的设计思想是将一个难以直接解决的大问题分解成一些规模较少的相同问题以便各个击破，分而治之。动态规划法与分治法类似，其基本思想也是将待求解问题分解成若千个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。</p><p>贪心法经常用于解决最优化问题，但他的最优往往是从局部最优来考虑的，每一步都选最优的方案，但这种方案不一定能得到整体上的最优解。回溯法是一种既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。题目描述中提到，需要解决的问题具有最优子结构性质，且求解过程中子问题被重复求解，这种情况下如果采用分治法，效率会很低，所以应采用动态规划法。而“以深度优先的方式搜索解空间”则明显是在采用回溯法。</p></blockquote><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>◆分治法的设计思想是<strong>将一个难以直接解决的大问题分解成一些规模较小的相同问题</strong>，以便各个击破,分而治之。如果规模为n的问题可分解成k个子问题，1&lt;k&lt;&#x3D;n,这些子问题互相独立且与原问题相同。分治法产生的子问题往往是原问题的较小模式，这就为递归技术提供了方便。</p><p>◆一般来说，分治算法在每一层递归. 上都有3个步骤。</p><p>(1)<strong>分解</strong>。将原问题分解成一系列子问题。(2)<strong>求解</strong>。递归地求解各子问题。若子问题足够小则直接求解。(3)<strong>合并</strong>。将子问题的解合并成原问题的解。</p><p>◆凡是涉及到<strong>分组解决的都是分治法</strong>，例如归并排序算法完全依照上述分治算法的3个步骤进行。</p><p>(1)分解。将n个元素分成各含n&#x2F;2个元素的子序列。(2)求解。用归并排序对两个子序列递归地排序。(3)合并。合并两个已经排好序的子序列以得到排序结果。</p><p>(1)刻画0-1背包问题的最优解的结构。</p><p>可以将背包问题的求解过程看作是进行一-系列的决策过程， 即决定哪些物品应该放入背包，哪些物品不放入背包。如果-个问题的最优解包含了物品n,即xn&#x3D;1,那么其余x1, x2，… xn-1一 定构成子问题1, 2, … n-1在容量为W-wn时的最优解。如果这个最优解不包含物品n，即xn&#x3D;0,那么其余x1, x2, … xn-1一 定构成子问题1, 2, … n-1在容量为W时的最优解。</p><p>(2)递归定义最优解的值。</p><p>根据上述分析的最优解的结构递归地定义问题最优解。设c[i, w]表示背包容量为w时i个物品导致的最优解的总价值，得到下式。显然,问题要求c[n, W]。</p><p>![image-20231030230903588](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030230903588.png)</p><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>◆动态规划算法与分治法类似,其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次,以至于最后解决原问题需要耗费指数级时间。</p><p>◆然而，不同子问题的数目常常只有多项式量级。如果能够保存已解决的子问题的答案，在需要时再找出已求得的答案,这样就可以避免大量的重复计算，从而得到多项式时间的算法。为了达到这个目的，可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到，<strong>只要它被计算过，就将其结果填入表中</strong>。这就是动态规划法的基本思路。</p><p>◆动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解，每个解都对应于一个值， 我们希望找到具有最优值(最大值或最小值)的那个解。当然，最优解可能会有多个，动态规划算法能找出其中的一一个最优解。设计一个动态规划算法, 通常按照以下几个步骤进行。</p><p>(1)找出最优解的性质，并刻画其结构特征。</p><p>(2)递归地定义最优解的值。</p><p>(3)以自底向.上的方式计算出最优值.</p><p>(4)根据计算最优值时得到的信息，构造一个最优解。</p><p>◆步骤(1) ~ (3)是动态规划算法的基本步骤。在只需要求出最优值的情形下，步骤(4)可以省略。若需要求出问题的一个最优解，则必须执行步骤(4)</p><p>◆对于一个给定的问题，若其具有以下两个性质，可以考虑用动态规划法来求解。</p><p>(1)<strong>最优子结构</strong>。如果一个问题的最优解中包含 了其子问题的最优，也就是说该问题具有最优子结构。当一个问题具有最优子结构时，提示我们动态规划法可能会适用，但是此时<strong>贪心策略可能也是适用</strong>的。</p><p>(2)<strong>重叠子问题</strong>。重叠子问题指<strong>用来解原问题的递归算法可反复地解同样的子问题</strong>，而不是总在产生新的子问题。即当一个递归算法不断地调用同一一个问题时，就说该问题包含重叠子问题。</p><p>◆典型应用: 0-1背包问题</p><p>◆有n个物品，第i个物品价值为vi,重量为wi， 其中vi和wi均为非负数，背包的容量为W, W为非负数。现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大。</p><p>◆满足约束条件的任一集合(x1, x2, … xn)是问题的一个可行解，问题的目标是要求问题的一一个最优解。考虑-个实例，假设n&#x3D;5，W&#x3D;17,每个物品的价值和重量如表所示，可将物品1、2和5装入背包，背包未满,获得价值22,此时问题解为(1, 1, 0, 0, 1) ;也可以将物品4和5装入背包，背包装满，获得价值24，此时解为(0, 0, 0, 1, 1)。</p><p>![image-20231030230326890](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030230326890.png)</p><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><h2 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h2><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="数据挖掘算法"><a href="#数据挖掘算法" class="headerlink" title="数据挖掘算法"></a>数据挖掘算法</h2><h2 id="智能优化算法"><a href="#智能优化算法" class="headerlink" title="智能优化算法"></a>智能优化算法</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;算法设计&quot;&gt;&lt;a href=&quot;#算法设计&quot; class=&quot;head</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
</feed>
