<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>民工的自我修养</title>
  
  <subtitle>民工的自我修养</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-03T13:28:49.221Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>民工的自我修养</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/03/News/20231103/"/>
    <id>http://example.com/2023/11/03/News/20231103/</id>
    <published>2023-11-03T13:20:29.258Z</published>
    <updated>2023-11-03T13:28:49.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> US stocks recorded their best day in six months as bond yields <strong>tumbled</strong> after the Federal Reserve and other central banks signalled a possible end to the interest rate rise cycle that has hammered financial markets for more than a year. </p><p>Thursday’s rally for stocks and bonds — whose prices move inversely to yields — followed what investors viewed as dovish remarks by Fed chair Jay Powell on Wednesday after the US central bank held rates steady for a second consecutive meeting. </p><p>The dovish mood produced the biggest two-day fall in 10-year Treasury yields, a benchmark for global asset prices, since the US banking crisis of early March. At their lowest point of 4.63 per cent earlier on Thursday, it marked a 0.19 percentage point decline from Wednesday. </p><p>Solita Marcelli, chief investment officer for the Americas at UBS Wealth Management, said: “The meeting underlines our view that the Fed is likely done tightening and that markets had become too aggressive in pricing higher rates for longer.” The S&amp;P 500 stock index gained 1.9 per cent for its best one-day performance since March, helped by strong earnings from the likes of Starbucks, which ended the day up 9.5 per cent.</p><p> Powell emphasised the Fed was “proceeding carefully” with future rate rises, which investors took as a sign bond markets have largely succeeded in slowing down the US economy. However, he also warned the central bank “was not confident yet” that monetary policy was sufficiently restrictive to bring inflation back to its 2 per cent target. The Fed decided to keep its benchmark funds rate on hold at between 5.25 per cent and 5.5 per cent at its meeting that ended on Wednesday. On Thursday, the Bank of England also voted 6-3 to hold rates steady at 5.25 per cent while Norway’s central bank left its rates unchanged too. The scale of the investor reaction to the Fed chair’s comments underlined how anxious many are to see the end of the monetary tightening that have increased borrowing costs for households and businesses across the world. Previous Fed rate rises and a big expansion in the US government’s borrowing plans had contributed to the prolonged sell-off that last month pushed 10-year yields above 5 per cent for the first time in 16 years. If the shift lower in yields is sustained, it could have profound implications for governments’ and companies’ cost of capital after a long sell-off that has hit bondholders.  Investors have been wrongfooted in the past by prematurely calling an end to the Fed’s rate rise cycle. But Tiffany Wilding, managing director at bond investment house Pimco, argued Powell’s comments did not appear to be preparing the market for a possible rate rise in December, “and as a result you are getting some loosening in financial conditions”. The Treasury department announced on Wednesday it would slow the pace at which it issues longer-dated debt, which also pulled US government bond yields lower. Government bond markets also rallied across Europe on Thursday. Two-year UK gilt yields, which reflect interest rates expectations, fell 0.09 percentage points to 4.70 per cent, the lowest level since June. Benchmark 10-year gilt yields fell 0.15 percentage points to 4.35 per cent. Ten-year German bond yields — the benchmark for the eurozone — slipped 0.05 percentage points to 2.7 per cent after jobs data suggested the country’s economy was stagnating.</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt; US stocks recorded their best day in </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/03/%E8%BD%AF%E8%80%83/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/11/03/%E8%BD%AF%E8%80%83/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/</id>
    <published>2023-11-03T02:40:39.554Z</published>
    <updated>2023-11-03T09:17:29.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>◆用例图:主要考察参与者和用例的识别、用例之间的关系（包含include,扩展extend、泛化)。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103104203934.png" alt="image-20231103104203934"></p><p>类图:主要考察填类名、多重度、类之间的联系</p><p>◆<strong>多重度</strong>（有点类似于E-R图中的联系类型)含义如下:</p><p>1:1表示一个集合中的一个对象对应另一个集合中1个对象。</p><p>0到*:*表示一个集合中的一个对象对应另一个集合中的0个或多个对象。</p><p>1到*:表示一个集合中的一个对象对应另一个集合中的一个或多个对象。</p><p>*:表示一个集合中的一个对象对应另一个集合中的多个对象。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103104618976.png" alt="image-20231103104618976"></p><p>◆状态图主要描述<strong>状态之间的转换</strong>，主要考察的就是填状态名、填状态转换的条件，具体如图所示。</p><p>◆转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。状态图中转换和状态是两个独立的概念，如下∶图中方框代表状态，箭头上的代表<strong>触发事件</strong>，<strong>实心圆点为起点和终点</strong>。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111252555.png" alt="image-20231103111252555"></p><p>◆序列图:即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p><p>◆主要考察填对象名、消息名，消息就是一个个箭头上传递的，对象作为实体在最上端。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111405002.png" alt="image-20231103111405002"></p><p>◆通信图:是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图。</p><p>◆主要考察填对象、填消息。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111510006.png" alt="image-20231103111510006"></p><p>◆活动图:动态图，是一种特殊的状态图，展现了在系统内从一个活动到另一个活动的流程。活动的分岔和汇合线是一条水平粗线。主要考察填活动名称。</p><p><img src="/../../pic/13.%E4%B8%8B%E5%8D%88%E9%A2%98-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/image-20231103111542380.png" alt="image-20231103111542380"></p><h1 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h1><p>◆由前面的介绍可知，考察UML建模就是考察多种图形，对这些图形的考察一般都是缺失一些关键点，而后要求考生补图。</p><p>◆要求认真<strong>审题</strong>，根据题干说明补齐类名或者对象名或者消息名等等，记住类图和对象图中的多重度（互相独立的分析，掌握表示方法)、类之间的联系标识(多边形端为整体，直线端为个体)。</p><p>◆认真审题，审图，根据说明查缺补漏，一般来说有以下几种题型:</p><p>1、补充用例图:主要考察补充<strong>用例名称、参与者、用例之间的关系</strong>，只要认真审题，根据题中描述核对，都可以轻易得出答案。</p><p>2、补充类图:主要考察补充<strong>类名称</strong>，<strong>需要根据类之间的关系以及多重度来判断</strong>，需要<strong>牢记类之间关系的图形符</strong>号，尤其是组合、聚合和泛化的符号，并且观察符号上的多重度数字，与题目描述对应。</p><p>3、补充状态图:主要补充<strong>状态名称</strong>，根据题目描述可以轻易得出答案。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Q:看到一张类图都是空的，就懵了，该怎么办?A∶类和类之间的联系，尤其是泛化联系是非常重要的，也是解题的关键，要记住泛化联系的符号，而后去题目描述里找到具有父子关系的实体，基本上题目就一步步解出来了。其他如组合、聚合联系的符号也是解题关键。</p><p>Q:这种题目该怎么学习，学习到哪种程度呢?A∶:要求能拿到12分以上;看完视频对应专题课程后，立即去做历年真题，掌握技巧。</p><p>用例图主要用来描述角色以及角色与用例之间的<strong>连接关系</strong>。说明的是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了<strong>多个模型元素</strong>，如系统、参与者和用例，并且<strong>显示这些元素之间的各种关系</strong>，如<strong>泛化</strong>、<strong>关联</strong>和<strong>依赖</strong>。它展示了一个外部用户能够观察到的系统功能模型图。</p><p>【用途】：帮助开发团队以一种可视化的方式理解系统的功能需求。</p><h1 id="用例图详解"><a href="#用例图详解" class="headerlink" title="用例图详解"></a>用例图详解</h1><h2 id="用例图所包含的的元素"><a href="#用例图所包含的的元素" class="headerlink" title="用例图所包含的的元素"></a><strong>用例图所包含的的元素</strong></h2><p><strong>1.</strong> <strong>参与者(Actor)——</strong>与应用程序或系统进行交互的用户、组织或外部系统。<strong>用一个小人表示</strong>。</p><p>　　　　　　　　　　　　　　　　<img src="https://images0.cnblogs.com/blog2015/775886/201506/201151512167414.png" alt="img"></p><p><strong>2.</strong> <strong>用例(Use Case)——</strong>用例就是<u>外部可见的系统功能，对系统提供的服务进行描述</u>。<strong>用椭圆表示</strong>。</p><p>　　　　　　　　　　　　 <img src="https://images0.cnblogs.com/blog2015/775886/201506/201156222169755.png" alt="img"></p><p><strong>3. 子系统(Subsystem)——</strong>用来展示系统的一部分功能，这部分功能联系紧密。</p><p>　　　　<img src="https://images0.cnblogs.com/blog2015/775886/201506/201522249517205.png" alt="img"></p><h2 id="二、用例图所包含的的关系"><a href="#二、用例图所包含的的关系" class="headerlink" title="二、用例图所包含的的关系"></a>二、用例图所包含的的关系</h2><p>　　用例图中涉及的关系有：<strong>关联</strong>、<strong>泛化</strong>、<strong>包含</strong>、<strong>扩展</strong>。</p><p>　　如下表所示：</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201541429987815.png" alt="img"></p><p>　　<strong>a. 关联(Association)</strong></p><p>　　<strong>表示参与者与用例之间的通信，任何一方都可发送或接受消息。</strong></p><p>　　【箭头指向】：无箭头，将参与者与用例相连接，指向消息接收方</p><p>　　<img src="https://images0.cnblogs.com/blog2015/775886/201506/201545377481898.png" alt="img"></p><p>　　<strong>b. 泛化(Inheritance)</strong></p><p>　　就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。</p><p>　　【箭头指向】：指向父用例</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201746081706263.png" alt="img"></p><p>　　<strong>c. 包含(Include)</strong></p><p>　　包含关系用来<strong>把一个较复杂用例所表示的功能分解成较小的步骤</strong>。包含关系对典型的应用就是复用，也就是定义中说的情景。但是有时当某用例的事件流过于复杂时，为了简化用例的描述，我们也可以把某一段事件流抽象成为一个被包含的用例；相反，用例划分太细时，也可以抽象出一个基用例，来包含这些细颗粒的用例。这种情况类似于在过程设计语言中，将程序的某一段算法封装成一个子过程，然后再从主程序中调用这一子过程。</p><p>　　例如：业务中，总是存在着维护某某信息的功能，如果将它作为一个用例，那添加、修改以及删除都要在用例详述中描述，过于复杂；如果分成添加用例、修改用例和删除用例，则划分太细。这时包含关系可以用来理清关系。</p><p>　　【箭头指向】：指向分解出来的功能用例</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201813400459106.png" alt="img"></p><p>　　<strong>d. 扩展(Extend)</strong></p><p>　　扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中。扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。</p><p>对于一个扩展用例，可以在基用例上有几个扩展点。</p><p>　　【箭头指向】：指向基础用例</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201822539989736.png" alt="img"></p><p>　　<strong>e. 依赖(Dependency)</strong></p><p>　　以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。</p><p>　　【箭头指向】：指向被依赖项</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201825317797833.png" alt="img"></p><p>　　<strong>5. 项目(Artifact)</strong></p><p>　　用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，VS2010中引入了“项目”这样一个元素，以便让开发人员能够在用例图中链接一个普通文档。</p><p>　　用依赖关系把某个用例依赖到项目上：</p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201834316387902.png" alt="img"></p><p>　　然后把项目-&gt;属性的Hyperlink设置到你的文档上；</p><p>　　这样当你在用例图上双击项目时，就会打开相关联的文档。</p><p>　　<strong>6. 注释(Comment)</strong></p><p><img src="https://images0.cnblogs.com/blog2015/775886/201506/201837532489411.png" alt="img"></p><p>　　**包含(include)****、扩展(extend)**<strong>、泛化(Inheritance)</strong> <strong>的区别：</strong></p><p>　　条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；</p><p>　　直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。</p><p>　　对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。</p><p>　　对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</p><p>　　●泛化侧重表示子用例间的互斥性；</p><p>　　●包含侧重表示被包含用例对Actor提供服务的间接性；</p><p>　　●扩展侧重表示扩展用例的触发不定性；</p><p>　　另外一点需要提及的是：泛化中的子用例和扩展中的扩展用例均可以作为基本用例事件的备选择流而存在。</p><p><strong>三、几个用例图示例</strong></p><p><img src="https://pic001.cnblogs.com/images/2012/1/2012013015315117.gif" alt="img"></p><p>　　以下为某在线购物系统的用例图，对系统做出做了整体的描绘。</p><p>　　(1)系统整体用例图</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/11.jpg" alt="img"></p><p>(商品用例图)</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/22.jpg" alt="img"></p><p>（购买信息用例</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/test.jpg" alt="img"></p><p>**  (用户资料用例)**</p><p>  <img src="https://images.cnblogs.com/cnblogs_com/lhdyesok/Uml_Usecase/44.jpg" alt="img">**</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/02/%E8%BD%AF%E8%80%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/11/02/%E8%BD%AF%E8%80%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-02T11:52:12.594Z</published>
    <updated>2023-11-02T13:29:24.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102195806879.png" alt="image-20231102195806879"></p><p>创建型模式；对象实例化的模式，创建型模式用于解耦对象的实例化过程。 </p><p>结构型模式；把类或对象结合在一起形成一个更大的结构。 </p><p>行为型模式：类和对象如何交互，及划分责任和算法。</p><h1 id="Ep-UML类-图"><a href="#Ep-UML类-图" class="headerlink" title="Ep_UML类 图"></a>Ep_UML类 图</h1><h2 id="1-1统一建模语言-Unified-Modeling-Language-是用来设计软件的可视化建模语言。"><a href="#1-1统一建模语言-Unified-Modeling-Language-是用来设计软件的可视化建模语言。" class="headerlink" title="1.1统一建模语言 (Unified  Modeling   Language) 是用来设计软件的可视化建模语言。"></a>1.1统一建模语言 (Unified  Modeling   Language) 是用来设计软件的可视化建模语言。</h2><p>UML类图学习目标:能看懂类图中各个类之间的线条、箭头代表什么意思后，看后面章节的设计模式结构图和期末画UML图没有任何问题。</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102200133286.png" alt="image-20231102200133286"></p><p>属性&#x2F;方法名称前加的 加号和减号表示了这个属性&#x2F;方法的【可见性】</p><h2 id="1-2UML-类图中表示可见性的符号有三种："><a href="#1-2UML-类图中表示可见性的符号有三种：" class="headerlink" title="1.2UML 类图中表示可见性的符号有三种："></a>1.2UML 类图中表示可见性的符号有三种：</h2><p>+:表示public</p><p>-:表示private</p><p>#:表示protected</p><p>属性的完整表示方式是：可见性名称：类型[&#x3D;默认值]</p><p>方法的完整表示方式是：可见性名称(参数列表)[: 返回类型] </p><h2 id="1-3类与类之间关系的表示方式"><a href="#1-3类与类之间关系的表示方式" class="headerlink" title="1 .3类与类之间关系的表示方式"></a>1 .3类与类之间关系的表示方式</h2><blockquote><p>实现、继承、聚合的使用最为频繁。</p></blockquote><h3 id="1-3-1关联关系"><a href="#1-3-1关联关系" class="headerlink" title="1.3.1关联关系"></a>1.3.1关联关系</h3><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学 生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合 关系和组合关系。我们先介绍关联。</p><p>关联又可以分为单向关联，双向关联，自关联 </p><h4 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h4><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102200827741.png" alt="image-20231102200827741"></p><p>单向关联用一个带箭头的实线表示。 上图表示每 个乘车人都有一个车票。</p><h4 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h4><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102200943761.png" alt="image-20231102200943761"></p><p> 双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类 图 中 ， 双 向 关 联 用 一 个 不 带 箭 头 的 直 线 表 示 。</p><p>上图中在Customer 类中维护一个List<Product>, 表示一个顾客可以购买多个商品；</p><p>在Product 类中维护一个Customer 类型的成员变量表示这个产品被哪个顾客所购买。</p><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102201056514.png" alt="image-20231102201056514"> </p><p>用一个带有箭头且指向自身的线表示。上图的意思就是Point类包含类型为Point的成员变量</p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系是整体和部分之间的关系。例如一个部门由多个员工组成；</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102201151641.png" alt="image-20231102201151641"></p><p>与组合关系不同的是，<strong>整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；</strong></p><p>例如，部门撤销了，人员不会消失，他们依然存在；</p><p>空心菱形</p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。 <strong>一旦整体对象不存在，部分对象也将不存在</strong></p><p>例如：公司不存在了，部门也将不存在了；</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203051928.png" alt="image-20231102203051928"></p><p>实心菱形</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>它是对象之间耦合度最弱的一种关联方式，是<strong>临时性的关联</strong>.某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问被依赖类中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的<strong>虚线</strong>来表示</p><p> <img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203140021.png" alt="image-20231102203140021"></p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系， 是父类与子类之间的关系， 是一种继承关系。</p><p>用带空心三角箭头的实线来表示</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203736041.png" alt="image-20231102203736041"></p><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>在这种关系中，类实现了接口所有的抽象操作。</p><p>实现关系使用带<strong>空心三角箭头的虚线来表示</strong>，箭头从实现类指向接口</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102203812637.png" alt="image-20231102203812637"></p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps56.png" alt="img"> </p><h1 id="软-件-设-计-原-则"><a href="#软-件-设-计-原-则" class="headerlink" title="软 件 设 计 原 则"></a>软 件 设 计 原 则</h1><h2 id="2-1-开闭原则"><a href="#2-1-开闭原则" class="headerlink" title="2.1.开闭原则"></a>2.1.开闭原则</h2><p>开闭原则简单来说就是以前写过的代码你就不要动了，在我们实际的开发过程中修改代码是一件很危险 的事情，弄不好就引起一堆的问题，但是可以扩展以前的代码。这个其实就是代码要有很好的可扩展</p><p>性，咱们的需求每天都在变，要怎么做到不修改原有代码的情况下来进行扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c1ass car&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> string name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">car</span><span class="params">(string name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">()</span>&#123;</span><br><span class="line">system.out.println(<span class="string">&quot;&quot;</span>我速度最大是120KM/h<span class="string">&quot;) ;</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">public class Test99 &#123;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">public static void main(string[] args) &#123;</span></span><br><span class="line"><span class="string">car bmw = new car(&quot;</span>BMw<span class="string">&quot;&quot;</span>);</span><br><span class="line">bmw.driver();</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我 们 新 发 布 了 一 款BMW 概念车，想要修改他的最大速度为180km&#x2F;h, 该 怎 么 做 ?</p><p>我 们 不 要 直 接 修 改driver 方法，而是去做拓展，怎么做?</p><h2 id="2-2-单一职责原则"><a href="#2-2-单一职责原则" class="headerlink" title="2.2.单一职责原则"></a>2.2.单一职责原则</h2><h2 id="隔离接口原则"><a href="#隔离接口原则" class="headerlink" title="隔离接口原则"></a>隔离接口原则</h2><p>这一原则指导我们在开发的过程中一个类最好只干一方面的事情。</p><h2 id="2-4-里氏替换原则"><a href="#2-4-里氏替换原则" class="headerlink" title="2.4.里氏替换原则"></a>2.4.里氏替换原则</h2><p>在有继承关系的代码开发中，如果需要进行功能的扩展，不要在子类中改变父类中已经实现的方法， 而是通过新增方法来扩展父类的功能</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps73.png" alt="img"></p><h2 id="2-5-依赖倒置原则"><a href="#2-5-依赖倒置原则" class="headerlink" title="2.5.依赖倒置原则"></a>2.5.依赖倒置原则</h2><p>我们在定义类的成员变量、参数类型、返回值类型的时候，不要写某个具体的实现类，而尽量采用接口 或者抽象类，这样后续如果我们想改，很显然不需要改动这些代码，而只需要增加实现类就可以了。</p><h2 id="2-6-合成复用原则"><a href="#2-6-合成复用原则" class="headerlink" title="2.6.合成复用原则"></a>2.6.合成复用原则</h2><p>当父类发生改变时，其子类也会被动发生改变。</p><p>在编写代码时如果需要使用其它类，那么两个类之间尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/wps83.png" alt="img"></p><h2 id="2-7-迪米特法则"><a href="#2-7-迪米特法则" class="headerlink" title="2.7.迪米特法则"></a>2.7.迪米特法则</h2><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调 用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><h1 id="单-例-模-式"><a href="#单-例-模-式" class="headerlink" title="单 例 模 式"></a>单 例 模 式</h1><p>Singleton Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102205029002.png" alt="image-20231102205029002"></p><p>这个类<strong>提供了一种唯一访问对象的方式，可以直接访问， 不需要实例化该类的对象</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singletonPatternDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">string</span>[] args</span>) &#123;</span><br><span class="line"><span class="regexp">/ /</span>singleobject <span class="built_in">object</span> = <span class="keyword">new</span> <span class="title function_">singleobject</span>();编译时错误:构造函数 <span class="title function_">sing1eobject</span>(是不可见的</span><br><span class="line"><span class="comment">//获取唯一可用的对象</span></span><br><span class="line">singleobject <span class="built_in">object</span> = singleobject.<span class="title function_">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分为饿汉式:(太饿了,直接实例化instance)<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class sing1eton &#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span><span class="keyword"> static</span> singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>singleton(;private singleton o&#123;&#125;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> singleton getInstance( &#123;return instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">懒汉式:(比较懒,用我的时候我再实例化instance)</span><br><span class="line">线程不安全<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class sing1eton &#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span><span class="keyword"> static</span> singleton instance;private singleton o&#123;]&#125;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> synchronized singleton getInstance( &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">if </span>(instance -= nu11 &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">instance </span>=<span class="built_in"> new </span>singleton(;</span><br><span class="line">&#125;<span class="built_in"></span></span><br><span class="line"><span class="built_in">return </span>instance;</span><br><span class="line">&#125;</span><br><span class="line">线程安全<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class singleton &#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span> volatile<span class="keyword"> static</span> sing1eton singleton;private singleton (&#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span><span class="keyword"> static</span> singleton getsingleton( &#123;if (singleton == nu11) &#123;</span><br><span class="line">synchronized (singleton.c1ass) &#123;<span class="built_in"></span></span><br><span class="line"><span class="built_in">if </span>(singleton == nu17) &#123;</span><br><span class="line">singleton =<span class="built_in"> new </span>singleton(;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="built_in"></span></span><br><span class="line"><span class="built_in">return </span>singleton;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用 volatile 修饰是很有必要的，因为 singleton  &#x3D;new  Singleton()这句话可以分为三 步：</p><p>1.为 singleton 分配内存空间；</p><p>2.初始化 singleton;</p><p>3.将 singleton 指向分配的内存空间。</p><p>但是由于JVM具有指令重排的特性，执行顺序有可能变成1-3-2。指令重排在单线程下不会出 现问题，但是在多线程下会导 致一个线程获得一个未初始化的实例。例如：线程T1执行了 1和3,此时T2调用 getlnstance() 后发现 singleton 不为空，因此返回 singleton,  但是此时 的 singleton 还没有被初始化。使用 volatile 会禁止JVM 指令重排，从而保证在多线程下也能 正常执行</p><h1 id="工-厂-模-式"><a href="#工-厂-模-式" class="headerlink" title="工 厂 模 式"></a>工 厂 模 式</h1><p>Factory Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102205724885.png" alt="image-20231102205724885"> </p><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类， 工厂模式使其创建过程延迟到子类进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>创建一个接口。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">步骤 <span class="number">2</span>创建实现接口的实体类。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">( &#123;system.out.print7n(<span class="string">&quot; Rectangle: : draw( method. &quot;</span>)</span>;&#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">square</span> <span class="keyword">implements</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">system.out.println(<span class="string">&quot; square : :draw( method. &quot;</span>);</span><br><span class="line">&#125;&#125;</span><br><span class="line">                     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">circle</span> imp1ements shape &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">system.out.println(<span class="string">&quot; circ1e : : draw( method. &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//步骤3创建一个工厂，生成基于给定信息的实体类的对象。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">shapeFactory</span> &#123;</span><br><span class="line"><span class="comment">//使用getshape 方法获取形状类型的对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> shape <span class="title function_">getshape</span><span class="params">(string shapeType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shapeType == nu11) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shapeType.equalsIgnorecase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">circle</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equa1sIgnorecase(<span class="string">&quot;RECTANGLE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectang1e</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equa7sIgnorecase(<span class="string">&quot;sQUARE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">squareo</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//步骤4通过传递类型信息来获取实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">shapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">shapeFactory</span>();</span><br><span class="line"><span class="comment">//获取 circle 的对象，并调用它的draw 方法</span></span><br><span class="line">        <span class="type">shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getshape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"><span class="comment">//调用circle 的draw方法</span></span><br><span class="line">        shape1.draw() ;</span><br><span class="line"><span class="comment">//获取Rectangle 的对象，并调用它的draw方法</span></span><br><span class="line">        <span class="type">shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getshape(<span class="string">&quot;RECTANGLE&quot;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">//调用Rectangle 的draw方法</span></span><br><span class="line"><span class="string">        shape2.draw();</span></span><br><span class="line"><span class="string">//获取Square 的对象，并调用它的draw 方法</span></span><br><span class="line"><span class="string">        shape shape3 = shapeFactory.getshape(&quot;</span>sQUARE<span class="string">&quot;);</span></span><br><span class="line"><span class="string">//调用Square 的draw方法</span></span><br><span class="line"><span class="string">        shape3.draw();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="抽-象-工-厂-模-式"><a href="#抽-象-工-厂-模-式" class="headerlink" title="抽 象 工 厂 模 式"></a>抽 象 工 厂 模 式</h1><p>Abstract Factory Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102211020547.png" alt="image-20231102211020547"> </p><p>提供一个创建一系列产品族的接口，而无需指定它们具体的类。</p><p>那什么是产品族? 看下图，不同的产品等级结构的一组产品组成产品族</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102211107521.png" alt="image-20231102211107521"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂，生产手机和平板两种东西：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">newPhone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Pad <span class="title function_">newPad</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：苹果工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">newphone</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;新牛出生!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Applephone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Pad <span class="title function_">newPad</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;蔬菜长成!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplePad</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：华为工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">newPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;新马出生!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Huaweiphone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Pad <span class="title function_">newPad</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.print1n(<span class="string">&quot;水果长成!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPad</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品：手机</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：平板</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Pad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：苹果手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplePhone</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是苹果Phone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：苹果Pad</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Applepad</span> <span class="keyword">implements</span> <span class="title class_">Pad</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是ApplePad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：华为手机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huaweiphone</span> <span class="keyword">implements</span> <span class="title class_">phone</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是HuaweiPhone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品：华为Pad</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huaweipad</span> <span class="keyword">implements</span> <span class="title class_">Pad</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;我是华为Pad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryPatternDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="type">Pad</span> <span class="variable">pad</span> <span class="operator">=</span> apple.newPad();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> apple.newphone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建-造-者-模-式"><a href="#建-造-者-模-式" class="headerlink" title="建 造 者 模 式"></a>建 造 者 模 式</h2><p>Builder  Pattern</p><p><img src="/../../pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231102212451001.png" alt="image-20231102212451001"></p><p>将一个复杂的构建与其实现相分离，使得同样的构建过程可以创建不同的表示。</p><p>这个抽象建造方法就是一张建造的图纸，后面实现这个接口的类是具体的建造图纸，把具体的建造图纸用set注入的方式给指挥者类干活，最后根据具体图纸完成产品!</p><p>应用实例：1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出 所谓的“套餐”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">举例：一个产品由A B两种构件组成，</span><br><span class="line">产品1A ,B两个构件是金子做的，(不是瓜皮子A_^)</span><br><span class="line">产品2A ,B两个构件是碳纤维做的</span><br><span class="line">两种价格不一样</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builder</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">builder.BuildPartA();</span><br><span class="line">builder.BuildPartB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BuildPartA</span><span class="params">()</span>; <span class="comment">//产品的A部件</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BuildPartB</span><span class="params">()</span>; <span class="comment">//产品的B部件</span></span><br><span class="line">Product <span class="title function_">getResult</span><span class="params">()</span>; <span class="comment">//获取产品建造后结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteBuilder1</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"><span class="comment">//设置产品零件</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartA</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartA(<span class="string">&quot;碳纤维做的A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartB</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartB(<span class="string">&quot;碳纤维做的B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组建一个产品</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder2</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"><span class="comment">//设置产品零件</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartA</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartA(<span class="string">&quot;金子做的A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BuildPartB</span><span class="params">()</span>&#123;</span><br><span class="line">product.setPartB(<span class="string">&quot;金子做的B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组建一个产品</span></span><br><span class="line">Qoverride</span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String partA;</span><br><span class="line"><span class="keyword">private</span> String partB;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.partA = partA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setpartB</span><span class="params">(String partB)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.partB = partB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">system.out.print1n(<span class="string">&quot;我的组成部件-parta:&quot;</span>+partA+<span class="string">&quot;- partB:&quot;</span>+ partB);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder1</span>();</span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder2</span>();</span><br><span class="line"><span class="comment">//指挥者用ConcreteBuilder1的方法来建造产品</span></span><br><span class="line">director.builder(builder1);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> builder1.getResult();</span><br><span class="line">product1.show()</span><br><span class="line"><span class="comment">//指挥者用ConcreteBuilder2的方法来建造产品</span></span><br><span class="line">director.builder(builder2);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product2</span> <span class="operator">=</span> builder2.getResult();</span><br><span class="line">product2.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="适-配-器-模-式"><a href="#适-配-器-模-式" class="headerlink" title="适 配 器 模 式"></a>适 配 器 模 式</h1><p>Adapter   Pattern</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;img src=&quot;/../../pic/%E8%AE%BE%E8%AE%A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/11/01/%E8%BD%AF%E8%80%83/Java%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/11/01/%E8%BD%AF%E8%80%83/Java%E8%AF%AD%E6%B3%95/</id>
    <published>2023-11-01T12:17:08.634Z</published>
    <updated>2023-11-02T12:34:24.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="设计对象并使用"><a href="#设计对象并使用" class="headerlink" title="设计对象并使用"></a>设计对象并使用</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>●类(设计图) :是对象共同特征的描述;</p><p>●对象:是真实存在的具体东西。<strong>在Java中，必须先设计类，才能获得对象。</strong></p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101202446788.png" alt="image-20231101202446788"></p><p>总结：</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101202647693.png" alt="image-20231101202647693"></p><p>●类名首字母建议大写， 需要见名知意，驼峰模式。</p><p>●一个Java文件中可以定义多个class类, 且只能一 个类是public修饰，而且public修饰的类名必须成为代码文件名。实际开发中建议还是一个文件定义一个class类。</p><p>●<strong>成员变量的完整定义格式是 :修饰符-数据类型-变量名称&#x3D;初始化值;一般无需指定初始化值,存在默认值。</strong></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><a href="https://www.bilibili.com/video/BV1dR4y1o7ER?t=135.3&p=3">https://www.bilibili.com/video/BV1dR4y1o7ER?t=135.3&amp;p=3</a></p><blockquote><p> 封装、继承、多态是面向对象的三大特征。</p></blockquote><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</strong></p><p>比如人画圆，对象应该是圆，而不是人。</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101203539964.png" alt="image-20231101203539964"></p><h2 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h2><p>●是一个权限修饰符</p><p>●可以修饰成员 (成员变量和成员方法)</p><p>●被private修 饰的成员只能在本类中才能访问</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101205642618.png" alt="image-20231101205642618"></p><p>在设置age为私有成员后，直接调用age的值是不可行的。</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101205656548.png" alt="image-20231101205656548"></p><p>正确的案例如下：</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101205925575.png" alt="image-20231101205925575"></p><blockquote><p>私有变量只能在其被声明的类内部直接通过“点”（<code>.</code>）运算符进行访问。私有变量的可见性仅限于声明它们的类，并且对于其他类或外部代码是不可见的。</p><p>这是封装的一种体现，通过将变量声明为私有，可以隔离和保护类的内部实现细节。这样可以确保类的数据的安全性和一致性，并提供更好的控制和管理数据的方式。</p><p>如果需要在其他类中访问私有变量，可以通过在类中提供公共的访问方法（如“getter”方法）来间接地获取私有变量的值。通过公共访问方法，<strong>可以控制对变量的访问</strong>，并提供对私有变量的安全访问。</p><p>需要注意的是，私有变量只能在声明它们的类中直接访问，而不是“定义模块”，因为定义模块可能包含多个类。</p></blockquote><h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    </span><br><span class="line">name=name;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该段代码不能正确地给name赋值。</p><p><strong>就近原则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据就近原则，System.out.println(age);输出的age是方法中的age。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> age=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">System.out.println(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System.out.println(age);输出的age是成员变量age。</p><p><strong>this.age</strong>指的就是成员变量age。<strong>this的作用就是区分局部变量和成员变量</strong>。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法也叫作构造器、构造函数。</p><p>作用:<strong>在创建对象的时候给成员变量进行初始化的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    </span><br><span class="line">修饰符   类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点:</p><p>1.方法名与类名相同，大小写也要一致</p><p>2.没有返回值类型，连void都没有</p><p>3.没有具体的返回值(不能由retrun带回结果数据)</p><p><img src="/../../pic/1.%E5%85%A5%E9%97%A8/image-20231101212838813.png" alt="image-20231101212838813"></p><p>如果没有写任何构造方法，虚拟机将会自动加入一个空参构造方法。</p><p>没创建一个对象，都会调用一次构造函数。</p><p><strong>构造方法注意事项</strong></p><p>如果没有定义构造方法， 系统将给出一个默认的无参数构造方法；如果定义了构造方法，系统将不再提供默认的构造方法。</p><p>带参构造方法, 和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载。</p><p>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法。</p><h1 id="标准-JavaBean"><a href="#标准-JavaBean" class="headerlink" title="标准 JavaBean"></a>标准 JavaBean</h1><h2 id="标准的JavaBean类"><a href="#标准的JavaBean类" class="headerlink" title="标准的JavaBean类"></a>标准的JavaBean类</h2><p>①类名需要见名知意。</p><p>②成员变量使用private修饰。</p><p>③提供至少两个构造方法。</p><p>●无参构造方法</p><p>●带全部参 数的构造方法</p><p>④成员方法。</p><p>●<strong>提供每一个成员 变量对应的setXxx()&#x2F; getXxx()</strong></p><p>●如果还有其他行为， 也需要写上。</p><h1 id="封装、继承、多态、抽象与接口"><a href="#封装、继承、多态、抽象与接口" class="headerlink" title="封装、继承、多态、抽象与接口"></a>封装、继承、多态、抽象与接口</h1><h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h2><p>封装意味着将数据的细节隐藏起来，仅公开有限的接口接口给用户。我们通过两种方式实现，第一种就是将类中的数据变为private，另一种便是提供get和set方法给外界，限制用户操作类数据的方式。</p><p>比如我们有一个Game类，其中有一个score数据：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Game</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义有很大的缺点：<strong>外界可以直接操作score数值</strong>，可以将其设置为无限大或无限小，甚至胡乱操作。我们就可以将其数据变为private，并创建get和set给外界来操作此数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Score Error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过创建getScore和setScore来限制用户操作score的方式，在setScore中，我们会检查数据的值是否符合我们的设定，如果违规（小于0或大于100），那么此操作就无法完成。<strong>通过封装，我们限制用户使用类的方式，只提供外界一个黑匣子，以保证数据的安全</strong>。</p><h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h2><p>在面对对象编程中，在我们已经创建了一个类后，而又想<strong>再创建一个与之相似的类，比如添加新的方法，或者修改原来的方法</strong>。我们不必从头开始，可以从原来的类派生出新的类，我们把原来的类称为父类或基类，而派生出来的类称为子类，<strong>子类则会继承父类的数据和方法</strong>。</p><p>让我们看一个简单的例子，首先我们定义一个Animal类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想创建一个 Dog 类，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;WangWang..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Dog类和Animal类几乎是一样的，只是 greet 方法略有不同，我们完全没必要创建一个新的类，可以直接创建子类（child class）来继承父类Animal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//调用父类的构造方法Animal（name）；-&gt;Animal.name=name;=&gt;Dog.name=name;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WangWang..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog类是从 Animal 类继承而来的，Dog类自动获得了 Animal 类的数据和方法，这些数据和方法必须是子类能够访问到的范围，被public和protected修饰的数据和方法就能被子类访问到。<strong>在Dog的构建函数中，我们调用了super(name)，这就意味着Dog调用了Animal的Animal(String name)函数，将自己的name数据初始化为参数name的数值。</strong></p><p>子类还可以对父类继承来的方法进行修改，Dog就对父类中的greet进行了重写（Override），并且还新增了一个方法 run。我们调用父类和子类对比一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">        animal.greet(); <span class="comment">// Hello, I am animal</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.greet(); <span class="comment">// WangWang..., I am dog</span></span><br><span class="line">        dog.run(); <span class="comment">// I am running!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h2><p><a href="https://www.bilibili.com/video/BV147411W7Af?t=824.9">https://www.bilibili.com/video/BV147411W7Af?t=824.9</a></p><p>多态的概念其实不难理解，它是指针对不同类型的参数进行相同的操作，<strong>根据对象（或类）类型的不同而表现出不同的行为</strong>。比如在我们刚学的继承中，子类可以拿到父类的数据和方法，也可以重写父类的方法，还可以新增自己特定的方法。有了继承，就能实现多态，便可以为不同的数据类型的实现提供统一的接口。比如我们再创建一个Animal的子类Cat：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;MiaoMiao..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们创建两个都是Animal类型的变量cat和dog，并将它们具体实例化成Cat和Dog类，那么当我们调用cat和dog的 greet 方法，它们则会自动调用实际类型的 greet 方法，做出不同的响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        cat.greet(); <span class="comment">// MiaoMiao..., I am cat</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.greet(); <span class="comment">// WangWang..., I am dog</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h2><p>数据抽象的意思是<strong>隐藏细节</strong>，只暴露最重要的信息给用户。<strong>抽象可以通过 abstract class 或 interface（接口）实现</strong>。abstract 关键字是一个用于类和方法的修饰符，我们<strong>无法创建 abstract class 类型的实例</strong>，这种抽象类只能被继承。而abstract method只能定义在abstract class中，这种方法没有具体执行内容。一个抽象类既可以有抽象方法也可以有正常的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zzz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们创建了一个抽象类Person，如果我们运行以下的代码则会报错，因为我们无法给抽象类创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p><strong>要使用抽象类，我们必须创建一个类继承它</strong>，比如我们创建一个Teenager继承Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teenager</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am a teenager.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，<strong>如果一个类继承了抽象类，那么此类必须要实现抽象类中定义的抽象方法，不然会报错</strong>，所以Teenager就必须要实现greet方法，下面是Teenager的调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Teenager</span> <span class="variable">teenager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teenager</span>();  </span><br><span class="line">        teenager.greet(); <span class="comment">// I am a teenager.</span></span><br><span class="line">        teenager.sleep(); <span class="comment">// Zzz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h2><p>另一个实现数据抽象的方式就是使用接口（interface）。<strong>一个接口就是完全的抽象类，其中只含有抽象方法，这些方法中是没有任何逻辑代码的</strong>。<u>类的主要作用便是定义一些特定的方法</u>，具体逻辑让正常的类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果要使用接口的方法，那么具体的类必须实现（implements）其接口</strong>。只要被实现，具体的类必须将接口方法的具体逻辑全部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to school.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m taking an exam.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口，我们可以再定义一个Employee类，并将其加到Person implements后，不同接口之间用逗号隔开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Employee</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSalary</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Student</span>, Employee &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to school&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m taking an exam&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to work.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I just got the salary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能从Person类中调用接口中全部的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">        person.goToSchool();</span><br><span class="line">        person.takeExam();</span><br><span class="line">        person.goToWork();</span><br><span class="line">        person.getSalary(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把接口理解为一个特定的属性，而这个属性有相对应的一些方法，通过实现（implements）接口，具体的类必须实现其属性相对应的特定方法，帮助实现数据的抽象化。我们要注意继承和接口所代表的逻辑关系，继承之间的关系是 is-a，也就意味着子类是父类的一个子集。实现接口的类和接口之间的关系是 has-a，意味着具体类拥有接口的一些功能。</p><h2 id="实践练习"><a href="#实践练习" class="headerlink" title="实践练习"></a>实践练习</h2><p>请创建一个Game类，其中包含score数据，请使用封装的概念来设计此类，并在其中创建一个displayInfo方法。然后再创建两个子类VideoGame，PhoneGame继承Game类，并分别重写displayInfo方法，然后调用这两个类的实例来查看区别。（display的逻辑可以很简单，打印出游戏的类型和分数即可）</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;设计对象并使用&quot;&gt;&lt;a href=&quot;#设计对象并使用&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/25/%E8%BD%AF%E8%80%83/New%20Text%20Document/"/>
    <id>http://example.com/2023/10/25/%E8%BD%AF%E8%80%83/New%20Text%20Document/</id>
    <published>2023-10-25T13:27:31.196Z</published>
    <updated>2023-10-26T00:37:54.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="E-R图转换为关系模式"><a href="#E-R图转换为关系模式" class="headerlink" title="E-R图转换为关系模式"></a>E-R图转换为关系模式</h2><p>E-R图中，有实体和联系两个概念，实体和实体之间的联系分为三种，即1:1,1:N,M:N，这三种情况，转换为关系模式的方法也不同。</p><p>◆首先，<strong>每个实体都要转换为一个关系模式</strong>，对于联系:</p><ul><li><p>一对一，<strong>联系作为一个属性随便加入哪个实体中</strong>;</p></li><li><p>一对多，联系可以单独转换为一个关系模式，也可以<strong>作为一个属性加入到N端中（N端实体包含1端的主键)</strong>;</p></li><li><p>多对多，联系<strong>必须单独转换为一个关系模式</strong>(<strong>且此关系模式应该包含两端实体的主键</strong>)。</p></li></ul><p>转换之后要注意:<strong>原来的两个实体之间的联系必须还存在</strong>，能够通过查询方式查到对方。</p><h2 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h2><p>◆数据库设计的考法也非常固定，<strong>第一小题补充E-R图，第二小题补充关系模式，第三小题是简单的情景问答题</strong>。同样也都不难，结合题目描述和E-R图的一些特点可以轻易得出答案，技巧如下:</p><p>1、补充E-R图:这是<strong>重中之重</strong>，E-R图如果弄错了，后续题目都有影响，主要是<strong>根据题目描述确认哪些实体之间有联系，联系类型是哪一种</strong>，而后进行连线即可，并不难。</p><p>2、补充关系模式:实际考察的是<strong>将E-R图转换为关系模式，补充缺失的属性</strong>，分成<strong>两步</strong>︰首先需要<strong>审题</strong>，题目会给出每个关系模式的属性信息，<strong>先将题目中的属性信息和问题对应，将缺少的属性全部补充</strong>;而后再<strong>按照规则转换</strong>，即前面所说的规则，按联系的三种对应方式决定要添加哪些字段。</p><blockquote><p>重点检查多对多和一对多的关系。</p></blockquote><p>3、情景问答:一般都是给出一段新的描述，要求新增一种实体-联系类型和关系模式，本质也是考察联系类型和E-R图转换为关系模式。</p><p>◆注意审题，常识以及E-R图转换为关系模式的原则(主要是联系的归属)。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Q: E-R图转换为关系模式时，总觉得不对怎么办?</p><p>A:学员在这种类型题目里唯一的模糊点就是这里，转换为关系模式，遵循两步法，首先以题目描述为主，然后再根据不同类型的转换原则去判断是否有遗漏。</p><p>Q:这种题目该怎么学习，学习到哪种程度呢?</p><p>A:要求能拿到12分以上;看完视频对应专题课程后，立即去做历年真题，掌握技巧。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>12.文老师-软件工程基础知识[系统设计]</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86[%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1]/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86[%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1]/</id>
    <published>2023-10-14T12:06:16.000Z</published>
    <updated>2023-10-28T02:55:25.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="处理流程设计"><a href="#处理流程设计" class="headerlink" title="处理流程设计"></a>处理流程设计</h1><h2 id="业务流程建模【不考】"><a href="#业务流程建模【不考】" class="headerlink" title="业务流程建模【不考】"></a>业务流程建模【不考】</h2><p>标杆瞄准:以行业领先的标杆企业为目标，结合本企业情况分析建模。</p><p>IDEF (一系列建模、分析和仿真方法的统称)。</p><blockquote><p>继承的建模方法。</p></blockquote><p>DEMO (组织动态本质建模法)</p><p>Petri网</p><p>业务流程建模语言: BPEL、 BPML、 BPMN、 XPDL。</p><p>基于服务的BPM:基于Web服务的思想对业务流程进行建模。</p><h2 id="处理流程设计（IDEF-）"><a href="#处理流程设计（IDEF-）" class="headerlink" title="处理流程设计（IDEF ）"></a>处理流程设计（IDEF ）</h2><p><strong>IDEFO: 业务流程(功能)建模;</strong></p><p>IDEF1:信息建模;</p><p><strong>IDEF1X: 数据建模(如ER模型) ;</strong></p><p><strong>IDEF2:仿真建模设计;</strong></p><p>IDEF3:过程描述获取;</p><p><strong>IDEF4:面向对象设计;</strong></p><p>IDEFS:本体论描述获取;</p><p>IDEF6:设计原理获取;</p><p>IDEF7:信息系统审计;</p><p><strong>IDEF8:用户界面建模;</strong></p><p>IDEF9:场景驱动信息系统设计;</p><p>IDEF10:实施架构建模;</p><p>IDEF11:信息制品建模;</p><p><strong>IDEF12:组织结构建模;</strong></p><p>IDEF13:三模式映射设计;</p><p>IDEF14:网络规划。</p><h2 id="流程表示工具【考点】"><a href="#流程表示工具【考点】" class="headerlink" title="流程表示工具【考点】"></a>流程表示工具【考点】</h2><p><strong>程序流程图(Program Flow Diagram,PFD)<strong>用一些图框表示各种操作，<u>它独立于任何一种程序设计语言</u>，比较直观、清晰，易于学习掌握。任何复杂的程序流程图都应该由</strong>顺序、选择和循环结构</strong>组合或嵌套而成。</p><p><strong>IPO图</strong>也是流程描述工具，用来描述构成软件系统的每个模块的<strong>输入、输出和数据加工</strong>。</p><blockquote><p>I:input,P:process,O:output</p></blockquote><p><strong>N-S图</strong>【又称“盒图”】容易表示<strong>嵌套和层次关系</strong>，并具有强烈的结构化特征。但是当问题很复杂时，N-S图可能很大，因此<strong>不适合于复杂程序的设计</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016225749101.png" alt="image-20231016225749101"></p><p><strong>问题分析图(PAD)</strong> 是一种支持<strong>结构化程序设计</strong>的图形工具。PAD具有清晰的逻辑结构、标准化的图形等优点，更重要的是，它<u>引导设计人员使用结构化程序设计方法，从而提高程序的质量</u>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016225753853.png" alt="image-20231016225753853"></p><blockquote><p>四种方法本质一样，知识表示方法不一样。</p></blockquote><p><strong>活动图</strong>【考点】</p><p>如下所示的软件项目<a href="https://so.csdn.net/so/search?q=%E6%B4%BB%E5%8A%A8%E5%9B%BE&spm=1001.2101.3001.7020">活动图</a>中，顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的权重表示活动的持续时间()天， 则完成该项目的最短时间为 （）天。在该活动图中，共有（）条关键路径。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231028091145730.png" alt="image-20231028091145730"></p><p>解析:</p><p>关键路径ABFJL、ADGIJL</p><p>关键路径是项目计划中最长的一套路径，通俗点说因为关键路径最长，所以只有保证它做完了，才能保证项目做完了，所以说它最“关键”。</p><p>算“最早时间”时，从左到右算，两数取大</p><p>最晚时间：关键路径的长度-从终点到该点最短的距离</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231028091243026.png" alt="image-20231028091243026"></p><p>求“关键路径”：</p><p>根据，最早时间&#x3D;最晚时间，的全部点去找关键路径</p><p>关键路径必然经过这些点</p><p>所以，ABFJL&#x3D;ADGIJL&#x3D;22</p><p><strong>松弛</strong>&#x3D;最晚开始时间-最早开始时间。</p><p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间(天），则完成该项目的最少时间为（)天。活动BD最多可以晚开始（)天而不会影响整个项目的进度。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231028090549586.png" alt="image-20231028090549586"></p><blockquote><p> <strong>活动图是描述一个项目中各个工作任务相互依赖关系的一种模型</strong>，项目的很多重要特性可以通过分析活动图得到，如估算项目完成时间，计算关键路径和关键活动等。</p></blockquote><p>根据上图计算出关键路径为A-B-D-G-I-K-L，其长度为22，关键路径上的活动均为关键活动。活动BD在关键路径上，因此松弛时间为0。</p><h2 id="业务流程重组BPR"><a href="#业务流程重组BPR" class="headerlink" title="业务流程重组BPR"></a>业务流程重组BPR</h2><p>BPR是对企业的业务流程进行<strong>根本性的再思考和彻底性的再设计</strong>，从而获得可以用诸如成本、质量、服务和速度等方面的业绩来衡量的显著性的成就。<strong>BPR设计原则、系统规划和步骤如下图所示</strong>:</p><blockquote><p>原有的流程彻底推倒，重新设计业务流程。</p></blockquote><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016230332985.png" alt="image-20231016230332985"></p><blockquote><p>记忆基本原则。</p></blockquote><h2 id="业务流程管理BPM"><a href="#业务流程管理BPM" class="headerlink" title="业务流程管理BPM"></a>业务流程管理BPM</h2><blockquote><p>是对现有业务流程的优化。</p></blockquote><p>BPM是一种以<strong>规范化的构造端到端的卓越业务流程为中心</strong>，以持续的<strong>提高组织业务绩效为目的</strong>的系统化方法。</p><p>BPM与BPR管理思想最根本的不同就在于<strong>流程管理并不要求对所有的流程进行再造</strong>。构造卓越的业务流程并不是流程再造，而是<strong>根据现有流程的具体情况，对流程进行规范化的设计。</strong></p><p>流程管理包含三个层面:<strong>规范流程、优化流程和再造流程</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231016230719234.png" alt="image-20231016230719234"></p><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>◆系统设计主要目的:为系统制定蓝图，在各种技术和实施方法中权衡利弊,精心设计，合理地使用各种资源，<strong>最终勾画出新系统的详细设计方法</strong>。</p><p>◆系统设计方法:<strong>结构化设计方法，面向对象设计方法</strong>。</p><p>◆系统设计的主要内容:<strong>概要设计、详细设计</strong>。</p><blockquote><p>首先做概要设计，然后做详细设计。</p></blockquote><p>◆概要设计基本任务:又称为<strong>系统总体结构设计</strong>，是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，<strong>形成软件的模块结构图，即系统结构图</strong>。<strong>产出概要设计说明书</strong>。</p><p>◆详细设计的基本任务:**模块内详细算法设计、模块内数据结构设计、数据库的物理设计、其他设计(代码、输入&#x2F;输出格式、用户界面)**、编写详细设计说明书、评审。</p><h2 id="系统设计基本原理"><a href="#系统设计基本原理" class="headerlink" title="系统设计基本原理"></a>系统设计基本原理</h2><p>抽象化：不需要和具体实践结合得过于紧密。</p><p>自顶而下，逐步求精：先概要设计，后详细设计。</p><blockquote><p>实现的时候，自底向上。</p></blockquote><p>信息隐蔽：把模块封装起来，避免信息泄露。</p><p>模块独立(<strong>高内聚，低耦合</strong>)：要求模块内联系紧密，模块间联系尽量少。</p><p>若模块A和模块B通过外部变量来交换输入、输出信息，则这两个模块的耦合类型是( )耦合。</p><p>A数据B标记C控制D公共</p><blockquote><p>公共耦合是指<strong>多个模块都访问同一个公共数据环境</strong>，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。模块A和模块B<strong>通过公共数据环境中的外部变量来交换输入、输出信息，显然属于公共耦合</strong>。</p></blockquote><h2 id="系统设计原则"><a href="#系统设计原则" class="headerlink" title="系统设计原则"></a>系统设计原则</h2><p>保持模块的大小适中;</p><p>尽可能减少调用的深度：调用的深度越深，效率会降低。</p><p><strong>多扇入，少扇出</strong>：扇入指其他模块调用本模块，扇出指本模块调用其他模块。扇入多意味着价值大，复用多。扇出多意味着耦合度高。</p><p>单入口，单出口;</p><p>模块的作用域应该在模块之内;</p><p>功能应该是可预测的。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017101044147.png" alt="image-20231017101044147"></p><h1 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h1><h2 id="人机界面设计三大黄金原则"><a href="#人机界面设计三大黄金原则" class="headerlink" title="人机界面设计三大黄金原则"></a>人机界面设计三大黄金原则</h2><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017101151428.png" alt="image-20231017101151428"></p><blockquote><p>掌握三大原则即可，细节不用看。</p></blockquote><h1 id="测试原则和方法【考点】"><a href="#测试原则和方法【考点】" class="headerlink" title="测试原则和方法【考点】"></a>测试原则和方法【考点】</h1><p>◆系统测试是<strong>为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试</strong>。</p><blockquote><p>测试是找出错误，调试是找出问题发生的原因。</p></blockquote><h2 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h2><p>◆应尽早并不断的进行测试：如V模型。</p><p>◆测试工作应该避免由原开发软件的人或小组承担;</p><p>◆在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期的输出结果;</p><p>◆既包含有效、合理的测试用例，也包含<strong>不合理、失效的用例</strong>;</p><p>◆检验程序是否做了该做的事，且<strong>是否做了不该做的事</strong>;</p><p>◆严格按照测试计划进行;</p><p>◆妥善保存测试计划和测试用例;</p><p>◆测试用例可以重复使用或追加测试。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>◆软件测试方法可分为静态测试和动态测试。</p><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>◆静态测试:指被测试程序<strong>不在机器上运行</strong>，而采用<strong>人工检测和计算机辅助静态分析</strong>的手段对程序进行检测，包括对文档的静态测试和对代码的静态测试。</p><p>对文档的静态测试主要以<strong>检查单</strong>的形式进行，而对代码的静态测试，包括<strong>桌前检查、代码审查、代码走查</strong>的方式。使用这种方法能够有效地发现30%- 70%的逻辑设计和编码错误。</p><blockquote><p>桌前检查:根据文档要求对代码逻辑进行审查</p><p>代码审查：开会讨论。</p><p>代码走查：程序员担当计算机的角色，模拟计算机运行代码。</p></blockquote><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>◆动态测试:指在计算机上<strong>实际运行程序</strong>进行软件测试，一般采用白盒测试和黑盒测试方法。</p><p>黑盒测试法:<strong>功能性测试</strong>，不了解软件代码结构，根据功能设计用例，测试软件功能。</p><blockquote><p>假定不了解软件代码结构，只进行一些功能性测试。</p></blockquote><p>白盒测试法:<strong>结构性测试</strong>，明确代码流程，根据代码逻辑设计用例，进行用例覆盖。</p><blockquote><p>根据软件代码流程设计测试用例。</p></blockquote><p>灰盒测试：黑白两种的结合。</p><h1 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h1><p>(1)单元测试:也称为模块测试，测试的对象是<strong>可独立编译或汇编的程序模块</strong>、软件构件或OO软件中的类(统称为模块)，测试依据是<strong>软件详细设计说明书</strong>。</p><p>某财务系统的一个组件中，某个变量没有正确初始化，()最可能发现该错误</p><p>A单元测试B集成测试C接受测试D安装测试</p><blockquote><p>单元测试主要检查模块的以下5个特征∶(1)模块接口。</p><p>(2）局部数据结构。</p><p>(3）重要的执行路径。</p><p>( 4）出错处理。</p><p>(5)边界条件。</p><p>是否使用了尚未赋值或尚未初始化的变量属于检查局部数据结构的内容。</p></blockquote><p>(2)集成测试:目的是<strong>检查模块之间，以及模块和已集成的软件之间的接口关系</strong>，并验证已集成的软件是否符合设计要求。测试依据是<strong>软件概要设计文档</strong>。</p><p>(3)系统测试:<strong>测试对象是完整的、集成的计算机系统</strong>;测试的目的是在真实系统工作环境下，验证完成的软件配置项能否和系统正确连接，并满足系统&#x2F;子系统设计文档和软件开发合同规定的要求。测试依据是<strong>用户需求或开发合同</strong>。主要内容包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试、安装与反安装测试等，其中，最重要的工作是进行功能测试与性能测试。功能测试主要采用黑盒测试方法;性能测试主要指标有响应时间、吞吐量、并发用户数和资源利用率等。</p><p>(4)确认测试:主要用<strong>于验证软件的功能、性能和其他特性是否与用户需求一致</strong>。根据用户的参与程度，通常包括以下类型:</p><p>内部【就是软件开发方】确认测试:主要由<strong>软件开发组织内部按照SRS进行测试</strong>。</p><p>Alpha测试:<strong>用户在开发环境下进行测试</strong>。</p><p>Beta测试:<strong>用户在实际使用环境下进行测试</strong>，通过改测试后，产品才能交付用户。</p><p>验收测试【走的一个流程】:<strong>针对SRS， 在交付前以用户为主进行的测试</strong>。其测试对象为完整的、集成的计算机系统。验收测试的目的是，在真实的用户工作环境下，检验软件系统是否满足开发技术合同或SRS。验收测试的结论是用户确定是否接收该软件的主要依据。除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。</p><p>(5)配置项测试:测试对象是<strong>软件配置项</strong>，测试目的是<strong>检验软件配置项与SRS的一致性</strong>。测试的依据是SRS。在此之间，应确认被测软件配置项已通过单元测试和集成测试。</p><p>(6)<strong>回归测试</strong>【考点】:测试目的是测试<strong>软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性</strong>。</p><h2 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h2><p>◆自底向上:<strong>从最底层模块开始测试，需要编写驱动程序</strong>,而后开始逐-合并模块，最终完成整个系统的测试。优点是较早的验证了底层模块。</p><p>◆自顶向下:<strong>先测试整个系统，需要编写桩程序,而后逐步向下直至最后测试最底层模块</strong>。优点是较<strong>早的验证了系统的主要控制和判断点</strong>。</p><p>◆三明治:既有自底向上也有自顶向下的测试方法，<strong>二者都包括</strong>。<strong>兼有二者的优点，缺点是测试工作量大</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017123402441.png" alt="image-20231017123402441"></p><h1 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h1><h2 id="黑盒测试用例"><a href="#黑盒测试用例" class="headerlink" title="黑盒测试用例"></a>黑盒测试用例</h2><p><strong>黑盒测试用例</strong>:将程序看做一个 黑盒子，只知道输入输出，不知道内部代码，由此设计出测试用例，分为下面几类:</p><p>◆<strong>等价类划分</strong>:把所有的数据按照某种特性进行归类，而后在每类的数据里选取一个即可。</p><blockquote><p>用一个用例代替一个类，节省测试用例。</p></blockquote><p>等价类测试用例的设计原则:设<strong>计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类</strong>，重复这一步，直到所有的有效等价类都被覆盖为止;<strong>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类</strong>，重复这一步，直到所有的无效等价类都被覆盖为止。</p><blockquote><p>如果覆盖了两个无效等价类，那么就不容易判别出是出现了那个错误。</p></blockquote><p>◆<strong>边界值划分</strong>:将每类的边界值作为测试用例，<strong>边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值</strong>，如年龄范围为0-150，边界值为0, 150， -1, 151四个。</p><p>◆错误推测:没有固定的方法，凭经验而言，来推测有可能产生问题的地方，作为测试用例进行测试。</p><p>◆因果图:由一个结果来反推原因的方法，具体结果具体分析，没有固定方法。</p><h2 id="白盒测试用例"><a href="#白盒测试用例" class="headerlink" title="白盒测试用例"></a>白盒测试用例</h2><p><strong>白盒测试用例</strong>:知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面几种:</p><p>(1)<strong>语句覆盖SC</strong>:逻辑代码中的<strong>所有语句都要被执行一遍，覆盖层级最低</strong>，因为执行了所有的语句，不代表执行了所有的条件判断。</p><blockquote><p>赋值语句、条件语句都是语句。</p></blockquote><p>(2)<strong>判定覆盖DC</strong>:逻辑代码中的<strong>所有判断语句的条件的真假分支都要覆盖一次</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017124504278.png" alt="image-20231017124504278"></p><p>(3) 条件覆盖CC:针对每一个判断条件内的每一个独立条件都要执行一遍真和假。</p><p>(4)<strong>条件判定组合覆盖CDC: 同时满足判定覆盖和条件覆盖</strong></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017125100662.png" alt="image-20231017125100662"></p><p>(5)<strong>路径覆盖</strong>:逻辑代码中的<strong>所有可行路径都覆盖了，覆盖层级最高</strong>。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017130025502.png" alt="image-20231017130025502"></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017130234904.png" alt="image-20231017130234904"></p><p>答案：C.D</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017130505278.png" alt="image-20231017130505278"></p><p>答案：A;D</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>◆测试是发现错误，调试是找出错误的代码和原因。</p><p>◆调试需要确定错误的准确位置;确定问题的原因并设法改正;改正后要进行回归测试。</p><p>◆调试的方法有:<strong>蛮力法、回溯法</strong>(从出错的地方开始，向回找)、<strong>原因排除法</strong> (找出所有可能的原因，逐一进行排除，具体包括演绎法、归纳法、二分法)。</p><h1 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h1><p>◆<strong>软件的两种属性:外部属性指面向管理者和用户的属性，可直接测量</strong>，一般为性能指标。<strong>内部属性指软件产品本身的的属性，如可靠性等，只能间接测量。</strong></p><p>◆<strong>McCabe度量法</strong>【考点】:又称为环路复杂度，假设有向图中<strong>有向边数为m,节点数为n，则此有向图的环路复杂度为m-n+2</strong>.</p><p>注意m和n代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式，另外，针对一个程序流程图，每一一个分支边(连线)就是一条有向边，每一条语句 (语句框)就是一个顶点。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017131428004.png" alt="image-20231017131428004"></p><p>答案：B;11顶点，13个顶点，maccabe为14.</p><h1 id="系统转换【考点】"><a href="#系统转换【考点】" class="headerlink" title="系统转换【考点】"></a>系统转换【考点】</h1><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017131946222.png" alt="image-20231017131946222"></p><p>◆<strong>遗留系统</strong>是指任何基本上<strong>不能进行修改和演化以满足新的变化了的业务需求的信息系统</strong>，它通常具有以下特点:</p><p>(1)系统虽然完成企业中许多重要的业务管理工作，但仍然<strong>不能完全满足要求</strong>。一般实现业务处理电子化及部分企业管理功能，很少涉及经营决策。</p><p>(2)系统在性能上已经落后，采用的<strong>技术已经过时</strong>。例如，多采用主机&#x2F;终端形式或小型机系统，软件使用汇编语言或第三代程序设计语言的早期版本开发，使用文件系统而不是数据库。</p><p>(3)通常是大型的软件系统，已经融入企业的业务运作和决策管理机制之中，<strong>维护工作十分困难</strong>。</p><p>(4)没有使用现代信息系统建设方法进行管理和开发，现在基本上已经没有文档，<strong>很难理解</strong>。</p><p>◆系统转换是指新系统开发完毕，投入运行，取代现有系统的过程，需要考虑多方面的问题，以实现与老系统的交接，有以下三种转换计划:</p><ul><li><p><strong>直接转换</strong>:<strong>现有系统被新系统直接取代了</strong>，风险很大，适用于新系统不复杂，或者现有系统已经不能使用的情况。优点是节省成本。</p></li><li><p><strong>并行转换</strong>:<strong>新系统和老系统并行工作一段时间</strong>，新系统经过试运行后再取代，若新系统在试运行过程中有问题，也不影响现有系统的运行，风险极小，在试运行过程中还可以比较新老系统的性能，<u>适用于大型系统</u>。<u>缺点是耗费人力和时间资源，难以控制两个系统间的数据转换</u>。</p></li><li><p><strong>分段转换</strong>:<strong>分期分批逐步转换</strong>，是直接和并行转换的集合，<strong>将大型系统分为多个子系统，依次试运行每个子系统</strong>，成熟一个子系统， 就转换一个子系统。<u>同样适用于大型项目，只是更耗时，而且现有系统和新系统间混合使用，需要协调好接口等问题</u>。【目前采用的比较多】</p><h1 id="数据转换与迁移"><a href="#数据转换与迁移" class="headerlink" title="数据转换与迁移"></a>数据转换与迁移</h1></li></ul><p><strong>数据转换与迁移</strong>:将数据从旧数据库迁移到新数据库中。</p><p>有三种方法:<strong>系统切换前通过工具迁移、系统切换前采用手工录入、系统切换后通过新系统生成</strong>。</p><h1 id="系统维护【考点】"><a href="#系统维护【考点】" class="headerlink" title="系统维护【考点】"></a>系统维护【考点】</h1><blockquote><p>耗时最长，成本最高。</p></blockquote><p>◆系统的<strong>可维护性</strong>可以定义为<strong>维护人员理解、改正、改动和改进这个软件的难易程度</strong>，其评价指标如下:</p><p>(1)<strong>易分析性</strong>。软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</p><p>(2) <strong>易改变性</strong>。软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。</p><p>(3)<strong>稳定性</strong>。软件产品避免由于软件修改而造成意外结果的能力。</p><p>(4)<strong>易测试性</strong>。软件产品使已修改软件能被确认的能力。</p><p>◆系统维护包括<strong>硬件维护、软件维护和数据维护</strong>，其中软件维护类型如下:</p><p><strong>正确性维护</strong>:发现了bug而进行的修改。</p><p><strong>适应性维护</strong>:由于外部环境发生了改变，被动进行的对软件的修改和升级。</p><p><strong>完善性维护</strong>:基于用户主动对软件提出更多的需求，修改软件，增加更多的功能，使其比之前的软件功能、性能更高，更加完善。</p><p><strong>预防性维护</strong>:对未来可能发生的bug进行预防性的修改。</p><h1 id="系统评价【从未考过】"><a href="#系统评价【从未考过】" class="headerlink" title="系统评价【从未考过】"></a>系统评价【从未考过】</h1><h2 id="系统评价分类"><a href="#系统评价分类" class="headerlink" title="系统评价分类"></a>系统评价分类</h2><p>立项评价:系统开发前的预评价，分析是否立项开发，做可行性评价。</p><p>中期评价:项目开发中期每个阶段的阶段评审。或者项目在开发中途遇到重大变故，评价是否还要继续。</p><p>结项评价:系统投入正式运行后，了解系统是否达到预期的目的和要求而对系统进行的综合评价。</p><h2 id="系统评价的指标"><a href="#系统评价的指标" class="headerlink" title="系统评价的指标"></a>系统评价的指标</h2><p>(1)从信息系统的组成部分出发，信息系统是一个由人机共同组成的系统，所以可以按照运行效果和用户需求(人)、系统质量和技术条件(机)这两条线索构造指标。</p><p>(2)从信息系统的评价对象出发，对于开发方来说，他们所关心的是系统质量和技术水平;对于用户方而言，关心的是用户需求和运行质量:系统外部环境则主要通过社会效益指标来反映。</p><p>(3)从经济学角度出发，分别按系统成本、系统效益和财务指标3条线索建立指标。</p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017181950988.png" alt="image-20231017181950988"></p><p><img src="/../../pic/13.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%5D/image-20231017182013871.png" alt="image-20231017182013871"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;处理流程设计&quot;&gt;&lt;a href=&quot;#处理流程设计&quot; class=&quot;</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>12.文老师-软件工程基础知识[需求分析]</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-10-14T12:06:16.000Z</published>
    <updated>2023-10-22T09:46:46.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>软件需求是指用户<strong>对系统在功能、行为、性能、设计约束等方面的期望</strong>。是<strong>指用户解决问题或达到目标所需的条件或能力</strong>，是<strong>系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力</strong>，以及反映这些条件或能力的文档说明。</p><blockquote><p>可以理解为客户需要什么。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>分为<strong>需求开发</strong>和<strong>需求管理</strong>两大过程。</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016100905029.png" alt="image-20231016100905029"></p><blockquote><p>需求定义：需求规格说明书最为重要。</p><p>需求验证：和客户一起评审，让客户确认需求。</p><p>需求基线：需求验证之后，需求基线形成；如果再变更需求，就需要走变更流程。</p></blockquote><h3 id="系统角度分类"><a href="#系统角度分类" class="headerlink" title="系统角度分类"></a>系统角度分类</h3><p>◆<strong>业务需求</strong>:反映<strong>企业或客户对系统高层次的目标要求</strong>，通常<u>来自项目投资人、客户、市场营销部门或产品策划部门</u>。通过业务需求可以确定项目视图和范围。</p><blockquote><p>和具体的实现没有关系。</p></blockquote><p>◆<strong>用户需求</strong>:描述的是<strong>用户的具体目标，或用户要求系统必须能完成的任务</strong>。即描述了用户能使用系统来做什么。通常采取<u>用户访谈和问卷调查</u>等方式，对用户使用的场景进行整理，从而建立用户需求。</p><p>◆<strong>系统需求</strong>:<strong>从系统的角度来说明软件的需求</strong>，包括功能需求、非功能需求和设计约束等。【考点】</p><blockquote><p>技术人员能够实现的需求。</p></blockquote><ul><li><p>1)功能需求:也称为行为需求，规定了<strong>开发人员必须在系统中实现的软件功能</strong>，用户利用这些功能来完成任务，满足业务需要。</p></li><li><p>2)非功能需求:<strong>指系统必须具备的属性或品质</strong>，又可以细分为软件质量属性(如可维护性、可靠性、效率等)和其他非功能需求。</p></li></ul><blockquote><p>包括系统的性能，如网页打开时间。</p></blockquote><ul><li>3)设计约束:也称为限制条件或补充规约，通常是<strong>对系统的一些约束说明</strong>，例如必须采用国有自主知识产权的数据库系统，必须运行在UNIX操作系统之下等。</li></ul><blockquote><p>外部强制规定。</p></blockquote><h3 id="用户角度分类"><a href="#用户角度分类" class="headerlink" title="用户角度分类"></a>用户角度分类</h3><p>质量功能部署(QFD) 是一种<strong>将用户要求转化成软件需求的技术</strong>，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，QFD将软件需求分为三类，分别是常规需求、期望需求和意外需求。</p><p>(1) 常规需求。用户认为<strong>系统应该做到的功能或性能</strong>，实现越多用户会越满意。</p><p>(2)期望需求。用户<strong>想当然认为系统应具备的功能或性能，但并不能正确描述</strong>自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。</p><blockquote><p>客户不要求也应该实现的功能。</p></blockquote><p>(3)意外需求。意外需求也称为兴奋需求，是<strong>用户要求范围外的功能或性能</strong>(但通常是软件开发人员很乐意赋予系统的技术特性)，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103249677.png" alt="image-20231016103249677"></p><blockquote><p>三个描述的抽象程度不同，抽象程度由高到低排序为 业务需求、用户需求、功能需求。</p></blockquote><h1 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>需求获取</strong>是一个确定和理解不同的项目干系人的需求和约束的过程。</p><h2 id="常见的需求获取法【考点】"><a href="#常见的需求获取法【考点】" class="headerlink" title="常见的需求获取法【考点】"></a>常见的需求获取法【考点】</h2><p>(1)用户访谈: 1对1，最多1-3， <strong>有代表性的用户</strong>。其形式包括结构化和非结构化两种，<strong>对项目组人员要求较高</strong>；无法对所有人进行访谈，需求获取可能不全面。</p><p>(2)问卷调查:用户多，无法一一访谈；可能不精准。</p><p>(3)采样:从种群中系统地选出有代表性的样本集的过程。$样本数量&#x3D;0.25*(可信度因子&#x2F;错误率)^2$</p><p>(4)情节串联板:一系列图片，通过这些图片来讲故事。.</p><p>(5**)联合需求计划(JRP)** :<u>通过联合各个关键用户代表、系统分析师、开发团队代表一起，通过有组织的会议来讨论需求。</u>【开会】</p><p>(6)需求记录技术:任务卡片、场景说明、用户故事、Volere白卡。</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103517223.png" alt="image-20231016103517223"></p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>需求分析: 一个好的需求应该具有<strong>无二义性、完整性</strong>、 一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员<strong>把杂乱无章的用户要求和期望转化为用户需求</strong>，这就是需求分析的工作。</p><h2 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h2><p>(1) 绘制系统上下文范围关系图</p><p>(2)创建用户界面原型</p><p>(3)分析需求的可行性</p><p>(4)确定需求的优先级</p><p>(5)为需求建立模型</p><p>(6)创建数据字典.</p><p>(7)使用QFD (质量功能部署)</p><h2 id="结构化的需求分析"><a href="#结构化的需求分析" class="headerlink" title="结构化的需求分析"></a>结构化的需求分析</h2><p>结构化特点:<strong>自顶向下，逐步分解，面向数据</strong>。</p><p>三大模型:<u><strong>功能模型(数据流图)、行为模型(状态转换图)、数据模型(E-R图)</strong></u>以及数据字典。</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103753156.png" alt="image-20231016103753156"></p><p>状态转换图STD如下图所示:</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016103947728.png" alt="image-20231016103947728"></p><p>◆数据流图描述<strong>数据在系统中如何被传送或变换，以及如何对数据流进行变换的功能或子功能，用于对功能建模</strong>，数据流图相关概念如图:</p><p>◆数据流图是可以分层的，从顶层(即<strong>上下文无关数据流</strong>)到0层、1层等,顶层数据流图只含有一个加工处理表示整个管理信息系统，描述了系统的输入和输出，以及和外部实体的数据交互。数据流图示例如下:</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016104045666.png" alt="image-20231016104045666"></p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016104134231.png" alt="image-20231016104134231"></p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016104123949.png" alt="image-20231016104123949"></p><h1 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>◆<strong>需求定义(软件需求规格说明书SRS)</strong> :是需求开发活动的产物，编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。SRS是软件开发过程中最重要的文档之一，对于任何规模和性质的软件项目都不应该缺少。</p><h2 id="◆需求定义方法"><a href="#◆需求定义方法" class="headerlink" title="◆需求定义方法"></a>◆需求定义方法</h2><p>(1)严格定义也称为预先定义，需求的严格定义<strong>建立在以下的基本假设</strong>之上:<strong>所有需求都能够被预先定义</strong>。开发人员与用户之间能够准确而清晰地交流。采用图形(或文字)可以充分体现最终系统。</p><p>(2)原型方法，<strong>迭代的循环型开发方式</strong>，需要注意的问题:并非所有的需求都能在系统开发前被准确地说明。项目干系人之间通常都存在交流上的困难，原型提供了<strong>克该服困难的一个手段</strong>。特点:需要实际的、可供用户参与的系统模型。有合适的系统开发环境。反复是完全需要和值得提倡的，需求一旦确定,就应遵从严格的方法。</p><h1 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h1><p>◆需求验证:也称为需求确认，目的是<strong>与用户一起确认需求无误</strong>，对需求规格说明书SAS进行评审和测试，包括两个步骤:</p><p>需求评审:正式评审和非正式评审。</p><p>需求测试:设计概念测试用例。【设计场景测试】</p><p>◆需求验证通过后，要请用户签字确认，作为验收标准之一，此时，这个<strong>需求规格说明书就是需求基线</strong>，不可以再随意更新，如果需要更改必须走需求变更流程。</p><h1 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h1><p>◆定义需求基线:<strong>通过了评审的需求说明书就是需求基线</strong>，下次如果需要变更需求，就需要按照流程来一步步进行。需求的流程及状态如下图所示:</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110530187.png" alt="image-20231016110530187"></p><h2 id="◆需求变更【考点】和风险"><a href="#◆需求变更【考点】和风险" class="headerlink" title="◆需求变更【考点】和风险"></a>◆需求变更【考点】和风险</h2><p>主要关心需求变更过程中的需求风险管理，带有风险的做法有:<strong>无足够用户参与、忽略了用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的SRS、不准确的估算</strong>。</p><p>◆变更产生的原因:<strong>外部环境的变化、需求和设计做的不够完整、新技术的出现、公司机构重组造成业务流程的变化。</strong></p><p>◆<strong>变更控制委员会CCB</strong>:也称为配置控制委员会，其任务时对建议的配置项变更做出评价、审批，以及监督已经批准变更的实施。对任何变更都能做出决定。</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110445357.png" alt="image-20231016110445357"></p><p>双向跟踪，两个层次，如下图所示: </p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110637548.png" alt="image-20231016110637548"></p><p>◆正向跟踪表示用户原始需求是否都实现了，反向跟踪表示软件实现的是否都是用户要求的，不多不少，可以用原始需求和用例表格(需求跟踪矩阵)来表示:</p><p>◆若原始需求和用例有对应，则在对应栏打对号，若某行都没有对号，表明原始需求未实现，正向跟踪发现问题;若某列都没有对号，表明有多余功能用例，软件实现了多余功能，反向跟踪发现问题。</p><p><img src="/../../pic/12.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231016110707857.png" alt="image-20231016110707857"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;软件需求&quot;&gt;&lt;a href=&quot;#软件需求&quot; class=&quot;head</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象技术</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2023-10-14T12:06:16.000Z</published>
    <updated>2023-10-28T05:37:36.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="面向对象开发【非常重要】"><a href="#面向对象开发【非常重要】" class="headerlink" title="面向对象开发【非常重要】"></a>面向对象开发【非常重要】</h1><blockquote><p>在采用面向对象技术开发系统时，主要步骤有面向对象分析、面向对象设计、面向对象程序设计和面向对象测试。</p><p><strong>面向对象分析（OOA）</strong>主要包括︰认定对象、组织对象、描述对象间的相互作用、定义对象的操作、定义对象的内部信息。</p><p>**面向对象设计(OOD)**是<u>设计分析模型和实现相应源代码</u>。</p><p><strong>面向对象程序设计</strong>选择合适的面向对象程序设计语言，<u>将程序组织为相互协作的对象集合</u>，每个对象表示某个类的实例，类通过继承等关系进行组织。</p><p><strong>面向对象测试</strong>是尽可能早的开始进行系统测试，以发现系统中可能存在的错误并进行修复，进而保证系统质量。</p><p>分析阶段的目的是为了获得对应用问题的理解，确定系统的功能、性能要求，在此阶段主要关注系统的行为，明确系统需要提供什么服务。</p><p>在设计阶段，采用面向对象技术将OOA所创建的分析模型转化为设计模型,其目标是定义系统构造蓝图。</p><p>在实现阶段（面向对象程序设计)，系统实现人员选用一种面向对象程序设计语言，采用对象、类及其相关概念进行程序设计，即<strong>实现系统</strong>。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>(1)对象:由<strong>数据及其操作所构成的封装体</strong>，是系统中用来<strong>描述客观事务的一个实体</strong>，是构成系统的一个基本单位。一个对象通常可以由<strong>对象名、属性和方法</strong>3个部分组成。</p><blockquote></blockquote><p>(2)类:现实世界中<strong>实体的形式化描述</strong>，类将该实体的属性(数据)和操作(函数)封装在一起。<strong>对象是类的实例，类是对象的模板</strong>。</p><blockquote><p>类是对象的抽象。一般是基于类建立模型。</p></blockquote><p>类可以分为三种:<strong>实体类、接口类(边界类)和控制类</strong>。</p><p>实体类的对象表示<strong>现实世界中真实的实体</strong>，如人、物等。</p><p>接口类(边界类)的对象<strong>为用户提供一种与系统合作交互的方式</strong>，分为人和系统两大类，其中人的接口可以是显示屏、窗口、Web窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。</p><p>控制类的对象用来<strong>控制活动流，充当协调者</strong>。</p><blockquote><p>控制业务流，防止发生混乱；就如规定学生交卷的顺序。</p></blockquote><p>(3)抽象:通过<strong>特定的实例抽取共同特征以后形成概念的过程</strong>。它<strong>强调主要特征，忽略次要特征</strong>。一个对象是现实世界中一个实体的抽象，一个类是一组对象的抽象，抽象是一种单一化的描述，它强调给出与应用相关的特性，拋弃不相关的特性。</p><p>(4)封装:是一种<strong>信息隐蔽技术</strong>，将相关的概念组成一个单元模块，并通过一个名称来引用。面向对象封装是将数据和基于数据的操作封装成一个整体对象,<strong>对数据的访问或修改只能通过对象对外提供的接口进行</strong>。</p><blockquote><p>以下关于封装在软件复用中所充当的角色的叙述，正确的是(A)。</p><p>A封装使得其他开发人员不需要知道一个软件组件内部如何工作</p><p>B封装使得软件组件更有效地工作</p><p>C封装使得软件开发人员不需要编制开发文档</p><p>D封装使得软件组件开发更加容易</p><p>封装是一种信息隐藏技术，其目的是使对象（组件）的使用者和生产者分离，也就是使其他开发人员无需了解所要使用的软件组件内部的工作机制，只需知道如何使用组件,即组件提供的功能及其接口。</p></blockquote><p>(5)继承:表示<u><strong>类之间的层次关系(父类与子类)</strong></u>，这种关系使得某类对象可以继承另外一类对象的特征， 又可分为单继承和多继承。</p><blockquote><p>多重继承是编程语言中的概念，多重继承指的是一个类可以继承另外一个类，而另外一个类又可以继承别的类，比如A类继承B类，而A类又可以继承C类，这就是多重继承。多重继承可能造成混淆的情况，出现二义性的成员。</p></blockquote><p>(6) 多态:<strong>不同的对象收到同一个消息时产生完全不同的结果</strong>。包括<strong>参数多态</strong>(不同类型参数多种结构类型)、<strong>包含多态</strong>(父子类型关系)、<strong>过载多态(又称重载多态)、强制多态(强制类型转换)<strong>四种类型。多态</strong>由继承机制支持</strong>，将通用消息放在抽象层，具体不同的功能实现放在低层。</p><blockquote><p>一个函数名，不同的子类实现了不同的方法。</p></blockquote><blockquote><p>选择题多态分为参数多态、包含多态、过载多态和强制多态四种不同形式，其中()多态在许多语言中都存在，最常见的例子就是子类泛型化。</p><p>A参数B包含C过载D强制</p><p>面向对象系统中，在收到消息时，对象要予以响应。多态( polymorphism )是不同的对象收到同一消息可以进行不同的响应，产生完全不同的结果，<strong>用户可以发送一个通用的消息，而实现细节则由接收对象自行决定，使得同一个消息就可以调用不同的方法</strong>，即一个对象具有多种形态。Cardelli和Wegner将多态分为4种不同的形式:参数多态、包含多态、过载多态和强制多态。其中<strong>参数多态是应用比较广的多态，包含多态在许多语言中都存在</strong>，最常见的例子就是子类型化。<strong>过载多态是同一个名字在不同的上下文中所代表的含义</strong></p><p>参数多态︰应用广泛、最纯的多态。</p><p>包含多态∶同样的操作可用于一个类型及其子类型。包含多态一般需要进行运行时的类型检查。</p><p>强制多态∶编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。</p><p>过载多态∶同一个名（操作符、函数名)在不同的上下文中有不同的类型。</p></blockquote><blockquote><p>多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次。一个对象发送通用消息请求服务时，要根据接收对象的具体情况将求的操作与实现的方法进行连接，即动态绑定，以实现在这些低层次上生成的对传给用消息以不同的响应。</p><p>在面向对象方法中，支持多态的是( )。</p><p>A静态分配B动态分配C静态类型D动态绑定</p></blockquote><p>(7)接口:描述对操作规范的说明，其<strong>只说明操作应该做什么</strong>，并没有定义操作如何做。</p><p>(8)消息:体现<strong>对象间的交互</strong>，通过它向目标对象发送操作请求。</p><p>(9)覆盖:子类在原有父类接口的基础上，用<strong>适合于自己要求的实现去置换父类中的相应实现</strong>。即在子类中重定义一个与父类同名同参的方法。</p><p>(10)函数重载:与覆盖要区分开，函数重载与子类父类无关，且<strong>函数是同名不同参数</strong>。</p><blockquote><p>重载，简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p></blockquote><p>(11)绑定是一个把<strong>过程调用和响应调用所需要执行的代码加以结合的过程</strong>。在一般的程序设计语言中，绑定是在<strong>编译时进行的，叫作静态绑定</strong>。动态绑定则是在<strong>运行时进行的</strong>，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。</p><blockquote><p>选择题某些程序设计语言中，在运行过程中当一个对象发送消息请求服务时，根据接收对象的具体情况将请求的操作与实现的方法进行连接，称为( ) 。</p><p>A静态绑定B通用绑定C动态绑定D过载绑定</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>例题1.在某销售系统中，客户采用扫描二维码进行支付。若采用面向对象方法开发该销售系统，则客户类属于()类，二维码类属于()类。</p><p>A.接口</p><p>B.实体</p><p>C.控制</p><p>D.状态</p><p>A.接口</p><p>B.实体</p><p>C.控制</p><p>D.状态</p><p>答案:BA</p><h2 id="面向对象的分析"><a href="#面向对象的分析" class="headerlink" title="面向对象的分析"></a>面向对象的分析</h2><p>面向对象的分析是为了<strong>确定问题域，理解问题</strong>。包含五个活动:<strong>认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息</strong>。</p><h2 id="面向对象需求建模"><a href="#面向对象需求建模" class="headerlink" title="面向对象需求建模"></a>面向对象需求建模</h2><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231017185417477.png" alt="image-20231017185417477"></p><blockquote><p>两种模型和模型的步骤要记住。</p></blockquote><h2 id="面向对象的设计"><a href="#面向对象的设计" class="headerlink" title="面向对象的设计"></a>面向对象的设计</h2><p>◆面向对象的设计:是<strong>设计分析模型和实现相应源代码</strong>，设计问题域的解决方案，与技术相关。</p><p>OOD同样应遵循抽象、信息隐蔽、功能独立、模块化等设计准则。</p><h2 id="面向对象的分析模型"><a href="#面向对象的分析模型" class="headerlink" title="面向对象的分析模型"></a>面向对象的分析模型</h2><p>◆面向对象的<strong>分析模型</strong>主要由<strong>顶层架构图、用例与用例图、领域概念模型构成</strong>;</p><p><strong>设计模型</strong>则<strong>包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</strong></p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231017185523719.png" alt="image-20231017185523719"></p><blockquote><p>架构图就是体系图。</p></blockquote><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><p>(1)<strong>单一责任原则</strong>。就一个类而言，应该<strong>仅有一个引起它变化的原因</strong>。即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任。</p><p>(2)<strong>开放一封闭原则</strong>。软件实体(类、模块、函数等)应该是<strong>可以扩展的，即开放的;但是不可修改的，即封闭的</strong>。</p><blockquote><p>可以增加功能，但是不能修改原有代码。</p></blockquote><p>(3)<strong>里氏替换原则</strong>。<strong>子类型必须能够替换掉他们的基类型</strong>【就是父类型】。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。</p><blockquote><p>就是子类能替换父类。</p></blockquote><p>(4)<strong>依赖倒置原则</strong>。<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。即，高层模块不应该依赖于低层模块，二者都应该依赖于抽象。</p><blockquote><p>对象应该依赖于类，类不应该依赖于对象。</p></blockquote><p>(5)<strong>接口分离原则</strong>。<strong>内部的实现必须与接口分离</strong>。接口属于客户，不属于它所在的类层次结构。即:<strong>依赖于抽象，不要依赖于具体</strong>，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化。</p><blockquote><p>选择题下列关于一个类的静态成员的描述中，不正确的是( )。</p><p>A类的静态方法只能访问该类的静态数据成员</p><p>B静态数据成员可被该类的所有方法访问</p><p>C该类的对象共享其静态数据成员的值</p><p>D该类的静态数据成员的值不可修改</p><p>试题解析</p><p>面向对象开发方法中，静态成员的含义是所修饰的成员是属于类的，而不是属于某对象的。<strong>静态数据成员对该类只有一份，该类的所有对象共享静态数据成员</strong>，可被该类的所有方法访问，其值可以修改，但是不论是通过对象还是类对静态数据成员值的修改，都会反应到整个类。类的静态方法只能访问该类的静态数据成员。</p></blockquote><p>对象的<strong>状态</strong>包括这个对象的所有属性（通常是静态的)以及每个属性当前的值（通常是动态的)﹔为了将一个对象与其它所有对象区分开来，我们通常会给它起一个“标识”﹔<strong>行为</strong>是对象根据它的状态改变和消息传递所采取的行动和所作出的反应;对象的行为代表了其外部可见的活动;操作代表了一个类提供给它的对象的一种服务。</p><blockquote><p>选择题对象的(A)标识了该对象的所有属性(通常是静态的）以及每个属性的当前值（通常是动态的)。</p><p>A状态B唯一IDC行为D语义</p></blockquote><h2 id="面向对象软件的测试层次"><a href="#面向对象软件的测试层次" class="headerlink" title="面向对象软件的测试层次"></a>面向对象软件的测试层次</h2><p>一般来说，对面向对象软件的测试可分为下列4个层次进行。</p><p>(1)<strong>算法层</strong>。测试<strong>类中定义的每个方法</strong>，基本上相当于传统软件测试中的单元测试。</p><blockquote><p>测试类中的每一个函数。</p></blockquote><p>(2)<strong>类层</strong>。测试封装<strong>在同一个类中的所有方法与属性之间的相互作用</strong>。在向面对象软件中类是基本模块，因此可以认为这是面向对象测试中所特有的模块测试。</p><p>(3)<strong>模板层</strong>。测试一组协同工作的类之间的相互作用，大体上相当于传统软件测试中的集成测试，但是也有面向对象软件的特点(例如，对象之间通过发送消息相互作用)。</p><p>(4) <strong>系统层</strong>。<strong>把各个子系统组装成完整的面向对象软件系统</strong>，在组装过程中同时进行测试。</p><p><strong>面向对象的分析模型主要由顶层架构图、用例与用例图和( )构成:设计模型则包含以()表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的( )和用以描述流程化处理过程的活动图等。</strong></p><p>A.数据流模型</p><p>B.领域概念模型</p><p>C.功能分解图</p><p>D.功能需求模型</p><p>A.模型视图控制器</p><p>B.组件图</p><p>C.包图</p><p>D.2层、3层或N层</p><p>A.序列图</p><p>B.协作图</p><p>C.流程图</p><p>D.状态图</p><p>答案:B.C.D</p><p>在面向对象设计的原则中、( D)原则是指抽象不应该依赖予细节，细节应该依赖于抽象，即应针对接口编程，而不是针对实现编程。</p><p>A.开闭B.里氏替换C.最少知识D.依赖倒置</p><p>答案: D</p><h1 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h1><p>◆<strong>UML (统一建模语言)</strong> :是一种<strong>可视化的建模语言，而非程序设计语言</strong>，支持从需求分析开始的软件开发的全过程。</p><p>◆从总体上来看，UML的结构包括<strong>构造块、规则和公共机制</strong>三个部分。</p><p>(1)构造块。UML有三种基本的构造块，分别是<strong>事务、关系和图</strong> 。事物是UML的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合。</p><p>(2)公共机制。公共机制是指达到特定目标的公共UML方法。【不考】</p><p>(3)规则。规则是构造块如何放在一起的规定。【不考】</p><h2 id="事物的类型"><a href="#事物的类型" class="headerlink" title="事物的类型"></a>事物的类型</h2><p>◆结构事物:模型的静态部分，如类、接口、用例、构件等;</p><p>◆行为事物:模型的动态部分，如交互、活动、状态机;</p><p>◆分组事物:模型的组织部分，如包;</p><p>◆注释物:模型的解释部分，依附于一个元素或一组元素之上对其进行约束或解释的简单符号。</p><blockquote><p>选择题在面向对象分析与设计中，()是应用领域中的核心类，一般用于保存系统中的信息以及提供针对这些信息的相关处理行为;(&#x2F;)是系统内对象和系统外参与者的联系媒介;(&#x2F;)主要是协调上述两种类对象之间的交互。</p><p>A)控制类B边界类C实体类D软件类</p><p><strong>实体类</strong>主要负责数据和业务逻辑;<strong>边界类</strong>负责和用户进行交互，即用户界面;<strong>控制类</strong>则负责实体类和界面类的交互。</p></blockquote><h2 id="事物的关系【考点】"><a href="#事物的关系【考点】" class="headerlink" title="事物的关系【考点】"></a>事物的关系【考点】</h2><p>◆依赖:<strong>一个事物的语义依赖于另一个事物的语义的变化而变化</strong></p><p>◆关联:是一种结构关系，描述了一组链，链是对象之间的连接。分为<strong>组合和聚合</strong>，都是<strong>部分和整体的关系</strong>，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。</p><blockquote><p>组合事物之间关系更强，具有共同的生命周期；总体不存在时，部分也就不存在了，反之亦然。</p><p>聚合关系不具有共同的生命周期，总体可以缺失部分而继续存在。</p></blockquote><p>◆泛化:<strong>一般&#x2F;特殊的关系</strong>，子类和父类之间的关系</p><p>◆实现:<strong>一个类元指定了另一个类元保证执行的契约</strong>。</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231017192315672.png" alt="image-20231017192315672"></p><blockquote><p>上图六种符号要记忆！</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018183751993.png" alt="image-20231018183751993"></p><p>答案：A.C.D</p><blockquote><p>选择题如下所示的UML类图中，Car和Boat类中的move ( B)方法()了’Transport类中的move( )方法。</p><p><img src="/../../pic/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231024130620582.png" alt="image-20231024130620582"></p><p>A继承B覆盖（重置)C重载D聚合</p><p>一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况，即继承关系。继承是父类和子类之间共享数据和方法的机制。父类描述了这些子类的公共属性和方法。一个子类可以继承它的父类（或祖先类）中的属性和方法，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和方法，也可以重新定义父类中己经定义的方法，即重置或覆盖（ overriding )。<strong>UML类图中，如果父类中已有方法名在子类中不出现，表示子类继承父类中的方法;如果父类中已有方法名在子类中出规了，就表示子类在继承父类接口定义的前提下，用适合于自己要求的实现去置换父类中的相应实现，即覆盖了父类中的方法。</strong></p></blockquote><h2 id="UML2-0图"><a href="#UML2-0图" class="headerlink" title="UML2.0图"></a>UML2.0图</h2><p>UML2.0图，书上是13种，有的说法还包含制品图，一共14种，了解即可，总分类如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018191720595.png" alt="image-20231018191720595"></p><p><strong>类图</strong>:静态图，为系统的<strong>静态设计视图</strong>，展现一组<strong>对象、接口、协作和它们之间的关系</strong>。UML类图如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192045517.png" alt="image-20231018192045517"></p><p>◆<strong>对象图</strong>:静态图，展现<strong>某一时刻一组对象及它们之间的关系</strong>，为类图的某一快照。<u>在没有类图的前提下，对象图就是静态设计视图</u>。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192122744.png" alt="image-20231018192122744"></p><blockquote><p>UML图中，对象图展现了() , ( &#x2F; )所示对象图与下图所示类图不一致。</p><p><img src="/../../pic/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231028133558013.png" alt="image-20231028133558013"></p><p>A.一组对象、接口、协作和它们之间的关系B.一组用例、参与者以及它们之间的关系C.某一时刻一组对象以及它们之间的关系D.以时间顺序组织的对象之间的交互活动</p><p>对象图︰展现了某一个时刻一组对象以及它们之间的关系。类图︰<strong>展现了一组对象、接口、协作和它们之间的关系。</strong>用例图︰展现了一组用例、参与者以及它们之间的关系。序列图︰是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p></blockquote><p><strong>用例图</strong>【考点】:静态图，展现了<strong>一组用例、参与者以及它们之间的关系</strong>。用例图中的参与者是人、硬件或其他系统可以扮演的角色；用例是参与者完成的一系列操作，用例之间的关系有<strong>扩展、包含、泛化</strong>【特有的】。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192306817.png" alt="image-20231018192306817"></p><blockquote><p>用例可以理解为参与者拥有的功能。用例图是用来需求建模的。</p><p>包含：要进行A，必须先完成B，则称A包含B。</p><p>扩展：要进行A，可以选择是否先完成B，则称A扩展B。B是可做可不做的。</p><p>泛化：父子关系。</p></blockquote><p>◆序列图:即顺序图，动态图，是场景的图形化表示，描述了<strong>以时间顺序组织的对象之间的交互活动</strong>。有<strong>同步消息</strong>（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示)，<strong>异步消息</strong>（发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示)、<strong>返回消息</strong>(由从右到左的虚线箭头表示)三种。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018192835164.png" alt="image-20231018192835164"></p><p>通信图:动态图，<strong>即协作图，强调参加交互的对象的组织</strong>。如下:</p><blockquote><p>反映对象之间的信号传递。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193122999.png" alt="image-20231018193122999"></p><p>◆状态图:动态雷，展现了一个状态机，描述单个对象在多个用例中的行为，包括简单状态和组合状态。转换可以通过<strong>事件触发器触发</strong>【如按下播放器的播放按钮，播放器开始播放】，事件触发后相应的<strong>监护条件</strong>会进行检查【如检查收音机电源是否接通，不满足的话就不会产生状态转换】。状态图中转换和状态是两个独立的概念，如下:图中方框代表状态，筋头上的代表触发事件，实心圆点为起点和终点。</p><blockquote><p>两个黑点表示初始状态和结束状态。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193222627.png" alt="image-20231018193222627"></p><p>◆活动图:动态图，是一种<strong>特殊的状态图</strong>，展现了在<strong>系统内从一个活动到另一个活动的流程</strong>。活动的分岔和汇合线是一条水平粗线。牢记下图中<strong>并发分岔、并发汇合、监护表达式、分支、流</strong>等名词及含义。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。</p><blockquote><p>并发分岔：并行做几种操作。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193640762.png" alt="image-20231018193640762"></p><p>◆构件图(组件图)：静态图，为<strong>系统静态实现视图，展现了一组构件之间的组织和依赖</strong>。如下:</p><blockquote><p>供接口：半圆；需接口：整圆</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018193948972.png" alt="image-20231018193948972"></p><p>选择题：UML构件图( component diagram)展现了一组构件之间的组织和依赖，专注于系统的静态（)视图，图中通常包括构件、接口以及各种关系。</p><p>A.关联B.实现C.机构D.行为</p><blockquote><p>构件图(Component Diagram )展现了一组构件之间的组织和依赖。构件图专注于系统的<strong>静态实现视图</strong>。</p></blockquote><p>◆部署图:静态图，为<strong>系统静态部署规图</strong>，部署图<strong>物理模块</strong>的节点分布。它与构件图相关，通常一个结点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。如下:</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018194135608.png" alt="image-20231018194135608"></p><h2 id="视图（UML-4-1视图"><a href="#视图（UML-4-1视图" class="headerlink" title="视图（UML 4+1视图)"></a>视图（UML 4+1视图)</h2><blockquote><p>视图是图的一个抽象。视图提出的概念由图来实现</p></blockquote><p>(1)逻辑视图。逻辑视图也称为<strong>设计视图</strong>，它表示了设计模型中在架构方面具有重要意义的部分，即<strong>类、子系统、包和用例实现的子集</strong>。</p><p>(2)进程视图。进程视图是<strong>可执行线程和进程作为活动类的建模</strong>，它是逻辑视图的一次执行实例<strong>，描述了并发与同步结构</strong>。</p><p>(3)实现视图。实现视图对组成基于系统的<strong>物理代码的文件和构件进行建模</strong>。</p><p>(4)部署视图。部署视图<strong>把构件部署到一组物理节点上</strong>，表示软件到硬件的映射和分布结构。</p><p>(5)用例视图。用例视图是<strong>最基本的需求分析模型</strong>。</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018194300135.png" alt="image-20231018194300135"></p><p>用例(use case)用来描述系统对事件做出响应时所采取的行动。用例之间是具有相关性的。在一个会员管理系统中，会员注册时可以采用电话和邮件两种方式。用例“会员注册”和“电话注册”、“邮件注册”之间是（C)关系。</p><p>A.包含(include)</p><p>B.扩展(extend) </p><p>c.泛化 (generalize)</p><p>D.依赖(depends on)</p><p>以下关于UML状态图的叙述中，不正确的是（B )A、活动可以在状态内执行，也可以在迁移时执行</p><p>B、若事件触发一个没有特定监护条件的迁移，则对象离开当前状态</p><p>C、迁移可以包含事件触发器，监护条件和状态</p><p>D、事件触发迁移</p><blockquote><p>迁移:一个状态到另一个状态的转换。</p></blockquote><p>在UML提供的系统视图中，(A）是逻辑视图的一次执行实例，描述了并发与同步结构;(D）是最基本的需求分析模型。</p><p>A进程视图</p><p>B.实现视图</p><p>C.部署视图</p><p>D.用例视图</p><p>A．进程视图</p><p>B.实现视图</p><p>c.部署视图</p><p>D.用例视图</p><p>如下所示的UML图是(D)，图中（Ⅰ)表示(B) ，图中（ⅠⅠ))表示(B)。</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018195031463.png" alt="image-20231018195031463"></p><p>A．序列图</p><p>B．状态图c．通信图D．活动图</p><p>A．合并分叉</p><p>B．分支</p><p>c．合并汇合</p><p>D．流</p><p>A．分支条件</p><p>B．监护表达式</p><p>c．动作名</p><p>D．流名称</p><h1 id="设计模式【重要】"><a href="#设计模式【重要】" class="headerlink" title="设计模式【重要】"></a>设计模式【重要】</h1><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018195659471.png" alt="image-20231018195659471"></p><p>架构模式:软件设计中的<strong>高层决策</strong>，例如C&#x2F;S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策。</p><p>设计模式:每一个设计模式描述了一个在我们周围<strong>不断重复发生的问题</strong>，<strong>以及该问题的解决方案的核心</strong>。这样，你就能一次又一次地使用该方案而不必做重复劳动。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便的复用成功的的设计和体系结构。四个基本要素:<strong>模式名称、问题（应该在何时使用模式）、解决方案（设计的内容）、效果（模式应用的效果）</strong>。</p><p>惯用法:是最低层的模式，<strong>关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系</strong>。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用一计数就是C++语言中的一种惯用法。</p><blockquote><p>考试考察方法有三种：1.三大类有哪些模式：把创建和结构型记住，剩下的是行为型。2.考察哪些场景适合用哪种模式。3.设计模式的图形。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018201750330.png" alt="image-20231018201750330"></p><blockquote><p>构造器：类和类的构造分离。如在游戏创建一个人物【需要设计五官、衣服等】，这个人物就是一个复杂类。构造身体不同部分的特征就是类的构造。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018202556216.png" alt="image-20231018202556216"></p><blockquote><p><strong>桥接模式</strong>：课程资料可以以电子或纸质等载体分发，课程资料内容可以是文字的，也可以以图片形式。电子或者纸质是抽象，文字和图片是实现。他们之间可以有电子-文字，电子-照片等四种组合方式。</p></blockquote><blockquote><p>组合模式：强调部分和整体之间的关系。</p></blockquote><blockquote><p>代理模式：软件的快捷方式。</p></blockquote><p>(&#x2F;)设计模式能够动态地给一个对象添加一些额外的职责而无需修改此对象的结构;(&#x2F;)设计模式定义一个用于创建对象的接口，让子类决定实例化哪一个类;欲使一个后端数据模型能够被多个前端用户界面连接，采用(D)模式最适合。</p><p>A装饰器（Decorator )B享元( Flyweight )C观察者( Observer )D中介者(Mediator )</p><p>因使用大量的对象而造成很大的存储开销时，适合采用()模式进行对象共享，以减少对象数量从而达到较少的内存占用并提升性能。</p><p>A组合(Composite )B享元( Flyweight )C迭代器（Iterator )D备忘( Memento )</p><blockquote><p>组合(Composite )模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户<strong>对单个对象和组合对象的使用具有一致性</strong>。适用于∶想表示对象的部分-整体层次结构;希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>外观(Facade)模式<strong>为子系统中的一组接口提供一个一致的界面</strong>，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。适用于:要<strong>为一个复杂子系统提供一个简单接口时</strong>，子系统往往因为不断演化而变得越来越复杂﹔客户程序与抽象类的实现部分之间存在着很大的依赖性;当需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。</p><p>享元( Flyweight )模式运用共享技术有效地支持大量细粒度的对象。适用于:一个应用程序使用了大量的对象﹔完全由于使用大量的对象，造成很大的<strong>存储开销</strong>;对象的大多数状态都可变为外部状态﹔如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象︰应用程序不依赖于对象标识。</p><p>装饰器（Decorator)模式描述了以透明围栏来支持修饰的类和对象的关系，<strong>动态地给一个对象添加一些额外的职责,从增加功能的角度来看，装饰器模式相比生成子类更加灵活</strong>。适用于∶在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责﹔处理那些可以撤销的职责;当不能采用生成子类的方式进行扩充时。</p><p>工厂方法(Factory Method )定义一个用于创建对象的接口，让子类决定将哪一个类实例化，使一个类的实例化延迟到其子类。适用于︰当一个类不知道它所必须创建的对象的类的时候﹔当一个类希望由它的子类来指定它所创建的对象的时候;当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p>观察者（Observer )模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。适用于∶当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用;当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时;当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</p><p><strong>中介者</strong>( Mediator)用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。适用于:一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解;一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象;想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲<strong>使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适</strong>。</p><p>迭代器（Itcrator )提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。适用于:<strong>访问一个聚合对象的内容而无须暴露它的内部表示</strong>﹔支持对聚合对象的多种遍历;<strong>为遍历不同的聚合结构提供一个统一的接口</strong>。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231018205415132.png" alt="image-20231018205415132"></p><blockquote><p>命令模式强调”可撤销“。</p><p>解释器模式通俗而言就是虚拟机，可以进行一些自定义操作。</p><p>迭代器模式：不暴露对象内部的细节。</p><p>中介模式：”不直接引用“。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231023212723092.png" alt="image-20231023212723092"></p><blockquote><p>备忘录模式：就是一个存档再读档的过程。</p></blockquote><blockquote><p>观察者模式：类似订阅微信公众号。观察者就是订阅者，被观察者就是公众号。</p></blockquote><blockquote><p>状态模式：类似随着会员等级变化，权限也随之变化。</p></blockquote><blockquote><p>策略模式：接口不需要改变，只需要改变算法。</p></blockquote><blockquote><p> 骨架就是一个模板，使用模板创建具体的类。</p></blockquote><blockquote><p>访问者模式：不同的阶段会有不同的行为（操作），而数据通常是不变的，因此把数据和操作分离。</p></blockquote><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231023213501673.png" alt="image-20231023213501673"></p><p>答案：DABA</p><p><img src="/../../pic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-20231023213807339.png" alt="image-20231023213807339"></p><p>答案：CAAB</p><p>某些设计模式会引入总是被用作参数的对象。例如(A)对象是一个多态accept方法的参数。</p><p>A.VisitorB.CommandC.MementoD.Obscrver</p><blockquote><p>很多行为模式注重封装变化。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样，当该程序的其他部分依赖于这个方面时，它们都可以与此对象协作。一些模式引入总是被用作参数的对象。有些模式定义一些可作为令牌进行传递的对象，这些对象将在稍后被调用。</p><p>在Visitor模式中，一个Visitor对象是一个多态的accept操作的参数，这个操作作用于该Visitor对象访问的对象。</p><p>在Command模式中，令牌代表一个请求;</p><p>在Memento模式中，它代表在一个对象在某个特定时刻的内部状态。</p><p>在这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会认识到这一点。</p><p>在Observer模式中，通过引入Observer和Subject对象来分布通信。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;面向对象开发【非常重要】&quot;&gt;&lt;a href=&quot;#面向对象开发【非常</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>9.文老师-数据结构</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-10-14T12:06:15.000Z</published>
    <updated>2023-11-02T09:09:01.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014182707252.png" alt="image-20231014182707252"></p><p>线性结构:每个元素<strong>最多只有一个出度和一个入度</strong>，表现为一条线状。线性表<strong>按存储方式【存储结构】分为顺序</strong><strong>表和链表</strong>。</p><ul><li><p>顺序存储:用一组<strong>地址连续的存储单元</strong>依次存储线性表中的数据元素，使得<strong>逻辑上相邻的元素物理上也相邻</strong>。</p></li><li><p>链式存储:存储各数据元素的结点的**<u>地址并不要求是连续的</u><strong>，数据元素逻辑上相邻,物理上分开；</strong>一个节点分为数据域和指针域，数据域记录了当前节点的数据，指针域记录了下一个相邻节点的物理地址**。</p></li></ul><p>顺序存储和链式存储的对比如下图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014183449722.png" alt="image-20231014183449722"></p><p>◆在空间方面，因为链表还需要存储指针，因此有空间浪费存在。</p><p>◆在时间方面，当需要<strong>对元素进行破坏性操作(插入、删除)时，链表效率更高</strong>，<u>因为其只需要修改指针指向即可，而顺序表因为地址是连续的，当删除或插入一个元素后，后面的其他节点位置都需要变动</u>。</p><p>◆而当需要对元素进行**不改变结构操作时(读取)，顺序表效率更高,**因为其物理地址是连续的，如同数组一般，只需按索引号就可快速定位，而链表需要从头节点开始，一个个的查找下去。</p><p><strong>选择题</strong>若对线性表的最常用操作是访问任意指定序号的元素，并在表尾加入和删除元素，则适宜采用(A )存储。</p><p>A.顺序表B.单链表C.双向链表D.哈希表</p><blockquote><p>线性表的元素在逻辑上是一个线性序列，若最常用的操作是访问任意指定序号的元素，而且其插入和删除元素的操作均在表尾进行，不需要移动其他元素，则其存储结构采用顺序表最为合适。</p></blockquote><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>队列、栈结构如下图；</p><p><strong>队列是先进先出，分队头和队尾;</strong></p><p><strong>栈是先进后出，只有栈顶能进出。</strong></p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014214721898.png" alt="image-20231014214721898"></p><h3 id="循环队列【考点】"><a href="#循环队列【考点】" class="headerlink" title="循环队列【考点】"></a>循环队列【考点】</h3><p><a href="https://www.bilibili.com/video/BV1cg411c7Rh?t=19.5">https://www.bilibili.com/video/BV1cg411c7Rh?t=19.5</a></p><p>设循环队列Q的容量为MAXSIZE,初始时队列为空，且Q.rear 和Q.front都等于0。</p><blockquote><p>队头指针永远指向队列第一个元素的地址。队尾指针永远指向队列最后一个元素的下一个元素的地址。</p><p>队头指针——&gt;读操作——&gt;指向当前元素</p><p>队尾指针——&gt;写操作——&gt;指向队列最后一个元素的空闲区域</p></blockquote><p>元素<strong>入队时</strong>修改<strong>队尾</strong>指针，即令Q.rear&#x3D;(Q.rear+1)%MAXSIZE.【%指取余操作】</p><p>元素<strong>出队时</strong>修改<strong>队头</strong>指针，即令Q.front&#x3D;(Q.front+ 1)%MAXSIZE。</p><p>根据队列操作的定义，当出队操作导致队列变为空时,有Q.rear&#x3D;&#x3D;Q.front;若入队操作导致队列满，则Q.rear&#x3D;&#x3D;Q.front。此时无法区分队列空还是队列满。</p><p>在队列空和队列满的情况下，循环队列的队头、队尾指针指向的位置是相同的，此时仅仅根据Q.rear和Q.front之间的关系无法断定队列的状态。为了区别队空和队满的情况，可采用以下两种处理方式:</p><p>其一是设置一个标志，以区别头、尾指针的值相同时队列是空还是满;</p><p>其二是**<u>牺牲一个存储单元，约定以“队列的尾指针所指位置的下一个位置是队头指针时”表示队列满</u>**，如图所示，而头、尾指针的值相同时表示队列为空。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014215959474.png" alt="image-20231014215959474"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1.对于线性表，相对于顺序存储，采用链表存储的缺点是(A) 。</p><p>A.数据元素之间的关系需要占用存储空间，导致存储密度不高</p><p>B.表中结点必须占用地址连续的存储单元，存储密度不高</p><p>C.插入新元素时需要遍历整个链表，运算的时间效率不高</p><p>D.删除元素时需要遍历整个链表，运算的时间效率不高</p><p>2.若一个栈初始为空，其输入序列是1，2, 3, …. n-1, n,其输出序列的第一个元素为k(1≤ k≤ [n&#x2F;2」),则输出序列的最后一个元素是(D)</p><p>A.值为n的元素</p><p>B.值为1的元素</p><p>C.值为n-k的元素</p><p>D.不确定的</p><ol start="3"><li></li></ol><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014221225325.png" alt="image-20231014221225325"></p><p>答案：D</p><ol start="4"><li></li></ol><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014221612909.png" alt="image-20231014221612909"></p><p>答案：B</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一种<strong>特殊的线性表</strong>，其数据元素都为字符。</p><p>◆空串:长度为的字符串，没有任何字符。</p><p>◆空格串:由一个或多个空格组成的串，空格是空白字符,占一个字符长度。</p><blockquote><p>空格是一个空白字符。</p></blockquote><p>◆子串:串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串，空串是任意串的子串。</p><p>◆串的模式匹配:子串的定位操作，用于<strong>查找子串在主串中第一次出现的位置的算法</strong>。</p><h3 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h3><h4 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h4><p><strong>朴素的模式匹配算法</strong>:也称为布鲁特——福斯算法， 其基本思想是<strong>从主串的第1个字符起与模式串的第1个字符比较，若相等，则继续逐个字符进行后续的比较;否则从主串中的<u>第2个字符起</u>与模式串的第1个字符重新比较</strong>，直至模式串中每个字符依次和主串中的一个连续的字符序列相等时为止，此时称为匹配成功，否则称为匹配失败。</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>KMP算法：对基本模式匹配算法的改进，其改进之处在于:每当匹配过程中出现<strong>相比较的字符不相等时，不需要回溯主串的字符位置指针，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的距离</strong>，再继续进行比较。</p><p>当模式串中的字符 pj 与主串中相应的字符Si不相等时，因其前j个字符(“p…pj-1”)已经获得了成功的匹配，所以**若模式串中”p0…pk-1”与”pj-k…pj-1”相同，这时可令pk与si进行比较，<u>从而使i无须回退</u>**。</p><p>在KMP算法中，依据b。若令next[j]&#x3D;k,则next[j]表示当模式串中的pj与主串中相应字符不相等时，<strong>令模式串的nex[j]与主串的相应字符进行比较</strong>。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>在字符串的KMP模式匹配算法中，需先求解模式串的next函数值，其定义如下式所示，j表示模式 串中字符的序号 (从 1 开始)。若模式串 $p$ 为 “abaac”，则其next函数值为 ()。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015111921751.png" alt="image-20231015111921751"></p><p>A. 01234B. 01122C. 01211D. 01111</p><p>解析:考查字符串的模式匹配算法。关键在于理解公式，而后从1开始代入，过程如下:</p><p> j&#x3D;1时p1为a，此时输出next[1]&#x3D;0,</p><p>j&#x3D;2时p2为b，比较中间的判断条件，1&lt;k&lt;j, 但j&#x3D;2， 故k为空，故next[2]&#x3D;1,</p><p>j&#x3D;3时p3&#x3D;a,此时k只能等于2，p1不等于p2,故不能满足中间的情况，此时next[3]&#x3D;1,</p><p>再取j&#x3D;4，k可以等于2或3，判断发现k&#x3D;2时满足但k&#x3D;3不满足，故next[4]&#x3D;2,</p><p>再取j&#x3D;5，k可以等于2或3或4，比较p1p2Lpk 1和右边那个等式，发现k&#x3D;2时成立，next[5]&#x3D;2。 </p><p>故答案应该为B: 01122 。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是<strong>定长线性表在维度上的扩展</strong>, 即<strong>线性表中的元素又是一个线性表</strong>。 N维数组是一种 “同构” 的数据结构, 其<strong>每个数据元素类型相同、结构一致</strong>。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113002293.png" alt="image-20231015113002293"></p><p>其可以表示为行向量形式或者列向量形式线性表，单个关系最多只有一个前 驱和一个后继, 本质还是线性的。</p><p>数组结构的特点: <strong>数据元素数目固定; 数据元素类型相同; 数据元素的下标 关系具有上下界的约束且下标有序。</strong></p><p>数组数据元素固定, 一般不做插入和删除运算, <strong>适合于采用顺序结构</strong>。</p><p>数组存储地址的计算,特别是二维数组，要注意理解，假设每个数组元素占用存储长度为len，起始地址为a，存储地址计算如下(<strong>默认从0开始编号</strong>) :</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113252350.png" alt="image-20231015113252350"></p><blockquote><p>考试中直接取特殊值求答案。</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>特殊矩阵:矩阵中的元素(或非0元素)的分布有定的规律。常见的特殊矩阵有对称矩阵、三角矩阵和对角矩阵。</p><p>稀疏矩阵:在一个矩阵中，若非零元素的个数远远少于零元素个数，且非零元素的分布没有规律。</p><p><strong>存储方式为三元组结构，即存储每个非零元素的(行，列，值)。</strong></p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113930675.png" alt="image-20231015113930675"></p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015114316509.png" alt="image-20231015114316509"></p><blockquote><p>特殊值代入计算。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015114817931.png" alt="image-20231015114817931"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广，<strong>是由0个或多个单元素或子表组成的有限序列</strong>。</p><p>广义表与线性表的区别:线性表的元素都是结构上不可分的单元素,而<strong>广义表的元素既可以单元素，也可以是有结构的表</strong>。</p><p>广义表一般记为: LS&#x3D; (a1, a2, .. an)。其中LS是表名，ai是表元素，它可以是表(称为子表)，也可以是数据元素(称为原子)。其中n是**广义表的长度(也就是最外层包含的元素个数)<strong>，n&#x3D;0的广义表为空表;而</strong>递归定义的重数就是广义表的深度，即定义中所含括号的重数(单边括号的个数，原子的深度为0，空表的深度为1)**。</p><blockquote><p>一般计算单边括号的个数就能得到表的深度。</p></blockquote><p>head()和tail():<strong>取表头</strong>(<strong>广义表第一个表元素</strong>，可以是子表也可以是单元素)和<strong>取表尾</strong>(**广义表中，除了第一个表元素之外的其他所有表元素构成的<u>表</u>**，非空广义表的表尾必定是一个表, 即使表尾是单元素)操作。</p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>树是n个节点的有限集合(n&gt;&#x3D;0) ，当n&#x3D;0时称为空树，在任一颗非空树中，<strong>有且仅有一个根节点</strong>。其余结点可分为m(m&gt;&#x3D;0)个互不相交的有限子集T1，T2, … Tm，其中，每个Ti又都是一棵树，井且称为根结点的子树。</p><h3 id="树的基本概念如下"><a href="#树的基本概念如下" class="headerlink" title="树的基本概念如下"></a>树的基本概念如下</h3><p>(1)<strong>双亲、孩子和兄弟</strong>。结点的子树的根称为该结点的孩子;相应地，该结点称为其子结点的双亲。具有相同双亲的结点互为兄弟。</p><p>(2)<strong>结点的度</strong>。一个结点的子树的个数记为该结点的度。例如A的度为3，B的度为2，C的度为0，D的度为1。</p><blockquote><p>就是该节点的出度。</p></blockquote><p>(3)<strong>叶子结点</strong>。叶子结点也称为终端结点，<strong>指度为0的结点</strong>。例如，E、 F、C、G都是叶子结点。</p><p>(4)<strong>内部结点</strong>。度不为0的非根结点，也称为分支结点或非终端结点。除根结点以外，分支结点也称为内部结点。例如，B、D都是内部结点。</p><p>(5)<strong>结点的层次</strong>。根为第一层，根的孩子为第二层，依此类推，若某结点在第i层，则其孩子结点在第1+1层。例如，A在第1层，B、C、D在第2层，E、F和G在第3层。</p><p>(6)<strong>树的高度</strong>。一棵树的最大层数记为树的高度(或深度)。例如，图中所示树的高度为3。</p><p>(7)<strong>有序(无序)树</strong>。若将树中结点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树，否则称为无序树。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015120007862.png" alt="image-20231015120007862"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>二叉树是n个节点的有限集合,它或者是空树，或者是由一个根节点及<strong>两颗互不相交的且分别称为左、右子树的二叉树所组成</strong>。</p><blockquote><p>子树个数小于等于2.</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015122445611.png" alt="image-20231015122445611"></p><p>两种特殊的二叉树:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015122546634.png" alt="image-20231015122546634"></p><p><strong>满二叉树</strong>：除叶子节点外，每个节点的度都为2。</p><p><strong>完全二叉树</strong>：完全二叉树有n层，n-1层是满的，最后一层从左到右是不间断的。</p><p><strong>非完全二叉树</strong>：完全二叉树有n层，n-1层是满的，最后一层从左到右是间断的。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>二叉树有一些性质如下, 要求掌握, 在实际考试中可以用特殊值法验证。</p><p>(1) 二叉树<strong>第 $i$ 层 $(i \geq 1)$ 上至多有 $2 ^{i-1}$ 个节点</strong>。</p><p>(2) <strong>深度为 $k$ 的二叉树至多有 $2^{k}-1$ 个节点 $(k \geq 1)$</strong> 。</p><p>(3) <strong>对任何一棵二叉树, 若其终端节点数为 $n_0$, 度为2的节点数为 $n_2$, 则 $n_0&#x3D;n_2+1$</strong> 。</p><blockquote><p>此公式可以画一个简单的二叉树使用特殊值法快速验证, 也可以证明如下: 设一棵二叉树上叶结点数为 $n_0$, 单分支结点数为 $n_1$, 双分支结点数为 $ {n}_2$, 则总的点数 $&#x3D;n_0+n_1+n_2$ 。在一棵二叉树中, 所有结点的分支数(即度数)应等于单分支结点 数加上双分支结点数的 2 倍, 即总的分支数 $&#x3D;n_1+2 n_2$ 。由于二叉树中除根结点以外, 每个结点都有唯一的一个分支指向它, 因此二叉树中: 总的分支数&#x3D;总结点数 -1 。</p></blockquote><p>(4) <strong>具有 $n$ 个节点的完全二叉树的深度为 $\lfloor\log 2 n\rfloor+1$</strong> 。【向下取整】</p><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><p>顺序存储，就是<strong>用一组连续的存储单元存储二叉树中的节点</strong>，按照<strong>从上到下，从左到右的顺序依次存储每个节点</strong>。</p><blockquote><p>一般只适用于完全二叉树和满二叉树。</p></blockquote><p>对于深度为k的完全二叉树，除第k层外，其余每层中节点数都是上一层的两倍，由此，从一个节点的编号可推知其双亲、左孩子、右孩子结点的编号。假设有编号为i的节点，则有:</p><p>若i&#x3D;1，则该节点为根节点，无双亲;</p><p>若i&gt;1， 则该节点的双亲节点为[i&#x2F;2]【向下取整】。</p><p>若2i&lt;&#x3D;n，则该节点的左孩子编号为2i,否则无左孩子。</p><p>若2i+1&lt;&#x3D;n，则该节点的右孩子编号为2i+1，否则无右孩子。</p><p>显然，<strong>顺序存储结构对完全二叉树而言既简单又节省空间，而对于一般二叉树则不适用</strong>。因为在顺序存储结构中，以节点在存储单元中的位置来表示节点之间的关系，那么对于一般的二叉树来说，也必须按照完全二叉树的形式存储，也就是要<strong>添上一些实际并不存在的“虚节点”，这将造成空间的浪费</strong>。</p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>由于二叉树中节点包含有数据元素、左子树根、右子树根及双亲等信息，因此可以用<strong>三叉链表</strong>或<strong>二叉链表</strong>(即一个节点含有三个指针或两个指针)来存储二叉树，链表的头指针指向二叉树的根节点。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015135005935.png" alt="image-20231015135005935"></p><blockquote><p>三个指针一个指向双亲节点，另外两个指向左右孩子。</p></blockquote><blockquote><p>空指针也占用一个存储单元。</p></blockquote><blockquote><p>当二叉树包含k个结点时，链表中每个结点有两个孩子指针，共2k个，每个指针表示了一个父子关系。非空二叉树中除了跟结点外，每个结点都有.唯一的父结点，因此2k个孩子指针中用k-1个表示了结点的父子关系，其余的k+1个孩子指针都为空指针。</p></blockquote><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>◆一颗非空的二叉树由根节点、左子树、右子树三部分组成。遍历这三E部分，也就遍历了整颗二叉树。这三部分遍历的基本顺序是先左子树后右子树，但根节点顺序可变，<strong>以根节点访问的顺序为准有下列三种遍历方式</strong>:</p><p><strong>先序(前序)遍历</strong>:根左右。</p><p><strong>中序遍历</strong>:左根右。</p><p><strong>后序遍历</strong>:左右根。</p><p>示例:前序: 12457836 中序: 42785136 后序: 48752631</p><blockquote><p>中序、后序从叶节点开始访问。</p></blockquote><p>◆层次遍历:按层次，从上到下，从左到右。◆反向构造_ &#x3D;叉树:仅仅有前序和后序是无法构造二叉树的，必须要是和中序遍历的集合才能反向构造出二叉树。构造时，前序和后序遍历可以确定根节点，中序遍历用来确定根节点的左子树节点和右子树节点，而后按此方法进行递归，直至得出结果。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015135239186.png" alt="image-20231015135239186"></p><h3 id="反向构造二叉树"><a href="#反向构造二叉树" class="headerlink" title="反向构造二叉树"></a>反向构造二叉树</h3><p>仅仅有前序和后序是无法构造二叉树的，<strong>必须要是和中序遍历的集合才能反向构造出二叉树</strong>。</p><blockquote><p>中序+前序或 中序+后续 才能反向构造二叉树。</p></blockquote><p>构造时，前序和后序遍历可以确定根节点，<strong>中序遍历用来确定根节点的左子树节点和右子树节点</strong>，而后按此方法进行递归，直至得出结果。</p><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p>一个高度为h的满二叉树的结点总数为2^h-1, 从根结点开始，自上而下、同层次结点从左至右，对结点按照顺序依次编号，即根结点编号为1,其左、右孩子结点编号分别为2和3,再下一层从左到右的编号为4，5，6, 7,依此类推。那么，在一棵满二叉树中，对于编号为m和n的两个结点，若n&#x3D;2m+1，则(D)</p><p>A.m是n的左孩子</p><p>B.m是n的右孩子</p><p> C.n是m的左孩子 </p><p>D.n是m的右孩子</p><p>某二叉树如图所示，若进行顺序存储(即用一维数组元素存储该二叉树中的结点且通过下标反映结点间的关系，例如，<strong>对于下标为i的结点,其左孩子的下标为2i、右孩子的下标为2i+1</strong>)，则该数组的大小至少为(D) ;若采用三叉链表存储该二叉树(各个结点包括结点的数据、父结点指针、左孩子指针、右孩子指针)，则该链表的所有结点中空指针的数目为(B)。 </p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142322242.png" alt="image-20231015142322242"></p><p>A.6B.10C.12.D.15A.6B.8C.12D.14</p><blockquote><p>把上图二叉树补为完全二叉树。2^4-1&#x3D;15。</p><p>一共有6个节点，每个节点有三个指针域。</p></blockquote><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>引入线索二叉树是为了<strong>保存二叉树遍历时某节点的前驱节点和后继节点的信息</strong>，二叉树的链式存储只能获取到某节点的左孩子和右孩子结点，无法获取其遍历时的前驱和后继节点，因此可以<strong>在链式存储中再增加两个指针域【四叉链表】</strong>，使其分别指向前驱和后继节点，但这样太浪费存储空间，考虑下述实现方法:</p><p>若<strong>n个节点的二叉树使用二叉链表存储，则必然有n+1个空指针域</strong>，利用这些空指针域来存放节点的前驱和后继节点信息，为此，需要增加两个标志，以区分指针域存放的到底是孩子结点还是遍历节点，如下:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142736066.png" alt="image-20231015142736066"></p><p>若二叉树的二叉链表采用上述结构, 则称为<strong>线索链表</strong>, 其中指向前驱、后继节点的指针称为线索，加上线索的二叉树称为线索二叉树。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142906222.png" alt="image-20231015142906222"></p><h3 id="哈夫曼树-x2F-最优二叉树【考点】"><a href="#哈夫曼树-x2F-最优二叉树【考点】" class="headerlink" title="哈夫曼树&#x2F;最优二叉树【考点】"></a>哈夫曼树&#x2F;最优二叉树【考点】</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>最优二叉树又称为哈夫曼树，是一类<strong>带权路径长度最短的树</strong>，相关概念如下:</p><blockquote><p>一个节点到另外一个结点的通路叫路径。</p></blockquote><p>◆ 路径:树中一个结点到另一个结点之间的通路。</p><p>◆结点的路径长度:路径上的分支数目。</p><p>◆树的路径长度:<strong>根节点到达每一个叶子节点之间的路径长度之和</strong>。</p><p>◆权:<strong>节点代表的值</strong>。</p><p>◆结点的带权路径长度:<strong>该结点到根结点之间的路径长度乘以该节点的权值</strong>。</p><p>◆树的带权路径长度(<strong>树的代价</strong>):<strong>树的所有叶子节点的带权路径长度之和</strong>。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015143629621.png" alt="image-20231015143629621"></p><h4 id="哈夫曼树的求法"><a href="#哈夫曼树的求法" class="headerlink" title="哈夫曼树的求法"></a>哈夫曼树的求法</h4><p>给出一组权值，<strong>将其中两个最小的权值作为叶子节点，其和作为父节点，组成二叉树，而后删除这两个叶子节点权值，并将父节点的值添加到该组权值中</strong>。重复进行上述步骤，直至所有权值都被使用完。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015144052502.png" alt="image-20231015144052502"></p><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>若需要构造哈夫曼编码(要保证<strong>左节点值小于右节点的值</strong>，才是<strong>标准的哈夫曼树</strong>) <strong>将标准哈夫曼树的左分支设为0,右分支设为1,写出每个叶节点的编码</strong>，会发现，哈夫曼编码前缀不同，因此不会混淆，同时也是最优编码。</p><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015150748271.png" alt="image-20231015150748271"></p><p>答案：AC</p><h3 id="查找二叉树（排序二叉树）【考点】"><a href="#查找二叉树（排序二叉树）【考点】" class="headerlink" title="查找二叉树（排序二叉树）【考点】"></a>查找二叉树（排序二叉树）【考点】</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015154438092.png" alt="image-20231015154438092"></p><p>◆查找二叉树上的每个节点都存储一个值，且<strong>每个节点的所有左孩子结点值都小于父节点值，而所有右孩子结点值都大于父节点值</strong>，是一个有规律排列的二叉树，这种数据结构可以<strong>方便查找</strong>【每一次都把查找范围缩小一半】、插入等数据操作。</p><p>◆二叉排序树的查找效率取决于二叉排序树的深度，<strong>对于结点个数相同的二叉排序树，平衡二叉树的深度最小</strong>，而<strong>单枝树的深度是最大的，故效率最差</strong>。【深度越大比较的次数越多】</p><p>◆平衡二叉树又称为<strong>AVL</strong>树【查找效率最高，深度最小】，它或者是一棵空树，或者是具有下列性质的二叉树。它的左子树和右子树都是平衡二叉树，<strong>且左子树和右子树的高度之差的绝对值不超过1</strong>。若将二叉树结点的<strong>平衡因子(Balance Factor, BF)定义为该结点左子树的高度减去其右子树的高度</strong>，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要树上有一个结点的平衡因子的绝对值大于1,则该二叉树就是不平衡的。</p><h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><p>某二叉树的先序遍历列为cabfedg,中序遍历序列为abcdefg,则二叉树是(C)。</p><p>A.完全二叉树</p><p>B.最优二叉树</p><p>C.平衡二叉树</p><p>D.满二叉树</p><blockquote><p>通过cabfedg确定c是根节点，进而把abcdefg分为左右子树：左子树：ab，右子树：defg；</p><p>通过前序遍历ab知道a是根结点，fedg知道f是右子树根节点。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015155253456.png" alt="image-20231015155253456"></p><p>答案：C</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>◆无向图:图的结点之间连接线是<strong>没有箭头的，不分方向</strong>。</p><p>◆有向图:图的结点之间<strong>连接线是箭头，区分A到B，和B到A是两条线</strong>。</p><p>◆完全图:无向完全图中，<strong>节点<u>两两之间</u>都有连线</strong>，n个结点的连线数为（n-1）+(n-2)+…+1&#x3D; n(n-1)&#x2F;2;有向完全图中，节点两两之间都有互通的两个箭头，n个节点的连线数为n(n-1)。</p><p>◆度、出度和入度:顶点的度是<strong>关联与该顶点的边的数目</strong>。在有向图中，<u>顶点的度为出度和入度之和</u>。</p><p>◆路径:存在一条通路，可以从一个顶点到达另一个顶点。</p><p>◆子图:<strong>有两个图G&#x3D;(V, E)和G’&#x3D;(V’, E’)，如果V’∈V且E’∈E，则称G’为G的子图</strong>。</p><blockquote><p>V是定点结合，E是边的集合。</p></blockquote><p>◆连通图和连通分量:<strong>针对无向图</strong>。若从顶点v到顶点u之间是有路径的，则说明v和u之间是连通的，若无向图中任意两个顶点之间都是连通的，则称为连通图。无向图G的<u>极大连通子图</u>称为其连通分量。</p><p>◆强连通图和强连通分量:<strong>针对有向图</strong>。若有向图任意两个顶点间都互相存在路径，即存在v到u，也存在u到v的路径，则称为强连通图。有向图中的极大连通子图称为其强连通分量。</p><p>◆网:<strong>边带权值的图称为网</strong>。</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p><strong>邻接矩阵</strong>:假设一个图中有<strong>n个节点， 则使用n阶矩阵来存储这个图中各节点的关系,规则是若节点i到节点j有连线，则矩阵Ri,j&#x3D;1, 否则为0</strong>，示例如下图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015165419622.png" alt="image-20231015165419622"></p><blockquote><p>无向图的邻接矩阵是一个对角阵。</p></blockquote><p>适合边比较多的图。</p><p><strong>邻接链表</strong>:用到了两个数据结构,先用一个一维数组将图中所有顶点存储起来，而后，对此一维数组的每个顶点元素，使用链表挂上其出度到达的结点的编号和权值，示例如下图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015165801499.png" alt="image-20231015165801499"></p><p>存储特点:<strong>图中的顶点数决定了邻接矩阵的阶和邻接表中的单链表数目，边数的多少决定了单链表中的结点数</strong>，<strong>而不影响邻接矩阵的规模</strong>，因此采用何种存储方式与有向图、无向图没有区别，要看图的边数和顶点数，<strong>完全图适合采用邻接矩阵存储</strong>。</p><blockquote><p>有向图只考虑出度。</p></blockquote><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>◆图的遍历是<strong>指从图的任意节点出发</strong>，<strong>沿着某条搜索路径对图中所有节点进行访问且只访问一次</strong>,分为以下两种方式:</p><blockquote><p>图的遍历方式不唯一。</p></blockquote><p>◆深度优先遍历:<strong>从任一顶点出发,遍历到底，直至返回，再选取任一其他节点出发</strong>，重复这个过程直至遍历完整个图;</p><p>◆广度优先遍历:先访问完一个顶点的所有邻接顶点，<strong>而后再依次访问其邻接顶点的所有邻接顶点</strong>，类似于层次遍历。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015170314834.png" alt="image-20231015170314834"></p><h3 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h3><p>假设有n个节点，那么这个图的最小生成树有n-1条边(不会形成环路，是树非图)，这n-1条边应该会将所有顶点都连接成一个树，井且这些边的权值之和最小，因此称为最小生成树。共有下列两种算法:</p><h4 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h4><p><strong>普里姆算法</strong>:从<strong>任意顶点出发，找出与其邻接的边权值最小的，此时此边的另外一个顶点自动加入树集合中，而</strong><strong>后再从<u>这个树集合的所有顶点</u>中找出与其邻接的边权值最小的</strong>，同样此边的另外一个顶点加入树集合中，依次递归，直至图中所有顶点都加入树集合中，此时此树就是该图的最小生成树。普里姆算法的时间复杂度为0(n^2)，<strong>与图中的边数无关，因此该算法适合于求边稠密的网的最小生成树</strong>。</p><blockquote><p>最小生成树不唯一。但最终的权值之和相等。在面临多个相同的权值时，对权值的选择要保证不能形成一个环，如果形成一个环，既不符合定义了。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015170655573.png" alt="image-20231015170655573"></p><h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><p>克鲁斯卡尔算法(推荐) :这个算法是<strong>从边出发的</strong>，因为本质是选取权值最小的n-1条边，因此，就将边按权值大小排序，依次选取权值最小的边，直至囊括所有节点，要注意，每次选边后要检查<strong>不能形成环路</strong>。克鲁斯卡尔算法的时间复杂度为0(eloge)，与图中的顶点数无关，因此该算法<strong>适合于求边稀疏的网的最小生成树</strong>。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015171605178.png" alt="image-20231015171605178"></p><blockquote><p>Prim算法从扩展顶点开始，每次总是“贪心的”选择与当前顶点集合中距离域短的顶点，而Kruscal算法从扩展边开始，每次总是“ 贪心的”选择剩余的边中最小权重的边，因此两个算法都是基于贪心策略进行的。Prim算法的时间复杂度为0( n2)，其中n为图的顶点数，该算法的计算时间与图中的边数无关，因此该算法适合于求边稠密的图的最小生成树；</p><p>Kruscal算法的时间复杂度为0( mlgm)，其中m为图的边数，该算法的计算时间与图中的顶点数无关，因此该算法适合于求边稀疏的图的最小生成树。当图稠密时，用Prim算法效率更高。但若事先没有关于图的拓扑特征信息时，无法判断两者的优劣。由于一个图的最小生成树可能有多棵，因此不能保证用这两种算法得到的是同一棵最小生成树。</p></blockquote><h3 id="拓扑序列【考点】"><a href="#拓扑序列【考点】" class="headerlink" title="拓扑序列【考点】"></a>拓扑序列【考点】</h3><p>若<strong>图中一个节点入度为0，则应该最先执行此活动，而后删除掉此节点和其关联的有向边，再去找图中其他没有入度的结点，执行活动，依次进行</strong>，示例如下(有点类似于进程的前趋图原理)</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015171944618.png" alt="image-20231015171944618"></p><h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172250039.png" alt="image-20231015172250039"></p><p>答案：AB</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172257703.png" alt="image-20231015172257703"></p><p>答案：A</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172520892.png" alt="image-20231015172520892"></p><p>答案：CA</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172749299.png" alt="image-20231015172749299"></p><p>答案:C</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>◆顺序查找的思想:将待查找的关键字为key的元素从头到尾与表中元素进行比较，如果中间存在关键字为key的元素，则返回成功;否则，则查找失败。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015173203799.png" alt="image-20231015173203799"></p><p>时间复杂度为O(n);</p><h2 id="折半查找【考点】"><a href="#折半查找【考点】" class="headerlink" title="折半查找【考点】"></a>折半查找【考点】</h2><p>◆只适用于待查找序列中的元素是<strong>有序排列</strong>的情况。</p><p>◆设查找表的元素存储在一维数组r[1..n]中，在表中元素已经按照关键字递增(或递减)方式排序的情况下，进行折半查找的方法是:</p><p>1、首先将待查元素的关键字(key) 值与表r中间位置上(下标为mid)记录的关键字进行比较，若相等，则查找成功;</p><p>2、若key&gt;r[mid].key，则说明待查记录只可能在后半个子表r[mid+1..n]中，下一步应在后半个子表中查找;</p><p>3、若key&lt;r[mid].key， 说明待查记录只可能在前半个子表r[1..mid-1]中，下一步应在r的前半个子表中查找;</p><p>4、重复上述步骤，逐步缩小范围，直到查找成功或子表为空失败时为止。</p><p>要注意两点:<u><strong>中间值位置求出若为小数，应该向下取整</strong></u>，即4.5&#x3D;4， 非四舍五入;中间值已经比较过不相等，在划分下一次比较区间时，<strong>无需将中间值位置再纳入下一次比较区间</strong>。</p><p>时间复杂度为O(log2n)。</p><h2 id="哈希表-x2F-散列表【考点】"><a href="#哈希表-x2F-散列表【考点】" class="headerlink" title="哈希表&#x2F;散列表【考点】"></a>哈希表&#x2F;散列表【考点】</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>哈希表通过一个以<strong>记录的关键字</strong>为自变量的函数(称为<strong>哈希函数</strong>)得到<strong>该记录的存储地址</strong>，所以在哈希表中进行查找操作时，需要用同一哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获得有关信息再判定查找是否成功。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>当多个关键字产生同一个地址时，则产生<strong>哈希冲突</strong>。</p><blockquote><p>解决哈希冲突的算法sha-256，md5</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015180624273.png" alt="image-20231015180624273"></p><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>哈希函数产生了冲突的解决方法如下:</p><p><a href="https://www.bilibili.com/video/BV1D54y177MP?t=10.0">https://www.bilibili.com/video/BV1D54y177MP?t=10.0</a></p><p>1.<strong>开放定址法</strong>: Hi&#x3D;(H(key)+di) % m，i&#x3D;1, 2….. k&lt;(k&lt;&#x3D;m-1).其中，H(key)为哈希函数; m为哈希表表长; di为增量序列。</p><p>常见的增量序列有以下3种。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015181550933.png" alt="image-20231015181550933"></p><p><strong>线性探测法：</strong></p><p>添加元素时，使用散列函数确定元素的插入位置，如果此空间有值：</p><p>1.该值是所要插入元素的关键码，不进行插入。</p><p>2.产生冲突，依次查看其后的下一个桶，如果发现空位置插入新元素。</p><p>注意：</p><p>散列表的载荷因子：a &#x3D; 插入元素个数 &#x2F; 散列表的长度</p><p>a是散列表装满程度的标志因子。对于开放地址法，载荷因子非常重要，应严格限制在 0.7~0.8 以下。超过 0.8 ，查表时的CPU缓存按照指数曲线上升。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>2.链地址法。它在查找表的每一个记录中增加一个链域，链域中存放下一个具有相同哈希函数值的记录的存储地址。利用链域，<strong>就把若干个发生冲突的记录链接在一个链表内</strong>。当链域的值为NULL时，表示已没有后继记录了。因此，对于发生冲突时的查找和插入操作就跟线性表一样了。</p><p>3.再哈希法:在同义词发生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生聚集现象，但增加了计算时间。</p><p>4.建立一个公共溢出区。无论由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入到公共溢出区中。</p><h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015181950594.png" alt="image-20231015181950594"></p><p>答案：A</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015182204804.png" alt="image-20231015182204804"></p><p>答案：B</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>◆要注意的是，前提条件是<strong>前i-1个元素是有序的，第1个元素依次从第i-1个元素往前比较，直到找到一个比第1个元素值小的元素，而后插入，插入位置及其后的元素依次向后移动。</strong></p><p>◆当给出一队无序的元素时，首先，应该将第1个元素看做是一个有序的队列，而后从第2个元素起，按插入排序规则，依次与前面的元素进行比较，直到找到一个小于他的值，才插入。示例如下图所示:</p><p>下图中，59依次向前比较，先和68比较，再和57比较,发现57比他小，才插入。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015182516357.png" alt="image-20231015182516357"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>针对较大的数据排序。</p></blockquote><p>◆希尔排序又称“<strong>缩小增量排序</strong>”，是<strong>对直接插入排序方法的改进</strong>。</p><p>◆希尔排序的基本思想是:先<strong>将整个待排记录序列分割成若干子序列</strong>，然后<strong>分别进行直接插入排序</strong>，待整个序列中的记录<strong>基本有序时</strong>，<strong>再对全体记录进行一次直接插入排序</strong>。</p><p>◆具体做法是:<strong>先取一个小于n的整数d1作为第一个增量</strong> ,把文件的全部记录分成d1个组，<strong>将所有距离为d1倍数的记录放在同一个组中，在各组内进行直接插入排序</strong>;然后取第二个增量d2(d2 &lt;d1),重复上述分组和排序工作，依此类推，直至所取的增量di&#x3D;1(di &lt;di-1&lt;… &lt;d2 &lt;d1),即所有记录放在同一组<strong>进行直接插入排序为止</strong>。</p><p>◆按上述，希尔排序实际是<strong>为了解决大数据的排序问题</strong>，当待排序的数据很多时，使用直接插入排序效率很低，因此，采取分组的方法，使问题细化，可以提高效率,适用于多数据。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030201350758.png" alt="image-20231030201350758"></p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p><a href="https://www.bilibili.com/video/BV1Lp4y1Y75f?t=229.0">https://www.bilibili.com/video/BV1Lp4y1Y75f?t=229.0</a></p><p>◆n个记录进行简单选择排序的基本方法是:<strong>通过n - i(1&lt;&#x3D;i&lt;&#x3D;n)次关键字之间的比较,从n-i+ 1个记录中选出关键字最小的记录，并和第i个记录进行交换</strong>，当i等于n时所有记录有序排列。</p><p>◆按上述，<strong>本质就是每次选择出最小的元素进行交换</strong>，主要是选择比较过程,交换过程只有一次。示例如下:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030202554023.png" alt="image-20231030202554023"></p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231102170901023.png" alt="image-20231102170901023"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>对于 $n$ 个元素的关键字序列 </p><p>$$K_1, K_2, …, K_n$$</p><p>, 当且仅当满足下列关系时称其为堆, 其中 $2i$ 和 $2i+1$ 需不大于 $n$ 。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030203649882.png" alt="image-20231030203649882"></p><blockquote><p>左侧为小根堆：，右侧为大根堆。</p></blockquote><p>堆排序的基本思想是: 对一组待排序记录的关键字, 首先按堆的定义排成一个序列 (即建立初始堆), 从而可以输出堆顶的最大关键字 (对于大根堆而言), 然后将剩余的关键字再调整成新堆, 便得到次大的关键字, 如此反复, 直到全部关键字排成有序序列为止。</p><p>为序列(55,60,40,10,80,65,15,5,75) 建立初始大根堆的过程如图所示:</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030204036239.png" alt="image-20231030204036239"></p><blockquote><p>找到最后一个非叶子节点，比较该根节点和其孩子节点大小，并交换位置。</p></blockquote><p>◆由上图可知，<strong>首先将给出的数组按完全二叉树规则建立</strong>，而后，找到此完全二叉树的<strong>最后一个非叶子节点(也即最后一颗子树)<strong>，比较</strong>此非叶子节点和其两个孩子结点的大小</strong>，若小，则与其孩子结点中最大的结点进行交换;依据此规则再去找倒数第二个非叶子节点;这是只有一层的情况，当涉及到多层次时,又打破了之前的堆，因此,又要进行变换。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030204741673.png" alt="image-20231030204741673"></p><p> ◆建立初始堆后，开始排序，每次取走堆顶元素(必然是最大的)，而后将堆中最后一个元素移入堆顶，而后按照初始建堆中的方法与其孩子结点比较大小,依次向下判断交换成为一个新的堆，再取走堆顶元素，重复此过程。</p><p>◆堆排序适用于在多个元素中找出前几名的方案设计，因为堆排序是选择排序,而且选择出前几名的效率很高。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030205026957.png" alt="image-20231030205026957"></p><p>◆n个记录进行冒泡排序的方法是:首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序,则交换这两个记录的值，然后比较第二个记录和第三个记录的关键字,依此类推，直至第n - 1个记录和第n个记录的关键字比较过为止。</p><p>上述过程称为<strong>一趟冒泡排序</strong>，<strong>其结果是关键字最大的记录被交换到第n个记录的位置上</strong>。然后进行第二趟冒泡排序，<strong>对前n-1个记录进行同样的操作，其结果是关键字次大的记录被交换到第n - 1个记录的位置上</strong>。最多进行n-1趟,所有记录有序排列。<strong>若在某趟冒泡排序过程没有进行相邻位置的元素交换处理，则可结束排序过程</strong>。</p><p>◆示例给的是<strong>从后往前排序，也是可以的</strong>，需要从最后两个元素开始进行比较，将较小的元素交换到前面去，依次进行比较交换。比较是为了交换，交换次数很多。区分冒泡排序和简单选择排序。</p><blockquote><p>简单排序只有一次交换；冒泡排序有多次交换，效率比较低。</p></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030212746661.png" alt="image-20231030212746661"></p><p>◆快速排序是将n个记录分成两块，再递归，实际分成两块的方法如图所示:设定一个基准为57,设定<strong>两个指针</strong>high&#x3D;1, low&#x3D;n, 从low指向的第n个元素开始，与基准值进行比较，若小于基准值，则与基准进行交换low–,此时，转而从high指向的第1个元素开始和基准值进行比较，若大于基准值，则和基准值进行交换，此时，又转而从low指向的值和基准进行比较,重复上述过程。</p><blockquote><p>基准值越靠近中位数越好。默认为待排序序列第一个值。</p></blockquote><blockquote><p>每一次交换元素后，指针都会变化。</p></blockquote><p>◆要注意的是:每次都是和基准值进行比较，因此最终是以基准值为中间，将队列分成两块。只有当和基准值发生了交换，才变换high和low指针的计数，否则，会一直low–下去。</p><p>◆上图中，最终以57为界，左边都是小于57的元素,右边都是大于57的元素，完成一次快速排序,接着对两块再分别进行递归即可。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>◆所谓“归并，是将两个或两个以上的有序文件合并成为一个新的有序文件。归并排序的一种实现方法是把<strong>一个有n个记录的无序文件看成是由n个长度为1的有序子文件组成的文件，然后进行两两归并</strong>，得到[n&#x2F;21]个长度为2或1的有序文件,再两两归并，如此重复，直至最后形成包含n个记录的有序文件为止。这种反复将两个有序文件归并成一个有序文件的排序方法称为<strong>两路归并排序</strong>。</p><p>◆要仔细理解上述过程，一般归并排序都是用来合并多个线性表的，<strong>对单列数据，二路归并排序可以对元素进行两两合并</strong>，示例如下:</p><p>◆对第三次归并，将52与28比较，28小,放入新表头, 52再与33比较, 33放入新表，52再与72比较, 52放入新表, 57再与72比较，57放入新表….</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030213950141.png" alt="image-20231030213950141"></p><h2 id="基数排序【不考】"><a href="#基数排序【不考】" class="headerlink" title="基数排序【不考】"></a>基数排序【不考】</h2><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030214531213.png" alt="image-20231030214531213"></p><p>基数排序是基于多个关键字来进行多轮排序的，本质也是将问题细分，如图例子，分别按个位、干位、百位的大小作为关键字进行了三轮排序，最终得出结果。</p><h2 id="内部排序算法总结【重要】"><a href="#内部排序算法总结【重要】" class="headerlink" title="内部排序算法总结【重要】"></a>内部排序算法总结【重要】</h2><blockquote><p>内部排序就是在内存内排序。</p></blockquote><p>(1)若待排序的记录数目n较小，可采用直接插入排序和简单选择排序。由于直接插入排序所需的记录移动操作较简单选择排序多，因此当记录本身信息量较大时，用简单选择排序方法较好。</p><p>(2)若待排序记录按关键字<strong>基本有序，则宜采用直接插入排序或冒泡排序</strong>。</p><p>(3)<strong>当n很大且关键字的位数较少时，采用链式基数排序较好</strong>。</p><p>(4)若n较大，则应采用时间复杂度为O(nlogn)的排序方法，例如快速排序、堆排序或归并排序。</p><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030214628503.png" alt="image-20231030214628503"></p><blockquote><p>稳定性是指在排序时，重复的元素位置不改变。</p></blockquote><blockquote><p>O(1)是指常量空间，即所需要的空间几乎不变化。</p></blockquote><blockquote><p>log默认以2为底。快速排序有二分的思想，时间复杂度为nlogn.</p></blockquote><blockquote><p>归并排序需要一个新表，需要辅助空间。</p></blockquote><p><img src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231030215546973.png" alt="image-20231030215546973"></p><blockquote><p>排序是一类最基本的操作，因此要求考生熟悉一些典型的排序算法，包括其算法思想、时空复杂度以及应用场合。若数据基本有序，插入排序应该是最佳选择，输入数据是否有序对归并和计数排序算法并没有影响。对传统的快速排序算法，输入数据有序反而使其效率最低。若关键字取值范围较小，则计数排序是最佳选择，因为在该情况下该管注的时间旨垫底为线性时间</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>11.文老师-软件工程基础知识.md</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-10-14T12:06:15.000Z</published>
    <updated>2023-10-28T01:38:53.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="信息系统生命周期"><a href="#信息系统生命周期" class="headerlink" title="信息系统生命周期"></a>信息系统生命周期</h1><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015193753582.png" alt="image-20231015193753582"></p><p>◆软件工程基本原理:用分阶段的生命周期计划严格管理、坚持进行阶段评审、实现严格的产品控制、采用现代程序设计技术、结果应能清楚的审查、开发小组的人员应少而精、承认不断改进软件工程实践的必要性。</p><p>◆**软件工程的基本要素:<u>方法、工具过程</u>**。</p><p>◆软件生存周期:可行性分析与项目开发计划、需求分析、概要设计(选择系统解决方案，规划子系统)、详细设计(设计子系统内部具体实现)、编码、测试、维护。</p><h2 id="信息系统五阶段生命周期【考点】"><a href="#信息系统五阶段生命周期【考点】" class="headerlink" title="信息系统五阶段生命周期【考点】"></a>信息系统五阶段生命周期【考点】</h2><p>◆1.系统规划阶段:任务是对组织的环境、目标及现行系统的状况进行<strong>初步调查</strong>,根据组织目标和发展战略确定信息系统的发展战略，<strong>对建设新系统的需求做出分析和预测</strong>，同时考虑建设新系统所受的各种约束，研究建设新系统的必要性和可能性。根据需要与可能，给出制建系统的备选方案。</p><p>输出:**可行性研究报告、<u>系统设计任务书</u>**。</p><p>◆2.系统分析阶段: 任务是根据系统设计任务书所确定的范围，<strong>对现行系统进行详细调查</strong>，描述现行系统的业务流程，指出现行系统的局限性和不足之处,确定新系统的基本目标和逻辑功能要求，即提出新系统的逻辑模型。系统分析阶段又称为<strong>逻辑设计阶段</strong>。这个阶段是<strong>整个系统建设的关键阶段</strong>，也是信息系统建设与一般工程项目的重要区别所在。<strong>得出系统的逻辑模型</strong>。</p><p>输出:系统说明书【也称需求说明书】。</p><p>◆3.系统设计阶段:系统分析阶段的任务是回答系统“做什么”的问题，而<strong>系统设计阶段要回答的问题是”怎么做”</strong>。该阶段的任务是根据系统说明书中规定的功能要求，具体设计实现逻辑模型的技术方案，也就是设计新系统的物理模型。这个阶段又称为<strong>物理设计阶段</strong>，可分为<strong>总体设计(概要设计)和详细设计</strong>两个子阶段。</p><p>输出**:系统设计说明书(概要设计、详细设计说明书)**</p><p>◆4.系统实施阶段:是将设计的系统付诸实施的阶段。这一阶段的任务包括计算机等设备的购置、安装和调试、程序的编写和调试、人员培训、数据文件转换、系统调试与转换等。这个阶段的特点是几个互相联系、互相制约的任务同时展开，必须精心安排、合理组织。系统实施是按实施计划分阶段完成的，每个阶段应写出实施进展报告。系统测试之后写出<strong>系统测试分析报告</strong>。</p><p>输出:<strong>实施进展报告、系统测试分析报告</strong>。</p><p>◆5.系统运行和维护阶段:系统投入运行后，需要经常进行维护和评价，记录系统运行的情况，根据一定的规则对系统进行必要的修改，评价系统的工作质量和经济效益。</p><h1 id="能力成熟度模型"><a href="#能力成熟度模型" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h1><h2 id="能力成熟度模型CMM"><a href="#能力成熟度模型CMM" class="headerlink" title="能力成熟度模型CMM"></a>能力成熟度模型CMM</h2><blockquote><p>用来衡量公司开发软件的能力。</p></blockquote><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015194859347.png" alt="image-20231015194859347"></p><h2 id="能力成熟度模型集成CMMI"><a href="#能力成熟度模型集成CMMI" class="headerlink" title="能力成熟度模型集成CMMI"></a>能力成熟度模型集成CMMI</h2><p>是若干过程模型的综合和改进，不仅仅软件，而是支持<strong>多个工程学科和领域的</strong>、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率。</p><p>CMMI两种表示方法:</p><p>(1)<strong>阶段式模型</strong>【考点】:类似于CMM，它关注组织的成熟度，五个成熟度模型如下:</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015195644955.png" alt="image-20231015195644955"></p><p>（2）连续式模型:关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力等级。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200040621.png" alt="image-20231015200040621"></p><h1 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h1><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><blockquote><p>开发中小型系统较多，现在逐渐被淘汰。适合需求明确的情况。</p></blockquote><p>◆瀑布模型(SDLC):瀑布模型是一个经典的软件生命周期模型,一般将软件开发分为:可行性分析(计划)、需求分析、 软件设计(概要设计、详细设计)、编码(含单元测试)、测试、运行维护等几个阶段。</p><p>◆瀑布模型特点</p><p>(1)从<strong>上一项开发活动接受该项活动的工作对象作为输入</strong>。</p><p>(2)利用这一输入， <strong>实施该项活动应完成的工作内容</strong>。</p><p>(3)给出该项活动的<strong>工作成果，作为输出</strong>传给下一项开发活动。</p><p>(4)对<strong>该项活动的实施工作成果进行评审</strong>。若其工作成果得到确认，则继续进行下一项开发活动;否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200121645.png" alt="image-20231015200121645"></p><h2 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h2><blockquote><p>螺旋模型和风险挂钩。</p></blockquote><p>◆螺旋模型是一个演化软件过程模型，将原型实现的迭代特征与线性顺序(瀑布)模型中控制的和系统化的方面结合起来。在螺旋模型中，软件开发是一系列的增量发布。</p><p>◆开发过程具有周期性重复的螺旋线状。四个象限分别标志每个周期所划分的四阶段:<strong>制订计划、<u>风险分析</u>、实施工程和客户评估</strong>。螺旋模型强调了风险分析，<strong>特别适用于庞大而复杂的、高风险的系统</strong>。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200443829.png" alt="image-20231015200443829"></p><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><blockquote><p>V模式认为每一阶段都应该进行测试。</p></blockquote><p>◆V模型从整体.上看起来，就是一个V字型的结构， 由左右两边组成。左边的下画线分别代表了需求分析、概要设计、详细设计、编码。右边的上画线代表了单元测试、集成测试、系统测试与验收测试。V模型的特点如下:</p><p>(1)单元测试的主要目的是针对编码过程中可能存在的各种错误;【单边】</p><p>(2)集成测试的主要目的是针对详细设计中可能存在的问题;【吉祥】</p><p>(3)系统测试主要针对概要设计，检查系统作为一个整体是否有效地得到运行;【膝盖】</p><p>(4)验收测试通常由业务专家或者用户进行，以确认产品能真正符合用户业务上的需要。【延续】</p><p>(5) V模型用于需求明确和需求变更不频繁的情形。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015200733419.png" alt="image-20231015200733419"></p><h2 id="原型化模型"><a href="#原型化模型" class="headerlink" title="原型化模型"></a>原型化模型</h2><p>◆原型化模型第一步就是<strong>创建一个快速原型</strong>，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论和分析，最终弄清楚当前系统的需求，进行了充分的了解之后，在原型的基础上开发出用户满意的产品。</p><blockquote><p>适用于需求不明确的情况。</p></blockquote><p>◆原型法认为在很难一下子全面准确地提出用户需求的情况下，原型应当具备的特点如下。</p><p>(1)实际可行</p><p>(2)具有最终系统的基本特征</p><p>(3)构造方便、快速，造价低。原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的。</p><p><strong>例题</strong>以下关于快速原型模型优点的叙述中，不正确的是（)</p><p>A有助于满足用户的真实需求</p><p>B适用于大型软件系统的开发</p><p>C开发人员快速开发出原型系统，因此可以加速软件开发过程。节约开发成本</p><p>D原型系统已经通过与用户的交互得到验证，因此对应的规格说明文档能正确描述用户需求</p><blockquote><p>快速原型模型比较适合于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。<strong>开发大型软件系统适用螺旋模型或者RUP模型</strong>。</p></blockquote><h2 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h2><p>◆增量模型:首先开发核心模块功能，而后与用户确认，之后再开发次核心模块的功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发,优先级最高的服务最先交付。</p><p>◆特点:但由于并不是从系统整体角度规划各个模块，因此不利于模块划分。难点在于如何将客户需求划分为多个增量。与原型不用的是增量模型的<strong>每一次增量版本都可作为独立可操作的作品</strong>，而原型的构造一般是为了演示。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015201403427.png" alt="image-20231015201403427"></p><h2 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h2><p>◆喷泉模型:是一种以用户需求为动力，以对象作为驱动的模型,适合于<strong>面向</strong><strong>对象</strong>的开发方法。使开发过程具有迭代性和无间隙性。</p><h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><p>基于构件的开发模型CBSD:利用<strong>预先包装的构件来构造应用系统</strong>。构件可以是组织内部开发的构件，也可以是商品化成品软件构件。特点是增强了复用性，在系统开发过程中，会构建-个构件库, 供其他系统<strong>复用</strong>，因此可以提高可靠性，节省时间和成本。</p><h2 id="形式化方法模型"><a href="#形式化方法模型" class="headerlink" title="形式化方法模型"></a>形式化方法模型</h2><p>形式化方法模型:建立在<strong>严格数学基础</strong>上的一种软件开发方法,主要活动是生成计算机软件形式化的数学规格说明。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015201633281.png" alt="image-20231015201633281"></p><p>答案：A D</p><h1 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h1><h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><p>◆结构是指系统内各个组成要素之间的相互联系、相互作用的框架。</p><p>◆结构化方法也称为生命周期法,是-种传统的信息系统开发方法，由<strong>结构化分析</strong>(Structured Analysis,SA)、<strong>结构化设计</strong>(Structured Design, SD)和<strong>结构化程序设计</strong>(Structured Programming, SP) 三部分有机组合而成，其精髓是自顶向下、逐步求精和模块化设计。</p><blockquote><p>面向数据流。</p></blockquote><h3 id="结构化方法的主要特点"><a href="#结构化方法的主要特点" class="headerlink" title="结构化方法的主要特点"></a>结构化方法的主要特点</h3><p>(1)<strong>开发目标清晰化</strong>。结构化方法的系统开发遵循”用户第一”的原则。</p><p>(2)<strong>开发工作阶段化</strong>。每个阶段工作完成后，要<strong>根据阶段工作目标和要求进行审查</strong>，这使各阶段工作有条不紊地进行，便于项目管理与控制。</p><p>(3)<strong>开发文档规范化</strong>。结构化方法每个阶段工作完成后，要<strong>按照要求完成相应的文档</strong>，以保证各个工作阶段的衔接与系统维护工作的遍历。</p><p>(4)<strong>设计方法结构化</strong>。在系统分析与设计时，从整体和全局考虑，<strong>自顶向下地分解</strong>;在系统实现时,根据设计的要求，先编写各个具体的功能模块，然后，<strong>自底向上逐步实现整个系统</strong>。</p><h3 id="结构化方法的不足与局限"><a href="#结构化方法的不足与局限" class="headerlink" title="结构化方法的不足与局限"></a>结构化方法的不足与局限</h3><p>(1)<strong>开发周期长</strong>:按顺序经历各个阶段,直到实施阶段结束后，用户才能使用系统。</p><p>(2)<strong>难以适应需求变化</strong>:不适用于需求不明确或经常变更的项目。</p><p>(3)**很少考虑数据结构:**结构化方法是一 种面向过程，面向数据流的开发方法，很少考虑数据结构。</p><h3 id="结构化方法常用工具"><a href="#结构化方法常用工具" class="headerlink" title="结构化方法常用工具"></a>结构化方法常用工具</h3><p>结构化方法一般利用图形表达用户需求，常用工具有<strong>数据流图、数据字典、结构化语言、判定表以及判定树</strong>等。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>◆面向对象(Object-Oriented, OO)方法认为，客观世界是由各种对象组成的，<strong>任何事物都是对象，每一个对象都有自己的运动规律和内部状态，都属于某个对象类</strong>，是该对象类的一个元素。复杂的对象可由相对简单的各种对象以某种方式而构成，不同对象的组合及相互作用就构成了系统。</p><blockquote><p>类是对象的集合体，就像乘用车是汽车的一个对象。</p></blockquote><h3 id="面向对象方法的特点"><a href="#面向对象方法的特点" class="headerlink" title="面向对象方法的特点"></a>面向对象方法的特点</h3><p>(1)使用OO方法构造的系统具有<strong>更好的复用性</strong>【类的继承】，其关键在于建立一个全面、合理、统一的模型(<strong>用例模型和分析模型</strong>)。</p><p>(2) OO方法也划分阶段，但其中的<strong>系统分析、系统设计和系统实现</strong>三个阶段之间已经<strong>没有“缝隙”</strong>。也就是说，这<strong>三个阶段的界限变得不明确</strong>，某项工作既可以在前一个阶段完成，也可以在后一个阶段完成;前一个阶段工作做得不够细，在后一个阶段可以补充。</p><p>(3)面向对象方法可以<strong>普遍适用于各类信息系统的开发</strong>。</p><h3 id="面向对象方法的不足之处"><a href="#面向对象方法的不足之处" class="headerlink" title="面向对象方法的不足之处"></a>面向对象方法的不足之处</h3><p><strong>必须依靠一定的面向对象技术支持，在大型项目的开发上具有一定的局限性，<u>不能涉足系统分析以前的开发环节</u>。</strong></p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a><strong>现状</strong></h3><p>当前， 一些大型信息系统的开发，通常是<strong>将结构化方法和 OO方法结合起来</strong>。首先，使用结构化方法进行自顶向下的整体划分;然后，自底向上地采用 OO方法进行开发。因此，结构化方法和 OO方法仍是两种在系统开发领域中相互依存的、不可替代的方法。</p><h2 id="原型化方法"><a href="#原型化方法" class="headerlink" title="原型化方法"></a>原型化方法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>◆原型化方法也称为<strong>快速原型法</strong>，或者简称为<strong>原型法</strong>。它是一种根据用户初步需求，利用系统开发工具，<strong>快速地建立一个系统模型展示给用户</strong>，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。</p><p>◆按是<strong>否实现功能</strong>分类:分为水平原型(行为原型，功能的导航)【没有实现功能】、垂直原型(结构化原型，实现了部分功能)。</p><p>◆按<strong>最终结果</strong>分类:分为抛弃式原型【后续抛弃该原型】、演化式原型【后续在该原型基础上改进】。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015215139241.png" alt="image-20231015215139241"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>原型法可以使系统开发的周期缩短、成本和风险降低、速度加快，获得较高的综合开发效益。</p><p>原型法是<strong>以用户为中心来开发系统</strong>的，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加了用户的满意度，提高了系统开发的成功率。</p><p>由于用户参与了系统开发的全过程，<strong>对系统的功能和结构容易理解和接受</strong>，有利于系统的移交，有利于系统的运行与维护。</p><h3 id="原型法的不足之处"><a href="#原型法的不足之处" class="headerlink" title="原型法的不足之处"></a>原型法的不足之处</h3><p><strong>开发的环境要求高。管理水平要求高【指和客户交流的过程要求高】。</strong></p><p>◆由以上的分析可以看出，原型法的优点主要在于能更有效地确认用户需求。从直观上来看，原型法适用于那些需求不明确的系统开发。事实上，<strong>对于分析层面难度大、技术层面难度不大的系统，适合于原型法开发</strong>。</p><p>◆从严格意义上来说，目前的原型法不是一种独立的系统开发方法，而<strong>只是一种开发思想</strong>，它只支持在系统开发早期阶段快速生成系统的原型，没有规定在原型构建过程中必须使用哪种方法。因此，它不是完整意义上的方法论体系。这就注定了原型法必须与其他信息系统开发方法结合使用。</p><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p> 敏捷开发是一种<strong>以人为核心、迭代、循序渐进的开发方法</strong>，相对于传统软件开发方法的“非敏捷”，更<strong>强调程序员团队与业务专家之间的紧密协作、面对面的沟通(认为比书面的文档更有效)、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。</strong></p><blockquote><p>一般针对中小型项目。</p></blockquote><p>◆敏捷软件开发宣言:</p><p>1.个体和交互胜过过程和工具</p><p>2.可以工作的软件胜过面面俱到的文档</p><p>3.客户合作胜过合同谈判</p><p>4.响应变化胜过遵循计划</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015215429304.png" alt="image-20231015215429304"></p><p>◆结对编程:<strong>一个程序员开发，另一个程序在一旁观察审查代码</strong>，能够有效的提高代码质量，在开发同时对代码进行初步审查，共同对代码负责。</p><p>◆自适应开发:强调开发方法的<strong>适应性</strong>(Adaptive) 。不象其他方法那样有很多具体的实践做法，它更<strong>侧重为软件的重要性提供最根本的基础</strong>，并从更高的组织和管理层次来阐述开发方法为什么要具备适应性。</p><p>◆水晶方法:<strong>每一个不同的项目都需要一套不同的策略、约定和方法论</strong>。</p><p>◆特性驱动开发:是一套<strong>针对中小型软件开发项目的开发模式</strong>。是一个<strong>模型驱动的快速迭代开发过程</strong>，它强调的是简化、实用、易于被开发团队接受，适用于需求经常变动的项目。</p><p>◆极限编程XP:核心是<strong>沟通、简明、反馈和勇气</strong>。因为知道计划永远赶不上变化，XP<strong>无需开发人员在软件开始初期做出很多的文档</strong>。XP提<strong>倡测试先行</strong>，为了将以后出现bug的几率降到最低。</p><p>◆并列争球法SCRUM:是一种<strong>迭代的增量化过程</strong>，把<strong>每段时间(30天)一次的迭代称为一个“冲刺”</strong>，并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品。</p><blockquote><p>每30天更新一个版本。</p></blockquote><h2 id="统一过程-RUP"><a href="#统一过程-RUP" class="headerlink" title="统一过程(RUP)"></a>统一过程(RUP)</h2><p>提供了在开发组织中<strong>分派任务和责任的纪律化方法</strong>。它的目标是<strong>在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品</strong>。</p><p>◆3个显著特点:<u><strong>用例驱动、以架构为中心、迭代和增量</strong></u>。</p><blockquote><p>用例:指一个具体的实际的场景。</p></blockquote><p>◆4个流程:<strong>初始阶段、细化阶段、构建阶段和交付阶段</strong>。每个阶段结束时都要安排一次技术评审，以确定这个阶段的目标是否已经达到。</p><blockquote><p>起始阶段专注于项目的初创活动。</p><p>精化阶段理解了最初的领域范围之后，进行需求分析和架构演进。构建阶段关注系统的构建，产生实现模型。</p><p>移交阶段关注于软件提交方面的工作，产生软件增量。</p><p>产生阶段运行软件并监控软件的持续使用，提供运行环境的支持，提交并评估缺陷报告和变更请求。</p></blockquote><p>◆适用:<strong>一个通用过程框架</strong>，可以用于种类广泛的软件系统、不同的应用领域、不同的组织类型、不同性能水平和不同的项目规模。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015221026149.png" alt="image-20231015221026149"></p><h1 id="软件产品线"><a href="#软件产品线" class="headerlink" title="软件产品线"></a>软件产品线</h1><p>◆软件产品线是一个产品集合，这些产品<strong>共享一个公共的、可管理的特征集，这个特征集能满足特定领域的特定需求</strong>。软件产品线是一个十分适合专业的开发组织的软件开发方法，能有效地提高软件生产率和质量，缩短开发时间，降低总开发成本。</p><p>核心资源:包括所有产品所共用的软件架构，通用的构件、文档等。</p><p>产品集合:产品线中的各种产品。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015221451366.png" alt="image-20231015221451366"></p><h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><h2 id="软件复用"><a href="#软件复用" class="headerlink" title="软件复用"></a>软件复用</h2><p>◆软件复用是<strong>将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费</strong>。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是<strong>代码级复用</strong>，被复用的知识专指程序，后来扩大到包括<strong>领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面</strong>。</p><h2 id="逆向工程-1"><a href="#逆向工程-1" class="headerlink" title="逆向工程"></a>逆向工程</h2><p>软件的逆向工程是<strong>分析程序，力图在比源代码更高抽象层次上建立程序的表示过程</strong>，逆向工程是<strong>设计的恢复过程</strong>。逆向工程的四个级别:</p><p><strong>实现级</strong>:包括程序的抽象语法树、符号表、过程的设计表示。</p><p>结构级:包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构。</p><p><strong>功能级</strong>:包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型。</p><p><strong>领域级</strong>:包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如E-R模型。</p><p>其中，<strong>领域级抽象级别最高，完备性最低，实现级抽象级别最低，完备性最高。</strong></p><blockquote><p>完备性与具体实现相关，完备性越高与代码实现关系越高。</p></blockquote><p>◆与逆向工程相关的概念有重构、设计恢复、再工程和正向工程。</p><p>(1)重构是指在<strong>同一抽象级别上转换系统描述形式</strong>。</p><p>(2)设计恢复是指借助工具从<strong>已有程序中抽象出有关数据设计</strong>、总体结构设计和过程设计等方面的信息。</p><p>(3)再工程是指<strong>在逆向工程所获得信息的基础上，修改或重构已有的系统，产生系统的一个新版本</strong>。再工程是<strong>对现有系统的重新开发过程</strong>，<strong>包括逆向工程、新需求的考虑过程和正向工程三个步骤</strong>。它不仅能从已存在的程序中重新获得设计信息，而且还能使用这些信息来重构现有系统，以改进它的综合质量。在利用再工程重构现有系统的同时，一般会增加新的需求，包括增加新的功能和改善系统的性能。</p><p>(4)正向工程是指不仅从现有系统中恢复设计信息，<strong>而且使用该信息去改变或重构现有系统</strong>，以改善其整体质量。</p><p><img src="/../../pic/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231015222541672.png" alt="image-20231015222541672"></p><blockquote><p> 软件系统工具通常可以按软件过程活动将软件工具分为软件开发工具、软件维护工具、软件管理和软件支持工具。</p><p>软件开发工具:需求分析工具、设计工具、编码与排错工具。</p><p>软件维护工具:版本控制工具、文档分析工具、开发信息库工具、<strong>逆向工程工具</strong>、再工程工具。</p><p>软件管理和软件支持工具:项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;信息系统生命周期&quot;&gt;&lt;a href=&quot;#信息系统生命周期&quot; cla</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>10.算法分析与设计</title>
    <link href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20/"/>
    <id>http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20/</id>
    <published>2023-10-14T12:06:09.000Z</published>
    <updated>2023-11-02T08:34:20.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p>算法(Algorithm) 是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一 个或多个操作。 此外，一个算法还具有下列5个重要特性。</p><p>(1)<strong>有穷性</strong>。一个算法必须总是(对任何合法的输入值)在执行有穷步之后结束,且每一步都可在有穷时间内完成。</p><p>(2)<strong>确定性</strong>。算法中的每一条指令必须有确切的含义，理解时不会产生二义性。并且在任何条件下，算法只有唯一的一 条执行路径，即对于<u>相同的输入只能得出相同的输出</u>。</p><p>(3)<strong>可行性</strong>。一个算法是可行的，即算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p><p>(4)<strong>输入</strong>。一个算法<strong>有零个或多个输入</strong>，这些输入取自于某个特定的对象的集合。</p><p>(5)<strong>输出</strong>。一个算法有<strong>一个或多个输出</strong>，这些输出是同输入有着某些特定关系的</p><h2 id="算法的复杂度【考点】"><a href="#算法的复杂度【考点】" class="headerlink" title="算法的复杂度【考点】"></a>算法的复杂度【考点】</h2><p>◆算法的时间复杂度分析:主要是<strong>分析算法的运行时间</strong>，即算法<strong>执行所需要的基本操作数</strong>。<strong>不同规模的输入所需要的基本操作数是不相同</strong>。在算法分析中,可以<strong>建立以输入规模n为自变量的函数T(n)来表示算法的时间复杂度</strong>。</p><p>◆即使对于<strong>相同的输入规模，数据分布不相同也影响了算法执行路径的不同</strong>，因此所需要的执行时间也不同。根据不同的输入，将算法的时间复杂度分析分为3种情况:最佳情况、最坏情况、平均情况。</p><p>◆<strong>渐进符号</strong>:以输入规模n为自变量建立的时间复杂度实际上还是较复杂的，例如an^2+bn+c,不仅与输入规模有关,还与系数a、b和c有关。此时可以<strong>对该函数做进一步的抽象， 仅考虑运行时间的增长率或称为增长的量级</strong>，如忽略上式中的低阶项和高阶项的系数，仅考虑n^2。 当输入规模大到只有与运行时间的增长量级有关时，就是在研究算法的渐进效率。也就是说，从极限角度看，只关心算法运行时间如何随着输入规模的无限增长而增长。下面简单介绍3 种常用的标准方法来简化算法的渐进分析。</p><p>![image-20231030222245314](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;4.png)</p><blockquote><p>时间复杂一般看循环的次数。</p></blockquote><p>常数级：没有循环，复杂度就是O(1)</p><p>线性级：对应O(n)，和输入成正比关系。一般有一个一重循环。</p><p>对数级：含有折半和两两归并的一般是对数级。</p><p>平方级：嵌套有两个循环体。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>◆递归是指子程序(或函数)直接调用自己或通过一系列调用语句间接调用自己，是一种描述问题和解决问题的常用方法。递归有两个基本要素:边界条件即确定递归到何时终止，也称为递归出口;递归模式，即大问题是如何分解为小问题的，也称为递归体。</p><p>![image-20231030223426150](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030223426150.png)</p><p>◆阶乘函数可递归地定义为:</p><p>◆阶乘函数的自变量n的定义域是非负整数。递归式的第一式给出了 这个函数的一个初始值，是递归的边界条件。递归式的第二式是用较小自变量的函数值来表示较大自变量的函数值的方式来定义n的阶乘，是递归体。n!可以递归地计算如下:</p><p>int Factorial(int num）if(num&#x3D;&#x3D;0)return1;if(num&gt;0)return num *Factorial（num - 1）;</p><p>![image-20231030223756879](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030223756879.png)</p><p>![image-20231030224038187](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030224038187.png)</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><blockquote><p>分治法的设计思想是将一个难以直接解决的大问题分解成一些规模较少的相同问题以便各个击破，分而治之。动态规划法与分治法类似，其基本思想也是将待求解问题分解成若千个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。</p><p>贪心法经常用于解决最优化问题，但他的最优往往是从局部最优来考虑的，每一步都选最优的方案，但这种方案不一定能得到整体上的最优解。回溯法是一种既带有系统性又带有跳跃性的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。题目描述中提到，需要解决的问题具有最优子结构性质，且求解过程中子问题被重复求解，这种情况下如果采用分治法，效率会很低，所以应采用动态规划法。而“以深度优先的方式搜索解空间”则明显是在采用回溯法。</p></blockquote><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>◆分治法的设计思想是<strong>将一个难以直接解决的大问题分解成一些规模较小的相同问题</strong>，以便各个击破,分而治之。如果规模为n的问题可分解成k个子问题，1&lt;k&lt;&#x3D;n,这些子问题互相独立且与原问题相同。分治法产生的子问题往往是原问题的较小模式，这就为递归技术提供了方便。</p><p>◆一般来说，分治算法在每一层递归. 上都有3个步骤。</p><p>(1)<strong>分解</strong>。将原问题分解成一系列子问题。(2)<strong>求解</strong>。递归地求解各子问题。若子问题足够小则直接求解。(3)<strong>合并</strong>。将子问题的解合并成原问题的解。</p><p>◆凡是涉及到<strong>分组解决的都是分治法</strong>，例如归并排序算法完全依照上述分治算法的3个步骤进行。</p><p>(1)分解。将n个元素分成各含n&#x2F;2个元素的子序列。(2)求解。用归并排序对两个子序列递归地排序。(3)合并。合并两个已经排好序的子序列以得到排序结果。</p><p>(1)刻画0-1背包问题的最优解的结构。</p><p>可以将背包问题的求解过程看作是进行一-系列的决策过程， 即决定哪些物品应该放入背包，哪些物品不放入背包。如果-个问题的最优解包含了物品n,即xn&#x3D;1,那么其余x1, x2，… xn-1一 定构成子问题1, 2, … n-1在容量为W-wn时的最优解。如果这个最优解不包含物品n，即xn&#x3D;0,那么其余x1, x2, … xn-1一 定构成子问题1, 2, … n-1在容量为W时的最优解。</p><p>(2)递归定义最优解的值。</p><p>根据上述分析的最优解的结构递归地定义问题最优解。设c[i, w]表示背包容量为w时i个物品导致的最优解的总价值，得到下式。显然,问题要求c[n, W]。</p><p>![image-20231030230903588](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030230903588.png)</p><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>◆动态规划算法与分治法类似,其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合用动态规划法求解的问题，经分解得到的子问题往往不是独立的。若用分治法来解这类问题，则相同的子问题会被求解多次,以至于最后解决原问题需要耗费指数级时间。</p><p>◆然而，不同子问题的数目常常只有多项式量级。如果能够保存已解决的子问题的答案，在需要时再找出已求得的答案,这样就可以避免大量的重复计算，从而得到多项式时间的算法。为了达到这个目的，可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到，<strong>只要它被计算过，就将其结果填入表中</strong>。这就是动态规划法的基本思路。</p><p>◆动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解，每个解都对应于一个值， 我们希望找到具有最优值(最大值或最小值)的那个解。当然，最优解可能会有多个，动态规划算法能找出其中的一一个最优解。设计一个动态规划算法, 通常按照以下几个步骤进行。</p><p>(1)找出最优解的性质，并刻画其结构特征。</p><p>(2)递归地定义最优解的值。</p><p>(3)以自底向.上的方式计算出最优值.</p><p>(4)根据计算最优值时得到的信息，构造一个最优解。</p><p>◆步骤(1) ~ (3)是动态规划算法的基本步骤。在只需要求出最优值的情形下，步骤(4)可以省略。若需要求出问题的一个最优解，则必须执行步骤(4)</p><p>◆对于一个给定的问题，若其具有以下两个性质，可以考虑用动态规划法来求解。</p><p>(1)<strong>最优子结构</strong>。如果一个问题的最优解中包含 了其子问题的最优，也就是说该问题具有最优子结构。当一个问题具有最优子结构时，提示我们动态规划法可能会适用，但是此时<strong>贪心策略可能也是适用</strong>的。</p><p>(2)<strong>重叠子问题</strong>。重叠子问题指<strong>用来解原问题的递归算法可反复地解同样的子问题</strong>，而不是总在产生新的子问题。即当一个递归算法不断地调用同一一个问题时，就说该问题包含重叠子问题。</p><p>◆典型应用: 0-1背包问题</p><p>◆有n个物品，第i个物品价值为vi,重量为wi， 其中vi和wi均为非负数，背包的容量为W, W为非负数。现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大。</p><p>◆满足约束条件的任一集合(x1, x2, … xn)是问题的一个可行解，问题的目标是要求问题的一一个最优解。考虑-个实例，假设n&#x3D;5，W&#x3D;17,每个物品的价值和重量如表所示，可将物品1、2和5装入背包，背包未满,获得价值22,此时问题解为(1, 1, 0, 0, 1) ;也可以将物品4和5装入背包，背包装满，获得价值24，此时解为(0, 0, 0, 1, 1)。</p><p>![image-20231030230326890](..&#x2F;..&#x2F;pic&#x2F;10.算法分析与设计 &#x2F;image-20231030230326890.png)</p><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><h2 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h2><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="数据挖掘算法"><a href="#数据挖掘算法" class="headerlink" title="数据挖掘算法"></a>数据挖掘算法</h2><h2 id="智能优化算法"><a href="#智能优化算法" class="headerlink" title="智能优化算法"></a>智能优化算法</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;算法设计&quot;&gt;&lt;a href=&quot;#算法设计&quot; class=&quot;head</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>9.文老师-程序设计语言基础知识</title>
    <link href="http://example.com/2023/10/13/%E8%BD%AF%E8%80%83/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/10/13/%E8%BD%AF%E8%80%83/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-10-13T12:06:15.000Z</published>
    <updated>2023-10-25T09:10:10.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="程序设计语言概述"><a href="#程序设计语言概述" class="headerlink" title="程序设计语言概述"></a>程序设计语言概述</h1><h2 id="程序设计语言的基本概念"><a href="#程序设计语言的基本概念" class="headerlink" title="程序设计语言的基本概念"></a>程序设计语言的基本概念</h2><h3 id="语言的种类"><a href="#语言的种类" class="headerlink" title="语言的种类"></a>语言的种类</h3><p>◆程序设计语言是为了书写计算机程序而人为设计的符号语言,用于对计算过程进行描述、组织和推导。</p><p>◆低级语言:<strong>机器语言(计算机硬件只能识别0和1的指令序列)，汇编语言</strong>。</p><blockquote><p>汇编语言需要通过汇编程序转换为机器语言。</p></blockquote><p>◆高级语言:功能更强，抽象级别更高，<strong>与人们使用的自然语言比较接近</strong>。</p><p>◆各程序设计语言特点【考点】: </p><p>Fortran语言:科学计算，执行效率高。</p><p>Pascal语言:为<strong>教学</strong>开发，表达能力强。</p><p>C语言:<strong>指针操作能力强</strong>，可以开发系统级软件,高效。</p><p>C+ +语言:<strong>面向对象</strong>，高效。</p><p>Java语言:面向对象，中间代码，<strong>跨平台</strong>。</p><p>C#语言:面向对象，中间代码，**.Net框架**。</p><p>Python是一种面向对象、<strong>解释型</strong>计算机程序设计语言。</p><p>Prolog是<strong>逻辑型</strong>程序设计语言。</p><p>◆汇编: 将<strong>汇编语言翻译成目标程序</strong>执行。</p><p>◆解释和编译:<strong>执行高级语言</strong>。不同之处在于<strong>编译程序生成独立的可执行文件，直接运行，运行时无法控制源程序，效率高</strong>。而<strong>解释程序不生成可执行文件，可以逐条解释执行【jupyter可以一行一行的执行程序】，用于调试模式，可以控制源程序</strong>，因为还需要控制程序，因此执行速度慢，效率低。</p><p><strong>例题：</strong>选择题可用于编写独立程序和快速脚本的语言是()。</p><p>A.PythonB.PrologC.JavaD.C#</p><blockquote><p>脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，通常以文本(如ASCII )保存，<strong>只在被调用时进行解释或编译</strong>。Python是一种脚本语言。</p></blockquote><h3 id="程序设计语言定义三要素-语法、语义、语用【如何使用】。"><a href="#程序设计语言定义三要素-语法、语义、语用【如何使用】。" class="headerlink" title="程序设计语言定义三要素:语法、语义、语用【如何使用】。"></a><strong>程序设计语言定义三要素:语法、语义、语用【如何使用】。</strong></h3><ul><li><p>语法是指由程序设计语言的基本符号组成程序中的<strong>各个语法成分(包括程序)的一组规则</strong>，其中由基本字符构成的符号(单词)书写规则称为词法规则，由符号构成语法成分的规则称为语法规则。</p></li><li><p>语义是程序设计语言中按语法规则构成的<strong>各个语法成分的含义</strong>,可分为静态语义和动态语义。静态语义指编译时可以确定的语法成分的含义，而运行时刻才能确定的含义是动态语义。一个程序的执行效果说明了该程序的语义，它取决于构成程序的各个组成部分的语义。</p></li><li><p>语用表示了构成语言的各个记号和使用者的关系，涉及符号的来源、使用和影响。</p></li></ul><p>◆<strong>语言的实现则有个语境问题</strong>。语境是指理解和实现程序设计语言的环境，包括编译环境和运行环境。</p><p>◆程序设计语言的分类</p><ul><li>(1)<strong>命令式和结构化程序设计语言</strong>，包括Fortran、 PASCAL和C语言。</li><li>(2)<strong>面向对象</strong>程序设计语言,包括C++、JAVA和Smalltalk语言。</li><li>(3)<strong>函数式</strong>程序设计语言,包括LISP、Haskell、 Scala、 Scheme、 APL等。</li><li>(4)<strong>逻辑型</strong>程序设计语言，包括PROLOG。</li></ul><h2 id="程序设计语言的基本成分【考点】"><a href="#程序设计语言的基本成分【考点】" class="headerlink" title="程序设计语言的基本成分【考点】"></a>程序设计语言的基本成分【考点】</h2><h3 id="数据成分"><a href="#数据成分" class="headerlink" title="数据成分"></a>数据成分</h3><ul><li><strong>数据成分</strong>:指一种程序设计语言的<strong>数据和数据类型</strong>。数据分为<strong>常量</strong>(程序运行时不可改变)、<strong>变量</strong>(程序运行时可以改变)、<strong>全局量</strong>(存储空间在静态数据区分配)、<strong>局部量</strong>(存储空间在堆栈区分配)。数据类型有整型、字符型、双精度、单精度浮点型、布尔型等。</li></ul><p>**例题.**以下关于变量和常量的叙述中,错误的是()。</p><p>A变量的取值在程序运行过程中可以改变，常量则不行B变量具有类型属性,常量则没有C变量具有对应的存储单元，常量则没有D可以对变量赋值，不能对常量赋值</p><blockquote><p>变量是计算机内存单元的抽象，在程序中表示数据，具有名称、类型、值、地址、作用域、存储类别等属性，其值在运行过程中由指令进行修改。常量也用于在程序中表示数据，但常量在程序运行过程中不能修改，常量也具有类型，如整型常量、浮点型常量、字符串常量等，也称为字面量或文字。</p></blockquote><p>**例题.**若C程序的表达式中引用了未赋初值的变量，则(D)。</p><p>A.编译时一定会报告错误信息，该程序不能运行B.可以通过编译并运行，但运行时一定会报告异常C.可以通过编译，但链接时一定会报告错误信息而不能运行D.可以通过编译并运行，但运行结果不一定是期望的结果</p><blockquote><p>在编写C&#x2F;C++源程序时，为所定义的变量赋初始值是良好的编程习惯，而赋初值不是强制的要求，因此编译程序不检查变量是否赋初值。如果表达式中引用的变量从定义到使用始终没有赋值，则<strong>该变量中的值表现为一个随机数</strong>，这样对表达式的求值结果就是不确定的了。</p></blockquote><h3 id="运算成分"><a href="#运算成分" class="headerlink" title="运算成分"></a>运算成分</h3><ul><li><strong>运算成分</strong>:指明<strong>允许使用的运算符号及运算规则</strong>。包括算术运算、逻辑运算、关系运算、位运算等。</li></ul><p>对于逻辑表达式“x and y or not z” ,and、or、 not分别是逻辑与、或、非运算，优先级从高到低为not、and、 or，and、or为左结合,not为右结合，若进行短路计算，则( )。</p><p>A.x为真时，整个表达式的值即为真，不需要计算y和z的值B.x为假时，整个表达式的值即为假，不需要计算y和z的值C.x为真时，根据y的值决定是否需要计算z的值D.x为假时，根据y的值决定是否需要计算z的值</p><blockquote><p>对逻辑表达式可以进行短路计算，其依据是:a and b的含义是a和b同时为“真”，则a and b为“真”，因此，若a为“假”，则无论b的值为“真”或“假”,a and b必然为“假”; a or b的含义是a和b同时为“假”，则a or b为“假”，因此，若a为“真”，则无论b的值为“真”或“假”，a or b必然为“真”。</p><p>在优先级和结合性规定下，对逻辑表达式“x and y or not z”求值时，应先计算“x and y”的值，若为“假”，才去计算“not z”的值。因此，若x的值为“假”，则“x and y”的值为“假”，需要计算“not z”来确定表达式的值而不管y是“真”是“假”。当x的值为“真”，则需要计算y的值︰若y的值为“真”，则整个表达式的值为“真”（从而不需再计算“not z” )﹔若y的值为“假”，则需要计算“not z”来确定表达式的值。</p></blockquote><h3 id="控制成分"><a href="#控制成分" class="headerlink" title="控制成分"></a>控制成分</h3><ul><li>3.<strong>控制成分</strong>:指明<strong>语言允许表述的控制结构。包括序结构、选择结构、循环结构</strong>。如下图所示。</li></ul><p><img src="/../../pic/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231014160317305.png" alt="image-20231014160317305"></p><h3 id="传输成分"><a href="#传输成分" class="headerlink" title="传输成分"></a>传输成分</h3><p>4.<strong>传输成分</strong>:指明语言允许的数据传输方式。如赋值处理、数据的输入输出等。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>函数</strong>: C程序由一个或多个函数组成，每个函数都有一个名字，其中有且仅有一个名字为main<strong>的函数作为程序运行时的起点</strong>。函数的使用涉及3个概念:<strong>函数定义、函数声明和函数调用</strong>。</p><p>函数的定义包括两部分:函数首部和函数体。函数的定义描述了函数做什么和怎么做。<strong>函数定义的一般形式</strong>为:  返回值的类型    函数名【形式参数表】 &#x2F;&#x2F;函数首部{函数体;}</p><p>函数首部说明了函数返回值的数据类型、函数的名字和函数运行时所需的参数及类型。函数所实现的功能在函数体部分进行描述。</p><p><strong>函数应该先声明后引用</strong>。如果程序中对一一个函数的调用在该函数的定义之前进行，则应该在调用前对被调用函数进行声明。函数原型用于声明函数。函数声明的一般形式为:返回值类型函数名(参数类型表);</p><p><strong>函数调用的一般形式为: 函数名(实参表) ;</strong></p><p>函数调用时<strong>实参与形参间交换信息的方法有值调用和引用调用两种</strong>。</p><p>(1)<strong>值调用</strong>(Call by Value)。若<strong>实现函数调用时将实参的值传递给相应的形参</strong>，则称为是传值调用。在这种方式下<strong>形参不能向实参传递信息</strong>。在C语言中，要实现被调用函数对实参的修改,必须<strong>用指针作为参数</strong>。即调用时需要先<strong>对实参进行取地址运算</strong>，然后将实参的地址传递给指针形参。其本质上仍属于值调用。这种方式实现了间接内存访问。</p><p>(2)<strong>引用调用</strong>(Call by Reference)。引用是<strong>C++中引入的概念</strong>,当形式参数为引用类型时，形参名实际上是实参的别名，函数中对形参的访问和修改实际上就是针对相应实参所做的访问和改变。</p><blockquote><p>函数调用时，基本的参数传递方式有传值与传地址两种，(C)。</p><p>A.在传值方式下，形参将值传给实参B.在传值方式下，实参不能是数组元素C.在传地址方式下，形参和实参间可以实现数据的双向传递D.在传地址方式下，实参可以是任意的变量和表达式</p><p>函数调用时基本的参数传递方式有传值与传地址两种，在传值方式下是将实参的值传递给形参，因此实参可以是表达式(或常量），也可以是变量（或数组元素)，这种信息传递是单方向的，<strong>形参不能再将值传回给实参</strong>。在传地址方式下，需要将实参的地址传递给形参，因此，实参必须是变量（数组名或数组元素），不能是表达式(或常量)。这种方式下，被调用函数中对表达式参数的修改实际上就是对实际参数的修改，因此客观上可以实现数据的双向传递。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li>将高级语言源程序翻译为可在计算机上执行的形式有多种不同的方式，其中(C)。</li></ol><p>A.编译方式和解释方式都生成逻辑上与源程序等价的目标程序</p><p>B.编译方式和解释方式都不生成逻辑上与源程序等价的目标程序</p><p>C.编译方式生成逻辑上与源程序等价的目标程序,解释方式不生成</p><p>D.解释方式生成逻辑_上与源程序等价的目标程序,编译方式不生成</p><ol start="2"><li>以下关于程序设计语言的叙述中，不正确的是(A )。</li></ol><p>A.脚本语言中不使用变量和函数</p><p>B.标记语言常用于描述格式化和链接</p><p>C.脚本语言采用解释方式实现</p><p>D.编译型语言的执行效率更高</p><blockquote><p>脚本语言：python，JavaScript等可以直接解释执行的语言。</p></blockquote><ol start="3"><li></li></ol><p><img src="/../../pic/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231014163729555.png" alt="image-20231014163729555"></p><blockquote><p> 如果是引用调用形参改变，实参改变。如果是值调用，形参改变，实参不改变。</p><p>B</p></blockquote><ol start="4"><li>通用的高级程序设计语言一般都会提供描述数据、 运算、控制和数据传输的语言成分，其中，控制包括顺序、(A )和循环结构。</li></ol><p>A.选择B.递归C.递推D.函数</p><h1 id="语言处理程序基础"><a href="#语言处理程序基础" class="headerlink" title="语言处理程序基础"></a>语言处理程序基础</h1><h2 id="编译程序基本原理【考点】"><a href="#编译程序基本原理【考点】" class="headerlink" title="编译程序基本原理【考点】"></a>编译程序基本原理【考点】</h2><p>编译程序对高级语言源程序进行编译的过程中，要不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入符号表中，编译过程如下:</p><p>◆词法分析:是编译过程的第一个阶段。 这个阶段的任务是<strong>从左到右一个字符一个字符地读入源程序</strong>，即对构成源程序的字符流进行<strong>扫描然后根据构词规则识别单词</strong>(也称单词符号或符号)。【检查单词是否拼写有误】</p><p>◆语法分析:是编译过程的-一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等语法分析程序判断源程序在结构上是否正确.【检查语法有误】</p><p>◆语义分析:是编译过程的一个逻辑阶段.语义分析的任务是<strong>对结构上正确的源程序进行上下文有关性质的审查,进行类型审查</strong>。如类型匹配、除法除数不为0等。又分为**静态语义错误(在编译阶段能够查找出来)和动态语义错误(只能在运行时发现)**。</p><p><img src="/../../pic/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231014164506770.png" alt="image-20231014164506770"></p><p>◆中间代码和目标代码:中间代码是根据语义分析产生的,需要经过优化链接,最终生成可执行的目标代码。引入中间代码的目的是<strong>进行与机器无关的代码优化处理</strong>。常用的中间代码有<strong>后缀式</strong>(逆波兰式)、三元式(三地址码)、四元式和树等形式。需要考虑三个问题(<u>一是如何生成较短的目标代码;二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；三是如何充分利用计算机指令系统的特点，以提高目标代码的质量</u>)。</p><blockquote><p><strong>中间代码生成和代码优化不是必要的。</strong>中间代码和硬件代码没有关系，支持跨平台。目标代码和硬件代码相关，不支持跨平台，如win平台的exe，Android的apk。</p></blockquote><p><img src="/../../pic/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231014165219805.png" alt="image-20231014165219805"></p><p>前缀表达式: +ab【先访问根节点就是前，先访问子节点就是后】</p><p>中缀表达式: a+b</p><p>后缀表达式:ab+</p><p>主要掌握上述三种表达式即可，其实就是树的三种遍历，一般<strong>正常的表达式是中序遍历</strong>，即中缀表达式，根据其构造出树,再按题目要求求出前缀或后缀式。</p><p>◆简单求法:后缀表达式是<strong>从左到右开始，先把表达式加上括号，再依次把运算符加到本层次的括号后面</strong>。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>1.将编译器的工作过程划分为词法分析，语法分析，语义分析，中间代码生成，代码优化和目标代码生成时，**语法分析阶段的输入是(A )**。若程序中的括号不配对，则会在( B)阶段检查出错误。</p><p>A、记号流</p><p>B、字符流</p><p>C、源程序</p><p>D、分析树</p><p>A、词法分析</p><p>B、语法分析</p><p>C、语义分析.</p><p>D、目标代码生成</p><p>2.以编译方式翻译C&#x2F;C++源程序的过程中，(C )阶段的主要任务是对各条语句的结构进行合法性分析。</p><p>A.词法分析</p><p>B.语义分析</p><p>C.语法分析</p><p>D.目标代码生成</p><p>3.表达式(a-b) * (c+d)的后缀式(逆波兰式)是(D )</p><p>A、abcd-+*</p><p>B、ab-c+d*</p><p>C、abc-d&#x2F;-*</p><p>D、ab-cd+*</p><blockquote><p> 简单求法:后缀表达式是<strong>从左到右开始，先把表达式加上括号，再依次把运算符加到本层次的括号后面</strong>。</p><p>直接作图也可以求出。</p></blockquote><p>4.将编译器的工作过程划分为词法分析,语法分析，语义分析,中间代码生成,代码优化和目标代码生成时,语法分析阶段的输入是()若程序中的括号不配对，则会在（&#x2F;)阶段检查出错误。</p><p>A.记号流B.字符流C.源程序D.分析树</p><blockquote><p>记号流，<u><strong>词法分析的输出是记号流</strong>，<strong>也就是语法分析的输入</strong>。</u></p><p>字符流，在Java中，根据处理的数据单位不同，分为字节流和字符流。字符流是由字符组成的，例如FileReader、FileWriter、BufferedReader、BuffcrcdWriter、InputStrcamRcader、OutputStrcam Writcr等。与本题无关。</p><p>源程序，词法分析的任务是把源程序的字符串转换成单词符号序列。分析树，如果没有语法错误，语法分析后就能正确的构造出其语法树。括号不匹配是典型的语法错误，会在语法分析阶段检测出来。</p></blockquote><p>5.已知某高级语言源程序A经编译后得到机器C上的目标程序B,则()。</p><p>A.对B进行反编译，不能还原出源程序AB.对B进行反汇编，不能得到与源程序A等价的汇编程序代码C.对B进行反编译，得到的是源程序A的变量声明和算法流程D.对A和B进行交叉编译，可以产生在机器C上运行的动态链接库</p><blockquote><p>编译是将高级语言源程序翻译成机器语言程序(汇编形式或机器代码形式)，反编译是编译的逆过程。<strong>反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序</strong>。</p></blockquote><h2 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h2><h3 id="字母表、字符串、字符串集合及运算"><a href="#字母表、字符串、字符串集合及运算" class="headerlink" title="字母表、字符串、字符串集合及运算"></a>字母表、字符串、字符串集合及运算</h3><ul><li>字母表 $\Sigma$ 和字符: 字母表是字符的非空有穷集合, 字符是字母表 $\Sigma $ 中的元素。例如 $\Sigma&#x3D;{a, b}$, $a$或$b$是字符。</li><li>字符串: $\Sigma$ 中的字符组成的有穷序列。例如 $a, a b$, $aaa$  都是 $\Sigma$ 上的字符串。</li><li>字符串的长度: 指字符串中的字符个数。如 $|a b a|&#x3D;3$ 。</li><li>空串 $\varepsilon$ :由零个字符组成的序列, $|\varepsilon|&#x3D;0$ 。</li><li>连接: 字符串 $S$ 和 $T$ 的连接是指将串 $T$ 接续在串 $S$ 之后, 表示为 $S \cdot T$, 连接符号 “ ・” 可省略。显然, 对于字母表 $\Sigma$ 的任意字符串 $S, S \cdot \varepsilon&#x3D;\varepsilon \cdot S&#x3D;S$ 。</li><li>$\Sigma^*$ : 是指包括空串 $\varepsilon$ 在内的 $\Sigma$ 上所有字符串的集合。例如: $\Sigma&#x3D;{a, b}$, $\Sigma^*&#x3D;{\varepsilon, a, b, a a, b b, a b, b a, a a a, \cdots}$ 。</li><li>字符串的方幂: 把字符串 $\alpha$ 自身连接 $n$ 次得到的串, 称为字符串 $\alpha$ 的 $n$ 次方幕, 记为 $\alpha^{\mathrm{n}} \circ \alpha_0&#x3D;\varepsilon, \alpha^n&#x3D;\alpha \alpha^{n-1}&#x3D;\alpha^{n-1} \alpha,(\mathrm{n}&gt;0)$ 。</li><li>字符串集合的运算: 设 $A, B$ 代表字母表 $\Sigma$ 上的两个字符串集合。</li><li>或 (合并): $A \cup B&#x3D;{\alpha \mid \alpha \in A或 \alpha \in B}$</li><li>积 (连接) : $A B&#x3D;{\alpha \beta \mid \alpha \in且 \beta \in B}$ 。</li><li>幂: $A^n&#x3D;A \cdot A^{n-1}&#x3D;A^{n-1} \cdot A(\mathrm{n}&gt;0)$, 并规定 $A^0&#x3D;{\varepsilon}$ 。 </li><li><strong>正则闭包</strong> $+: A^{+}&#x3D;A^1 \cup A^2 \cup A^3 \cup \cdots \cup A^n \cup \cdots$ ，不包含空串。</li><li><strong>闭包</strong> ${ }^*: A^*&#x3D;A^0 \cup A^{+}$。显然, $\Sigma^*&#x3D;\Sigma^{\mathfrak{u}} \cup \Sigma^1 \cup \Sigma^2 \cup \cdots \cup \Sigma^{\mathrm{n}} \cup \cdots$ 。</li></ul><h3 id="文法G"><a href="#文法G" class="headerlink" title="文法G"></a>文法G</h3><p>文法 $G$ 是一个四元组, 可表示为 $G&#x3D;(V, T, P, S)$, 其中:</p><p>$V$ : 非终结符, 不是语言组成部分, 不是最终结果, 可以推导出其他元素。</p><p>$T$ : 终结符, 是语言的组成部分, 是<strong>最终结果,</strong> 不能再推导其他元素。</p><p>$S$ : 起始符, 是语言的<strong>开始符号</strong>。</p><p>P: 产生式, 用<strong>终结符代替非终结符的规则</strong>, 例如 $a-&gt;b$ 。</p><p><strong>乔姆斯基 (Chomsky) 把文法分成 4 种类型</strong>, 即0 型、 1 型、 2 型和 3 型。</p><ul><li>0 型文法也称为短语文法, 其功能相当于图灵机, 任何 0 型语言都是递归可枚 举的; 反之, 递归可枚举集也必定是一个0 型语言。</li><li>1 型文法也称为<strong>上下文有关文法</strong>, <strong>这种文法意味着对非终结符的替换必须考 虑上下文</strong>, 并且一般不允许替换成 $\varepsilon$ 串。例如, 若 $\alpha A \beta \rightarrow \alpha \gamma \beta$ 是 1 型文法的产生式, $\alpha$ 和 $\beta$ 不全为空, 则非终结符 $A$ 只有在左边是 $\alpha$, 右边是 $\beta$ 的上下文中才能替换成 $\gamma$ 。</li><li>2 型文法就是<strong>上下文无关文法</strong>, <strong>非终结符的替换无须考虑上下文</strong>。<u><strong>程序设计 语言中的大部分语法都是上下文无关文法,</strong></u> 当然语义上是相关的, 要注意区分 语法和语义。</li><li><strong>3 型文法等价于正规式</strong>，因此也被称为正规文法或线性文法。</li></ul><p>对于大多数通用程序设计语言，用(B)描述其语法即可。</p><p>A.正规文法B.上下文无关文法C.上下文有关文法D.短语结构文法</p><blockquote><p>乔姆斯基(Chomsky )把文法分成四种类型，即0型、1型、2型和3型。0型文法也称为短语文法，其能力相当于图灵机，任何0型语言都是递归可枚举的;反之，递归可枚举集也必定是一个0型语言。</p><p>1型文法也称为上下文有关文法，这种文法意味着对非终结符的替换必须考虑上下文。</p><p>2型文法就是<strong>上下文无关文法</strong>，非终结符的替换无需考虑上下文。</p><p>3型文法等价于正规式，因此也被称为正规文法或线性文法。通用程序设计语言的大多数语法可由上下文无关文法表示。</p></blockquote><h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>语言中具有独立含义的最小语法单位是符号 (单词), 如标识符、无符号常数与界限符等。词法分析的任务是把构成源程序的字符串转换成单词符号序列。</p><p><strong>词法规则可用 3 型文法 (正规文法) 或正规表达式描述</strong>, <strong>它产生的集合是语言 规定的基本字符集 $\Sigma($ 字母表)上的字符串的一个子集，称为正规集</strong>。</p><p>正规式和正规集:</p><p>对于字母表 $\Sigma$, 其上的正规式及其表示的正规集可以递归定义如下。</p><ul><li>(1) $\varepsilon$ 是一个正规式, 它表示集合 $L(\varepsilon)&#x3D;{\varepsilon}$ 。</li><li>(2) 若 $a$ 是 $\sum$ 上的字符, 则 $a$ 是一个正规式, 它所表示的正规集为 ${a}$ 。</li><li>(3) 若正规式 $r$ 和 $s$ 分别表示正规集 $L(r)$ 和 $L(s)$, 则:<ul><li>(1) $r \mid s$ 是正规式, 表示集合 $L(r) \cup L(s)$ 。</li><li>(2) $r \cdot s$ 是正规式, 表示集合 $L(r) L(s)$ 。</li><li>(3) $r^*$ 是正规式, 表示集合 $(L(r))$ 。</li><li>(4) $(r)$ 是正规式, 表示集合 $L(r)$ 。</li></ul></li></ul><p>仅通过有限次地使用上述 3 个步骤定义的表达式才是 $\Sigma$ 上的正规式，其中，运 算符 “I” “・” “*”分别称为 “或” “连接” 和 “闭包”。在正规式的书写中， 设 $\Sigma&#x3D;\{a, b\}$ ，下表列出了 $\Sigma$ 上的一些正规式和相应的正规集。</p><p><img src="/../../pic/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231014173702798.png" alt="image-20231014173702798"></p><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><h2 id="语法分析方法"><a href="#语法分析方法" class="headerlink" title="语法分析方法"></a>语法分析方法</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;程序设计语言概述&quot;&gt;&lt;a href=&quot;#程序设计语言概述&quot; cla</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>经销商采购车辆贷款授信流程</title>
    <link href="http://example.com/2023/10/12/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E5%85%AC%E4%B8%9A%E5%8A%A1/1.1%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2023/10/12/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E5%85%AC%E4%B8%9A%E5%8A%A1/1.1%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/</id>
    <published>2023-10-12T07:47:37.000Z</published>
    <updated>2023-10-13T04:04:40.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="经销商新车采购车辆贷款系统申请指引"><a href="#经销商新车采购车辆贷款系统申请指引" class="headerlink" title="经销商新车采购车辆贷款系统申请指引"></a>经销商新车采购车辆贷款系统申请指引</h1><h2 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h2><h3 id="系统登陆"><a href="#系统登陆" class="headerlink" title="系统登陆"></a>系统登陆</h3><p>首次与奇瑞金融合作的向奇瑞金融公司大区客户经理申请并提供准确的经销商名称（全称）即可获得系统账号。已与奇瑞金融合作过批售或者零售的客户可以查询到经销商在我司的系统账号。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>采购车辆贷款业务系统网址</td><td><a href="https://cbs.cheryfs.cn/chery/index1.jsp">https://cbs.cheryfs.cn/chery/index1.jsp</a></td><td></td></tr><tr><td>用户名</td><td>我司的采购车辆贷款用户名为客户编号后7位，初始密码为Chery123，需登陆系统后重置密码。</td><td></td></tr><tr><td>重置密码</td><td>为了保障您的用户安全,重置密码组合至少为字母+数字</td><td></td></tr></tbody></table><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012200830974.png" alt="image-20231012200830974"></p><h3 id="贷款申请"><a href="#贷款申请" class="headerlink" title="贷款申请"></a>贷款申请</h3><p>搜索贷款申请菜单——额度授信管理（通过点亮星标，将菜单添加到左侧常用菜单栏）</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012200940274.png" alt="image-20231012200940274"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012200951587.png" alt="image-20231012200951587"></p><p>此界面功能按钮介绍：</p><ul><li>1、查询：可以查看历史额度申请信息和流程节点及状态</li><li>2、贷款申请：可进行额度的新申请、续授信、增补和释放</li><li>3、其他类型申请：可进行用信过程中增加担保调整和额度调减&#x2F;终止</li><li>4、集团额度调配申请：适用于集团经销商之间额度的互相转换</li></ul><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201117732.png" alt="image-20231012201117732"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201135787.png" alt="image-20231012201135787"></p><p><img src="/../image-20231012201142572.png" alt="image-20231012201142572"></p><p>申请品牌和申请类型需填写准确，如同时经营奇瑞、星途请选择“奇瑞、星途”选项。</p><p>界面分为四个页签：贷款申请、基本信息、财务报表、影像材料。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201234498.png" alt="image-20231012201234498"></p><p><strong>基本信息页</strong>签包括：申请主体基本信息、股东信息、管理层信息、企业高管家庭成员信息、关联企业信息、担保信息。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201318446.png" alt="image-20231012201318446"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201327797.png" alt="image-20231012201327797"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201342972.png" alt="image-20231012201342972"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201353421.png" alt="image-20231012201353421"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201412247.png" alt="image-20231012201412247"></p><p>股东类型分为自然人股东和法人股东，根据实际情况新增并选择，填写要求如图。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201455276.png" alt="image-20231012201455276"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201514896.png" alt="image-20231012201514896"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201530503.png" alt="image-20231012201530503"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201536821.png" alt="image-20231012201536821"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201631554.png" alt="image-20231012201631554"></p><p>1、原则上经销商法人股东（如有）、自然人股东夫妻及实际控制人夫妻均需提供连带责任保证担保。</p><p>2、自然人担保的资产录入，分为房产、车辆及其他，请分别录入。夫妻双方资产请一并录入。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201702268.png" alt="image-20231012201702268"></p><p>担保类型分为：自然人担保、企业担保和抵质押物担保，可点击对应的功能按钮进行相关信息增加的界面。</p><p>担保要求：所有自然人股东夫妻双方、法定代表人夫妻双方必须提供担保，法人股东必须提供担保。其他担保条件根据实际情况进行补充。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201750668.png" alt="image-20231012201750668"></p><p>报表模板可下载，下载填写完毕后点击新增上传，资产负债表和利润表按要求期数上传，科目余额表只需要上传最近一期即可报表期数间需具备一定的逻辑关系，各科目的上年度期末值要与本年度期末值相同如报表填写错误，可通过维护按钮修改数据，也可以点击删除后重新新增上传。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012201945904.png" alt="image-20231012201945904"></p><p>经销商影像资料上传页面可以下载资料示例：示例包括资料清单、填写规范和资料模板，上传影像时请按照图中影像分类依次上传，如上传经销商申请资料——公司章程，点击上图中第三个分类右侧的上传资料进行上传。</p><h3 id="保险购买"><a href="#保险购买" class="headerlink" title="保险购买"></a>保险购买</h3><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012202030698.png" alt="image-20231012202030698"></p><p>额度落实后需购买财产保险，<strong>保单金额不低于释放金额</strong>。</p><p>菜单名称：保险信息录入。填写保险信息，点击影像资料上传扫描的保单信息后提交，等待后台人员进行保单审核。</p><h3 id="报单查询"><a href="#报单查询" class="headerlink" title="报单查询"></a>报单查询</h3><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012202107344.png" alt="image-20231012202107344"></p><p>菜单名称：经销商保单查询。后台人员审核完毕后，经销商课题通过此菜单查询系统历史保险上传情况和保单状态</p><h3 id="保证金转入"><a href="#保证金转入" class="headerlink" title="保证金转入"></a>保证金转入</h3><ul><li>经销商将履约保证金直接汇入以下账户：户名： 奇瑞徽银汽车金融股份有限公司开户行:  徽商银行安徽芜湖天门山支行账号： 1102101021000151488</li><li>在业务核心系统中将往来户金额转到对应保证金账户。</li><li>根据实际资金使用需求，转入相应的保证金。</li></ul><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012202225275.png" alt="image-20231012202225275"></p><p>菜单名称：经销商保证金转入（可查看转入的金额——往来户余额）。</p><p>选择保证金类型：经销商贷款保证金，选择销售公司，输入金额后提交。</p><h3 id="月度结息"><a href="#月度结息" class="headerlink" title="月度结息"></a>月度结息</h3><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012202318379.png" alt="image-20231012202318379"></p><p>菜单名称：采购车辆贷款还款试算。</p><p>每月20日前，点击本月结息试算功能按钮后，经销商将系统试算的结息金额汇入我司对公账户中，20日晚上日终会自动从往来户账户余额中扣款。</p><h3 id="贷款还款"><a href="#贷款还款" class="headerlink" title="贷款还款"></a>贷款还款</h3><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012202518769.png" alt="image-20231012202518769"></p><p>菜单名称：采购车辆贷款还款。可通过还款试算功能试算赎证需要的金额，将款项打入我司对公账户后，搜索需要赎证还款的车架号,勾选后点击提交还款，弹出还款明细信息，确认后点击确认还款。系统提示还款成功。</p><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><h3 id="申请人材料"><a href="#申请人材料" class="headerlink" title="申请人材料"></a>申请人材料</h3><table><thead><tr><th align="center"><strong>材料明细</strong></th><th align="center"><strong>新申请</strong>&#x2F;续授信</th><th align="center"><strong>增加授信</strong></th><th align="center"><strong>额度释放</strong></th></tr></thead><tbody><tr><td align="center">贷款申请表</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">营业执照、公司章程</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">经营品牌授权文件</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">股东会决议</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">法定代表人身份证</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">自然人股东身份证</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">法人股东营业执照、公司章程</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">经营场所证明文件</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">财务报表</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">账户信息</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">工资单&#x2F;社保缴费证明</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="经销商贷款申请表"><a href="#经销商贷款申请表" class="headerlink" title="经销商贷款申请表"></a>经销商贷款申请表</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012202746616.png" alt="image-20231012202746616"></p><p>金融公司提供模板，信息填写要完整，要求如下：</p><p>①客户全称、法定代表人应与工商登记信息一致；</p><p>②经营区域一般为经销商所在城市；</p><p>③原件加盖公章；</p><p>④<strong>申请日期与股东会决议日期保持一致或略晚于股东会决议日期</strong>。</p><h4 id="营业执照"><a href="#营业执照" class="headerlink" title="营业执照"></a>营业执照</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012203017325.png" alt="image-20231012203017325"></p><p>正本、副本均可。要求如下：</p><p>①有效期内，相关信息须与工商注册登记信息一致；</p><p>②申请人营业执照营业范围含“汽车销售”字段；</p><p>③复印件（加盖公章）【盖上鲜红的公章】；</p><p>④如营业执照到期更新后及时发送给金融公司。</p><h4 id="公司章程"><a href="#公司章程" class="headerlink" title="公司章程"></a>公司章程</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012203203497.png" alt="image-20231012203203497"></p><p>要求如下：</p><p>①相关信息须与工商注册登记信息一致，并体现历史变更信息；</p><p>②复印件（加盖公章）；</p><p>③公司章程结尾处按章程要求进行股东签字&#x2F;盖章。</p><h4 id="经销商授权书"><a href="#经销商授权书" class="headerlink" title="经销商授权书"></a>经销商授权书</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012203233063.png" alt="image-20231012203233063"></p><p>要求如下：①复印件（加盖公章）；②如授权书到期更新后及时发送给金融公司。</p><h4 id="股东会决议"><a href="#股东会决议" class="headerlink" title="股东会决议"></a>股东会决议</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012203257107.png" alt="image-20231012203257107"></p><p>金融公司提供模板，信息填写要完整，要求如下：</p><p>①信息填写完整，金额填写正确，与申请金额一致；</p><p>②所有股东均须签字（特殊情况遵循章程约定）；</p><p>③原件（加盖公章）；</p><p>④日期不得晚于申请表日期。</p><h4 id="法定代表人身份证"><a href="#法定代表人身份证" class="headerlink" title="法定代表人身份证"></a>法定代表人身份证</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231012203404960.png" alt="image-20231012203404960"></p><p>要求如下：①复印件（正反面）；②有效期内；③加盖申请人公章；④如身份证件到期更新后及时发送给金融公司。</p><h4 id="租赁合同"><a href="#租赁合同" class="headerlink" title="租赁合同"></a>租赁合同</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092014048.png" alt="image-20231013092014048"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092018862.png" alt="image-20231013092018862"></p><p>自有、租赁均可。要求如下：</p><p>①如为自有经营场所，提供产权证复印件盖申请人公章；</p><p>②如为租赁经营场所，租赁合同在有效期内（加盖公章）；租赁场地与经销商经营场地一致；租赁合同有双方签字或盖章及签署日期；承租方非申请公司的，须提供相关书面说明，双方签字或盖章。</p><h4 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092103241.png" alt="image-20231013092103241"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092108974.png" alt="image-20231013092108974"></p><p>要求如下（资产负债表+利润表）：</p><p>①最近两年年报及最近一期的财务报表，公司成立不到两年的，须从成立当年开始提供；</p><p>②报表有审计的，须提供审计报告；</p><p>③报表真实、合理，勾稽关系、逻辑关系正确；</p><p>④最近一期报表资产负债率不得超过80%；</p><p>⑤<strong>财务报表录入系统即可，无需上传至影像。</strong></p><h4 id="工资单"><a href="#工资单" class="headerlink" title="工资单"></a>工资单</h4><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092158669.png" alt="image-20231013092158669"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092237501.png" alt="image-20231013092237501"></p><p>各地材料模板可不同，要求如下：</p><p>①复印件加盖公章；</p><p>②工资单&#x2F;社保缴费证明文件上需体现公司人数；</p><p>③提供其中一项资料即可。</p><h3 id="担保人材料"><a href="#担保人材料" class="headerlink" title="担保人材料"></a>担保人材料</h3><table><thead><tr><th align="center">主体</th><th align="center">材料明细</th><th align="center">新申请&#x2F;续授信</th><th align="center">增加授信</th><th align="center">额度释放</th></tr></thead><tbody><tr><td align="center">自然人担保</td><td align="center">担保人身份证</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">自然人担保</td><td align="center">担保人配偶身份证及婚姻证明</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">自然人担保</td><td align="center">资产&#x2F;收入类证明</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">法人担保（如有）</td><td align="center">营业执照、公司章程</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">法人担保（如有）</td><td align="center">法定代表人身份证</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">法人担保（如有）</td><td align="center">股东会决议</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">法人担保（如有）</td><td align="center">财务报表</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">法人担保（如有）</td><td align="center">账户信息</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">不动产抵押（如有）</td><td align="center">不动产权证</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">不动产抵押（如有）</td><td align="center">产权所有人身份证明</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="自然人担保"><a href="#自然人担保" class="headerlink" title="自然人担保"></a>自然人担保</h4><h5 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092709351.png" alt="image-20231013092709351"></p><p>要求如下：</p><p>①复印件（正反面）；</p><p>②有效期内；</p><p>③如身份证件到期更新后及时发送给金融公司。</p><h5 id="结婚证"><a href="#结婚证" class="headerlink" title="结婚证"></a>结婚证</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092743914.png" alt="image-20231013092743914"></p><p>要求如下：①身份信息页；②信息与身份证一致，如不一致，提供证明文件</p><h5 id="收入证明"><a href="#收入证明" class="headerlink" title="收入证明"></a>收入证明</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092814073.png" alt="image-20231013092814073"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092822463.png" alt="image-20231013092822463"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092828776.png" alt="image-20231013092828776"></p><p>要求如下：①工作类、收入类或财产类证明材料等（房产证、行驶证、发票、合同等）；</p><h4 id="法人企业担保"><a href="#法人企业担保" class="headerlink" title="法人企业担保"></a>法人企业担保</h4><h5 id="营业执照-1"><a href="#营业执照-1" class="headerlink" title="营业执照"></a>营业执照</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013092924123.png" alt="image-20231013092924123"></p><p>正本、副本均可。要求如下：</p><p>①有效期内，相关信息须与工商注册登记信息一致；</p><p>②复印件（加盖公章）；</p><p>③如营业执照到期更新后及时发送给金融公司。</p><h5 id="公司章程-1"><a href="#公司章程-1" class="headerlink" title="公司章程"></a>公司章程</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093022061.png" alt="image-20231013093022061"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093028875.png" alt="image-20231013093028875"></p><p>要求如下：</p><p>①相关信息须与工商注册登记信息一致，并体现历史变更信息；</p><p>②复印件（加盖公章）；</p><p>③公司章程结尾处按章程要求进行股东签字&#x2F;盖章。</p><h5 id="股东会决议-1"><a href="#股东会决议-1" class="headerlink" title="股东会决议"></a>股东会决议</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093118793.png" alt="image-20231013093118793"></p><p>金融公司提供模板，信息填写要完整，要求如下：</p><p>①信息填写完整，金额填写正确，与申请金额一致；</p><p>②所有股东均须签字（特殊情况遵循章程约定）；</p><p>③原件，加盖公章；</p><h5 id="资产负债表、利润表"><a href="#资产负债表、利润表" class="headerlink" title="资产负债表、利润表"></a>资产负债表、利润表</h5><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093155506.png" alt="image-20231013093155506"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093200510.png" alt="image-20231013093200510"></p><p>要求如下（资产负债表+利润表）：</p><p>①最近二年年报及最近一期的财务报表，公司成立不到二年的，须从成立当年开始提供；</p><p>②报表有审计的，须提供审计报告；</p><p>③加盖公章；</p><p>④报表真实、合理，勾稽关系、逻辑关系正确。</p><h3 id="抵质押"><a href="#抵质押" class="headerlink" title="抵质押"></a>抵质押</h3><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093252133.png" alt="image-20231013093252133"></p><p>要求如下：①复印件；②未抵押在其他金融机构。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093316220.png" alt="image-20231013093316220"></p><p>要求如下：①复印件（正反面）；②有效期内；③如身份证件到期更新后及时发送给金融公司。</p><h2 id="合同、协议签署"><a href="#合同、协议签署" class="headerlink" title="合同、协议签署"></a>合同、协议签署</h2><p>借款合同，保证担保，征信授权，浮动抵押合同。</p><h2 id="审批通知书"><a href="#审批通知书" class="headerlink" title="审批通知书"></a>审批通知书</h2><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093511951.png" alt="image-20231013093511951"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093515562.png" alt="image-20231013093515562"></p><p>流程结束后经销商会接收到审批结果通知，落实担保条件，签署相关授信合同。此待办可点击提交关闭。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093534197.png" alt="image-20231013093534197"></p><p>相关合同、协议的签署采用上上签电子签约的方式进行，具体签约步骤如下：</p><p>步骤一：收到签约短信，进行登录。</p><p>步骤二：进行身份证实名认证，需要刷脸认证，如果刷脸失败，手持证件认证（需一个工作日）</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093548269.png" alt="image-20231013093548269"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093552521.png" alt="image-20231013093552521"></p><p>企业法人实名认证：需上传法定代表人身份证件照片，由法定代表人刷脸实名认证！</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093621702.png" alt="image-20231013093621702"></p><p>步骤三：认证成功后进行合同协议的签署（需签署文件类型有：征信查询授权书和循环借款合同、保证合同、浮动抵押合同）；根据提示操作，完成后会提示签署成功。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093636832.png" alt="image-20231013093636832"></p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093641429.png" alt="image-20231013093641429"></p><p>登录网址可以查看合同签署状态，也可以对未签署合同进行批量签署注：夫妻双方需按顺序签署在一个合同上，其中一人签署完毕后，另一人才能收到短信签署链接进行签署。</p><p><img src="/../../../../../pic/%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/image-20231013093655906.png" alt="image-20231013093655906"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;经销商新车采购车辆贷款系统申请指引&quot;&gt;&lt;a href=&quot;#经销商新</summary>
      
    
    
    
    <category term="大区工作" scheme="http://example.com/categories/%E5%A4%A7%E5%8C%BA%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="业务学习" scheme="http://example.com/categories/%E5%A4%A7%E5%8C%BA%E5%B7%A5%E4%BD%9C/%E4%B8%9A%E5%8A%A1%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对公业务" scheme="http://example.com/categories/%E5%A4%A7%E5%8C%BA%E5%B7%A5%E4%BD%9C/%E4%B8%9A%E5%8A%A1%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E5%85%AC%E4%B8%9A%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/08/%E8%BD%AF%E8%80%83/%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2023/10/08/%E8%BD%AF%E8%80%83/%E7%BD%91%E7%BB%9C/</id>
    <published>2023-10-08T12:49:24.388Z</published>
    <updated>2023-10-08T12:49:36.425Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="软考计算机网络"><a href="#软考计算机网络" class="headerlink" title="软考计算机网络"></a><a href="https://www.cnblogs.com/gh110/p/11827738.html">软考计算机网络</a></h1><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li><ul><li><p><a href="https://www.cnblogs.com/gh110/p/11827738.html#_1">考点归纳</a></p></li><li><ul><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#1_2">1、网络基础</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#2_4">2、网络协议</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#3_6">3、网络设备</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#4IP_8">4、IP地址</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#5_10">5、网络管理</a></li></ul></li><li><p><a href="https://www.cnblogs.com/gh110/p/11827738.html#_13">一、网络的功能、分类与组成</a></p></li><li><ul><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_14">一、计算机网络定义</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_17">二、计算机网络的分类</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_99">三、计算机网络的组成</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#NIC_104">四、网卡（NIC）</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#Repeater_108">五、中继器(Repeater)</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_111">六、集线器</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_116">七、交换机</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_129">八、路由器</a></li></ul></li><li><p><a href="https://www.cnblogs.com/gh110/p/11827738.html#_135">二、网络协议与标准</a></p></li><li><ul><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#OSI_136">一、OSI网络参考模型</a></li></ul></li><li><p><a href="https://www.cnblogs.com/gh110/p/11827738.html#_178">三、网络结构与通信</a></p></li><li><ul><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_179">一、按拓扑结构分类</a></li><li><a href="https://www.cnblogs.com/gh110/p/11827738.html#_216">二、典型拓扑结构图</a></li></ul></li></ul></li></ul><h2 id="考点归纳"><a href="#考点归纳" class="headerlink" title="考点归纳"></a>考点归纳</h2><h3 id="1、网络基础"><a href="#1、网络基础" class="headerlink" title="1、网络基础"></a>1、网络基础</h3><p>网络的分类、网络拓扑结构、OSI参考模型</p><h3 id="2、网络协议"><a href="#2、网络协议" class="headerlink" title="2、网络协议"></a>2、网络协议</h3><p>各种常见的网络协议及各协议对应的网络层次</p><h3 id="3、网络设备"><a href="#3、网络设备" class="headerlink" title="3、网络设备"></a>3、网络设备</h3><p>各类双绞线、各类光纤、交换机、三层交换机、路由器、网卡、网桥、集线器等</p><h3 id="4、IP地址"><a href="#4、IP地址" class="headerlink" title="4、IP地址"></a>4、IP地址</h3><p>一些常见的具体特殊作用的IP地址、子网掩码、子网划分及路由汇聚</p><h3 id="5、网络管理"><a href="#5、网络管理" class="headerlink" title="5、网络管理"></a>5、网络管理</h3><p>基本概念、网络管理协议、网络管理常用命令</p><h2 id="一、网络的功能、分类与组成"><a href="#一、网络的功能、分类与组成" class="headerlink" title="一、网络的功能、分类与组成"></a>一、网络的功能、分类与组成</h2><h3 id="一、计算机网络定义"><a href="#一、计算机网络定义" class="headerlink" title="一、计算机网络定义"></a>一、计算机网络定义</h3><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p><h3 id="二、计算机网络的分类"><a href="#二、计算机网络的分类" class="headerlink" title="二、计算机网络的分类"></a>二、计算机网络的分类</h3><blockquote><p><strong>按传输距离分为</strong>局域网(LAN) 一般分布在几米到几公里范围。城域网(MAN) 一般分布在几公里到几十公里或一个城区。广域网(WAN) 一般分布在数十公里到几千公里。<strong>按工作模式分为</strong>对等网络基于服务器的网络<strong>按传输介质分为</strong>有线网络分为双绞线网络、同轴电缆网络、光纤网络、光纤同轴混合网络等。无线网络分为无线电、微波、红外等。</p></blockquote><ul><li><strong>1、双绞线</strong>把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。<img src="https://img-blog.csdnimg.cn/20191004105027505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191004105203383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><strong>(1)布线标准</strong>EIA&#x2F;TIA的布线标准中规定了两种双绞线的线序，分别是 T568A与T568B T568A线序为：白绿 绿 白橙 蓝 白蓝 橙 白棕 棕T568B线序为：白橙 橙 白绿 蓝 白蓝 绿 白棕 棕<img src="https://img-blog.csdnimg.cn/20191004105606257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>(2) 直通线与交叉线</strong></p><ul><li>直通线：是指线缆两端的线序排列完全相同的网线(两端全 部使用T568A，或者两端全部使用T568B)。</li><li>交叉线：是指线缆两端的线序一端按照T568A标准连接， 另一端按照T568B标准连接。<img src="https://img-blog.csdnimg.cn/20191004105658533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>2、同轴电缆</strong>由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层以及保护塑料外层所组成，广泛用于传输较高速率的数据。<img src="https://img-blog.csdnimg.cn/2019100410575478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>3、光纤</strong>是光导纤维的简写，是一种由玻璃或塑料制成的纤维，可作为光传导工具。传输原理是光的全反射。<img src="https://img-blog.csdnimg.cn/20191004105841161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">光纤按传输方式可分为 </span><br><span class="line"> 多模光纤 </span><br><span class="line"> 单模光纤 </span><br></pre></td></tr></table></figure><p><strong>1．多模光纤</strong>多模光纤是在给定的工作波长上能以多个模式同时传输的光纤。<img src="https://img-blog.csdnimg.cn/20191004105928280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>多模光纤的光源为发光二极管，发出的可见光定向性较差，光以 不同的角度进入纤芯。存在许多条不同角度入射的光线在一条光纤中传输，多模光纤适合于近距离传输。<img src="https://img-blog.csdnimg.cn/20191004110023781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>2．单模光纤</strong>单模光纤的直径减小到只有一个光的波长大小，它可使光线沿直线传播，而不会产生多次反射。传输频带宽，传输容量大。 单模光纤的光源使用定向型很好的激光二极管。 单模光纤的损耗较小，传输距离远。<img src="https://img-blog.csdnimg.cn/20191004110110691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191004110129390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>3、无线电</strong>无线电的频带是有限的。上限为在300GHz（吉赫弦），而下限 频率在各类规范中不统一，常见的说法有三种分别为3kHz～ 300GHz（国际电信联盟规定）、9kHz～300GHz、10kHz～ 300GHz。<ul><li>中波主要沿地面传播，绕射能力强，适用于广播和海上通信。</li><li>短波具有较强的电离层反射能力，适用于环球通信</li><li>超短波和微波的绕射能力较差，可作为视距或超视距中继通信。</li></ul></li><li><strong>4、微波</strong>微波是指频率在0.3GHz～300GHz范围的电磁波，目前主要是使用2GHz～40GHz的频率范围。陆地微波系统的主要用途是完成远距离远程通信服务和楼宇间 建立短距离的点对点通信。</li><li><strong>5、红外线</strong>红外线的主要特点<ul><li>(1)不能穿透坚实的物体，防窃听的安全性要比无线电系统好。</li><li>(2)几乎不会受到电气、天电、人为干扰，抗干扰性强。</li><li>(3)红外线通信机体积小，重量轻，结构简单，价格低廉。</li><li>(4)必须在直视距离内通信，且传播受天气的影响。</li></ul></li><li><strong>6、激光</strong>激光通信系统组成设备包括发送和接收两个部分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">激光通信的优点：  通信容量大。  保密性强。  结构轻便，设备经济。 </span><br><span class="line">激光通信的缺点：  距离限于视距（数公里至数十公里范围），易受气候影响。 </span><br><span class="line"> 瞄准困难。激光束有极高的方向性，这给发射和接收点之间 的瞄准带来不少困难。</span><br></pre></td></tr></table></figure><h3 id="三、计算机网络的组成"><a href="#三、计算机网络的组成" class="headerlink" title="三、计算机网络的组成"></a>三、计算机网络的组成</h3><p>计算机网络由资源子网和通信子网组成。1.服务器 2.工作站 3.通信设备 4.传输介质<img src="https://img-blog.csdnimg.cn/20191004110632275.png" alt="在这里插入图片描述"></p><h3 id="四、网卡（NIC）"><a href="#四、网卡（NIC）" class="headerlink" title="四、网卡（NIC）"></a>四、网卡（NIC）</h3><p>又称网络适配器。用于计算机和网络电缆之间的物理连接。 网卡完成物理层和数据链路层的大部分功能。每块网卡都有一个唯一的地址，称为MAC地址或物理地址， 采用十六进制数表示，共六个字节（48位）。前三个字节是 厂家编码，后三个字节由各厂家自行指派。</p><h3 id="五、中继器-Repeater"><a href="#五、中继器-Repeater" class="headerlink" title="五、中继器(Repeater)"></a>五、中继器(Repeater)</h3><p>是工作在物理层设备。适用于完全相同的两类网络的互连， 主要功能是通过对数据信号的复制、整形、放大再发送，来扩大网络传输的距离。</p><h3 id="六、集线器"><a href="#六、集线器" class="headerlink" title="六、集线器"></a>六、集线器</h3><p>具有中继器的功能，区别在于集线器能够提供多端口服务， 也称多口中继器。集线器是物理层设备。集线器不具备交换机所具有的MAC地址表，所以它发送数据时是没有针对性的，而是采用广播方式发送。集线器所有端口是一个冲突域，所有的端口是一个广播域。</p><h3 id="七、交换机"><a href="#七、交换机" class="headerlink" title="七、交换机"></a>七、交换机</h3><p>也称多端口网桥，工作在数据链路层，能够识别帧的内容。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。交换机每一个端口是一个冲突域，所有的端口是一个广播域。</p><p><strong>二层交换与三层交换</strong>1)二层交换二层交换是以硬件的方式执行网桥的功能。通过MAC地址进 行转发，同时将端口、所涉及的MAC地址及对应关系记录在地址表中。</p><p><strong>2)三层交换</strong>三层交换技术就是：二层交换技术+三层转发技术，它解决了 局域网中网段划分之后，网段中子网必须依赖路由器进行管理 的局面。三层交换机在对第一个数据流进行路由后，会产生一个MAC 地址与IP地址的映射表，当同样的数据流再次通过时，将根据 此表直接从二层交换而不是再次路由，从而消除了路由器进行 路由选择而造成网络的延迟，提高了数据包转发的效率。</p><h3 id="八、路由器"><a href="#八、路由器" class="headerlink" title="八、路由器"></a>八、路由器</h3><p>路由器是网络层的互联设备，用于连接多个逻辑上分开的网络， 所谓逻辑网络就是拥有独立网络地址的网络。路由器的工作就是为经过路由器的每个数据帧寻找一条最佳传 输路径，并将该数据帧有效地传送到目的站点。路由器每个端口是一个冲突域，每个端口是一个广播域。</p><p><img src="https://img-blog.csdnimg.cn/20191004111113204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="二、网络协议与标准"><a href="#二、网络协议与标准" class="headerlink" title="二、网络协议与标准"></a>二、网络协议与标准</h2><h3 id="一、OSI网络参考模型"><a href="#一、OSI网络参考模型" class="headerlink" title="一、OSI网络参考模型"></a>一、OSI网络参考模型</h3><blockquote><p>1.物理层 2.数据链路层 3.网络层 4.传输层 5.会话层 6.表示层 7.应用层<img src="https://img-blog.csdnimg.cn/20191004111458202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191004111531368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p><strong>1、物理层</strong>是OSI参考模型的最低层或第一层。 物理层协议要解决的是主机、工作站等数据终端设备与通信 线路上通信设备之间的接口问题。</p><blockquote><p>用4个技术特性来描述：  机械特性  电气特性  功能特性  规程特性<strong>(1)机械特性</strong>规定了DTE和DCE之间的连接器形式，包括连接器形状、几何尺寸、引线数目和排列方式等。<strong>(2)电气特性</strong>规定了发送器和接收器的电气参数及其他有关电路的特征。如1和0的各自电压的大小,每比特持续多少微秒等。电气特性决定了传送 速率和传输距离。<strong>(3)功能特性</strong>接口信号分为数据信号、控制信号和时钟信号。功能特性对接口各信号线的功能给出确切的定义，说明某些连线上出现的某一电压表示的意义。<strong>(4)规程特性</strong>规定了DTE和DCE之间各接口信号线实现数据传输的操作过程 （操作顺序）。</p></blockquote></li><li><p><strong>2、数据链路层(DataLink)</strong>建立、维持和释放网络实体之间的数据链路，这种数据链路对网络层表现为一条无差错的信道。数据链路层通常把流量控制和差错控制合并在一起。数据链路层分为MAC（媒介访问控制层）和LLC（逻辑链路控制层）。服务访问点为MAC地址。</p></li><li><p><strong>3、网络层(Network)</strong>属于通信子网，网络层解决的问题是路由选择、网络拥塞、异构网络互联等问题，其服务访问点为逻辑地址（网络地址）。 代表性协议有IP，IPX协议等。</p></li><li><p><strong>4、传输层( Transport)</strong>实现发送端和接收端的端到端的数据分组传送，负责保证实现数据包无差错、按顺序、无丢失和无冗余的传输。服务访问点为端口。 代表性协议有TCP，UDP，SPX协议等。</p></li><li><p><strong>5、会话层( Session)</strong>会话层主要功能是管理和协调不同主机上各种进程之间的通 信（对话），即负责建立、管理和终止应用程序之间的会话。</p></li><li><p><strong>6、表示层(Prsentation)</strong>表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。应用层可以根据其服务解释数据的含义。通常包括数据编码的约定、本地句法的转换、数据压缩与解压缩。例如，JPEG， ASCII，GIF，DES，MPEG等</p></li><li><p><strong>7、应用层(Application)</strong>直接为端用户服务，提供各类应用程序的接口和用户接口。例如，HTTP，Telnet，FTP，SMTP等。<img src="https://img-blog.csdnimg.cn/20191004115316145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="三、网络结构与通信"><a href="#三、网络结构与通信" class="headerlink" title="三、网络结构与通信"></a>三、网络结构与通信</h2><h3 id="一、按拓扑结构分类"><a href="#一、按拓扑结构分类" class="headerlink" title="一、按拓扑结构分类"></a>一、按拓扑结构分类</h3><p><strong>按拓扑结构可将计算机网络分为</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 总线型拓扑结构  星型拓扑结构  环型拓扑结构</span><br><span class="line"> 树型拓扑结构  网状拓扑结构</span><br></pre></td></tr></table></figure><p><strong>1、总线型拓扑结构</strong>用单总线把各计算机连接起来。优点：建网容易，增减节点方便，节省线路。缺点：重负载时通信效率不高。<img src="https://img-blog.csdnimg.cn/20191004112440364.png" alt="在这里插入图片描述"></p><p><strong>2、星型拓扑结构</strong>每个终端或计算机都以单独（专用）的线路与中央设备相连。中央设备一般是交换机（集线器）。优点：结构简单，建网容易，延迟小，便于管理。缺点：成本高，中心节点成为系统的瓶颈。<img src="https://img-blog.csdnimg.cn/20191004112527428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>3、环型拓扑结构</strong>所有计算机和接口设备连接成一个环，可以是单环，也可以是双环。环中信号是单向传输的。双环网络中两个环上信号的传输方向相反。 特别适合实时控制的局域网系统。<img src="https://img-blog.csdnimg.cn/20191004112552301.png" alt="在这里插入图片描述"></p><p><strong>4、树型拓扑结构</strong>节点组织成树状结构，具有层次性。它具有较强的可折叠性，非常适用于构建网络主干，还能够有效地保护布线投资。这种拓扑结构的网络一般采用光纤作为网络主干，用于军事单位，政府单位等上、下界限相当严格和层次分明的部门。<img src="https://img-blog.csdnimg.cn/20191004112659501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>5、网状拓扑结构</strong>每个节点至少有两条路径与其他节点相连。</p><ul><li>优点：可靠性高、可改善线路的信息流量分配、可选择最佳路径，传输延迟小。</li><li>缺点：控制复杂，线路成本高。</li></ul><p>网状拓扑结构一般用于Internet骨干网上。</p><p><img src="https://img-blog.csdnimg.cn/20191004112625358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="二、典型拓扑结构图"><a href="#二、典型拓扑结构图" class="headerlink" title="二、典型拓扑结构图"></a>二、典型拓扑结构图</h3><p><img src="https://img-blog.csdnimg.cn/20191004112759134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2doYW4xMTA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>欢迎查阅</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;软考计算机网络&quot;&gt;&lt;a href=&quot;#软考计算机网络&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>汽车贷款管理办法</title>
    <link href="http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.2%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.2%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/</id>
    <published>2023-09-29T12:06:15.000Z</published>
    <updated>2023-10-04T11:31:58.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>(2017 年 10 月 13 日中国人民银行 中国银行业监督管理委员</p><p>会令 〔2017〕 第 2 号发布  自 2018 年 1 月 1  日起施行)</p></blockquote><h1 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章  总则"></a>第一章  总则</h1><p>第一条  为规范汽车贷款业务管理，防范汽车贷款风险，促 进汽车贷款业务健康发展，根据《中华人民共和国中国人民银行 法》、《中华人民共和国银行业监督管理法》、《中华人民共和国商业银行法》等法律规定 ， 制定本办法。</p><p>第二条  本办法所称汽车贷款是指<strong>贷款人向借款人发放的用于购买汽车（含二手车）的贷款</strong>，包括个人汽车贷款、经销商汽车贷款和机构汽车贷款。</p><p>第三条  本办法所称贷款人是指在中华人民共和国境内依 法设立的、经中国银行业监督管理委员会及其派出机构批准经营人民币贷款业务的商业银行、农村合作银行、农村信用社及获准经营汽车贷款业务的非银行金融机构。</p><p>第四条  本办法所称<strong>自用车</strong>是指借款人<strong>通过汽车贷款购买的、不以营利为目的的汽车</strong>；<strong>商用车</strong>是指借款人通过汽车贷款购买的 、<strong>以营利为目的的汽车</strong>；<strong>二手车</strong>是指从办理完注册登记手续到达到国家强制报废标准之前进行所有权变更并依法办理过户手续的汽车；<strong>新能源汽车</strong>是指采用新型动力系统，完全或者主要依靠新型能源驱动的汽车，包括<strong>插电式混合动力（含增程式）汽车、纯电动汽车和燃料电池汽车</strong>等。</p><p>第五条  汽车贷款利率按照中国人民银行公布的贷款利率规定执行 ， 计、结息办法由借款人和贷款人协商确定。</p><p>第六条  <strong>汽车贷款的贷款期限（含展期）不得超过 5 年</strong>，其 中 ，<strong>二手车贷款的贷款期限（含展期）不得超过 3 年</strong>，<strong>经销商汽车贷款的贷款期限不得超过 1 年。</strong></p><p>第七条  借贷双方应当遵循平等 、自愿、诚实、守信的原则。</p><h1 id="第二章-个人汽车贷款"><a href="#第二章-个人汽车贷款" class="headerlink" title="第二章  个人汽车贷款"></a>第二章  个人汽车贷款</h1><p>第八条  本办法所称个人汽车贷款，是指贷款人向个人借款人发放的用于购买汽车的贷款。</p><p>第九条  借款人申请个人汽车贷款 ， 应当同时符合以下条件：</p><p>（ 一 ）是中华人民共和国公民，或在中华人民共和国境内连续居住一年（含一年） 以上的港 、澳、 台居民及外国人；</p><p>（ 二 ）具有有效身份证明、固定和详细住址且具有完全民事行为能力；</p><p>（三）具有稳定的合法收入或足够偿还贷款本息的个人合法资产；</p><p>（四）个人信用良好；</p><p>（五） 能够支付规定的首期付款；</p><p>（六） 贷款人要求的其他条件。</p><p>第十条  贷款人发放个人汽车贷款 ， 应综合考虑以下因素，确定贷款金额、期限、利率和还本付息方式等贷款条件：</p><p>（ 一 ）贷款人对借款人的信用评级情况；</p><p>（ 二 ）贷款担保情况；</p><p>（三）所购汽车的性能及用途；</p><p>（四） 汽车行业发展和汽车市场供求情况。</p><p>第十一条  贷款人应当<strong>建立借款人信贷档案</strong>。借款人信贷档</p><p>案应载明以下内容：</p><p>（ 一 ）借款人姓名 、住址 、有效身份证明及有效联系方式；</p><p>（ 二 ）借款人的收入水平及信用状况证明；</p><p>（三）所购汽车的购车协议、汽车型号、发动机号、车架号、价格与购车用途；</p><p>（四） 贷款的金额 、期限 、利率 、还款方式和担保情况；</p><p>（五） 贷款催收记录；</p><p>（六） 防范贷款风险所需的其他资料。</p><p>第十二条  贷款人发放个人商用车贷款，除本办法第十一条 规定的内容外，应在借款人信贷档案中增加商用车运营资格证年检情况、商用车折旧、保险情况等内容。</p><h1 id="第三章-经销商汽车贷款"><a href="#第三章-经销商汽车贷款" class="headerlink" title="第三章  经销商汽车贷款"></a>第三章  经销商汽车贷款</h1><p>第十三条  本办法所称经销商汽车贷款，是指<strong>贷款人向汽车经销商发放的用于采购车辆、零配件的贷款</strong>。</p><p>第十四条  借款人申请经销商汽车贷款，应当同时符合以下条件：</p><p>（ 一 ）具有工商行政主管部门核发的<strong>企业法人营业执照</strong>；</p><p>（ 二 ）具有汽车生产商出具的<strong>代理销售汽车证明</strong>；</p><p>（三） <strong>资产负债率不超过 80%；</strong></p><p>（四） 具有稳定的合法收入或足够偿还贷款本息的合法资产；</p><p>（五）经销商、经销商高级管理人员及经销商代为受理贷款申请的客户无重大违约行为或信用不良记录；</p><p>（六） 贷款人要求的其他条件。</p><p>第十五条  贷款人应为每个经销商借款人建立独立的信贷档案 ， 并及时更新 。经销商信贷档案应载明以下内容：</p><p>（ 一 ）经销商的名称、法定代表人及营业地址；</p><p>（ 二 ）各类营业证照复印件；</p><p>（三）经销商购买保险、商业信用及财务状况； </p><p>（四）所购汽车及零部件的型号 、价格及用途；</p><p>（五） 贷款担保状况；</p><p>（六） 防范贷款风险所需的其他资料。</p><p>第十六条  <strong>贷款人对经销商采购车辆、零配件贷款的贷款金额应以经销商一段期间的平均存货为依据，具体期间应视经销商存货周转情况而定。</strong></p><p>第十七条  <strong>贷款人应通过定期清点经销商采购车辆、零配件 存货，以及分析经销商财务报表等方式，定期对经销商进行信用审查 ， 并视审查结果调整经销商信用级别和清点存货的频率。</strong></p><h1 id="第四章-机构汽车贷款"><a href="#第四章-机构汽车贷款" class="headerlink" title="第四章  机构汽车贷款"></a>第四章  机构汽车贷款</h1><p>第十八条  本办法所称机构汽车贷款，是指贷款人对除经销 商以外的法人、其他经济组织（以下简称机构借款人）发放的用于购买汽车的贷款。</p><p>第十九条  借款人申请机构汽车贷款，必须同时符合以下条件：</p><p>（ 一 ）具有企业或事业单位登记管理机关核发的企业法人营 业执照或事业单位法人证书及法人分支机构营业执照、个体工商户营业执照等证明借款人主体资格的法定文件；</p><p>（ 二 ）具有合法、稳定的收入或足够偿还贷款本息的合法资产；</p><p>（三） 能够支付规定的首期付款；</p><p>（四） 无重大违约行为或信用不良记录；</p><p>（五） 贷款人要求的其他条件。</p><p>第二十条  贷款人应参照本办法第十五条的规定为每个机构借款人建立独立的信贷档案 ， 加强信贷风险跟踪监测。</p><p>第二十一条  贷款人对从事汽车租赁业务的机构发放机构 商用车贷款，应监测借款人对残值的估算方式，防范残值估计过高给贷款人带来的风险。</p><h1 id="第五章-风险管理"><a href="#第五章-风险管理" class="headerlink" title="第五章  风险管理"></a>第五章  风险管理</h1><p>第二十二条  汽车贷款发放实施<strong>贷款最高发放比例要求制度</strong> ， 贷款人发放的汽车贷款金额占借款人所购汽车价格的比例， 不得超过贷款最高发放比例要求；贷款最高发放比例要求由中国人民银行 、中国银行业监督管理委员会根据宏观经济、行业发展等实际情况另行规定。</p><p>前款所称<strong>汽车价格</strong>，<u>对新车是指<strong>汽车实际成交价格</strong>（扣除政 府补贴，且<strong>不含各类附加税、费及保费等</strong>）与汽车生产商公布的价格的较低者，对二手车是指汽车实际成交价格（扣除政府补贴，且不含各类附加税 、费及保费等） 与贷款人评估价格的较低者。</u></p><p>第二十三条  贷款人应建立借款人信用评级系统，审慎使用 外部信用评级，通过内外评级结合，确定借款人的信用级别 。对 个人借款人，应根据其职业、收入状况 、还款能力 、信用记录等 因素确定信用级别；对经销商及机构借款人，应根据其信贷档案 所反映的情况、高级管理人员的信用情况、财务状况 、信用记录等因素确定信用级别。</p><p>第二十四条  贷款人发放汽车贷款，应要求借款人提供所购 汽车抵押或其他有效担保 。经贷款人审查 、评估，确认借款人信用良好 ， 确能偿还贷款的 ， 可以不提供担保。</p><p>第二十五条  贷款人应直接或委托指定经销商受理汽车贷款申请，完善审贷分离制度，加强贷前审查和贷后跟踪催收工作。</p><p>第二十六条  贷款人应建立二手车市场信息数据库和二手车残值估算体系。</p><p>第二十七条  贷款人应根据贷款金额、贷款地区分布、借款人财务状况、汽车品牌、抵押担保等因素建立汽车贷款分类监控 系统，对不同类别的汽车贷款风险进行定期检查 、评估。根据检查评估结果 ，及时调整各类汽车贷款的风险级别。</p><p>第二十八条  贷款人应建立汽车贷款预警监测分析系统，制定预警标准；超过预警标准后应采取重新评价贷款审批制度等措施。</p><p>第二十九条  贷款人应建立<strong>不良贷款分类处理制度和审慎的贷款损失准备制度</strong> ， 计提相应的风险准备。</p><p>第三十条  贷款人发放抵押贷款 ， 应审慎评估抵押物价值，充分考虑抵押物减值风险 ，设定<strong>抵押率上限</strong>。</p><p>第三十一条  贷款人应将汽车贷款的有关信息及时录入金融信用信息基础数据库。</p><h1 id="第六章-附则"><a href="#第六章-附则" class="headerlink" title="第六章  附则"></a>第六章  附则</h1><p>第三十二条  贷款人在从事汽车贷款业务时有违反本办法 规定之行为的，中国银行业监督管理委员会及其派出机构有权依 据《中华人民共和国银行业监督管理法》等法律规定对该贷款人 及其相关人员进行处罚。中国人民银行及其分支机构可以建议中 国银行业监督管理委员会及其派出机构对从事汽车贷款业务的贷款人违规行为进行监督检查。</p><p>第三十三条  贷款人对借款人发放的用于购买推土机、挖掘机、搅拌机 、泵机等工程车辆的贷款 ， 比照本办法执行。</p><p>第三十四条  本办法由中国人民银行和中国银行业监督管理委员会共同负责解释。</p><p>第三十五条  本办法自 2018 年 1 月 1  日起施行 。原《汽车 贷款管理办法》（中国人民银行 中国银行业监督管理委员会令</p><p>〔2004〕第 2 号发布） 同时废止。</p><p>- 9 -</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;(2017 年 10 月 13 日中国人民银行 中</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="法律合规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/"/>
    
    <category term="4.汽车金融类法律法规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    
    
  </entry>
  
  <entry>
    <title>个人贷款管理暂行办法</title>
    <link href="http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.3%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%B8%AA%E4%BA%BA%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E6%9A%82%E8%A1%8C%E5%8A%9E%E6%B3%95%20/"/>
    <id>http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.3%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%B8%AA%E4%BA%BA%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E6%9A%82%E8%A1%8C%E5%8A%9E%E6%B3%95%20/</id>
    <published>2023-09-29T12:06:15.000Z</published>
    <updated>2023-10-04T11:45:51.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p> (2010年2月12日中国银行业监督管理委员会令2010年第2号公布 自2010年2月20日起施行)</p></blockquote><h1 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章 总则"></a>第一章 总则</h1><p>第一条  为规范银行业金融机构个人贷款业务行为，加强个人贷款业务审慎经营管理，促进个人贷款业务健康发展，依据《中华人民共和国银行业监督管理法》、《中华人民共和国商业银行法》等法律法规，制定本办法。</p><p>第二条 中华人民共和国境内经中国银行业监督管理委员会批准设立的银行业金融机构（以下简称贷款人）经营个人贷款业务，应遵守本办法。</p><p>第三条 本办法所称<strong>个人贷款</strong>，是指贷款人向符合条件的<strong>自然人</strong>发放的用于个人消费、生产经营等用途的<strong>本外币贷款</strong>。</p><p>第四条 个人贷款应当遵循依法合规、审慎经营、平等自愿、公平诚信的原则。</p><p>第五条 贷款人应建立有效的个人贷款全流程管理机制，制订贷款管理制度及每一贷款品种的操作规程，明确相应贷款对象和范围，实施差别风险管理，建立贷款各操作环节的考核和问责机制。</p><p>第六条 贷款人应按区域、品种、客户群等维度建立个人贷款风险限额管理制度。</p><p>第七条 个人贷款用途应符合法律法规规定和国家有关政策，贷款人不得发放无指定用途的个人贷款。贷款人应加强贷款资金支付管理，有效防范个人贷款业务风险。</p><p>第八条 个人贷款的期限和利率应符合国家相关规定。</p><p>第九条  贷款人应建立借款人合理的收入偿债比例控制机制，结合借款人收入、负债、支出、贷款用途、担保情况等因素，合理确定贷款金额和期限，控制借款人每期还款额不超过其还款能力。</p><p>第十条 中国银行业监督管理委员会依照本办法对个人贷款业务实施监督管理。</p><h1 id="第二章-受理与调查"><a href="#第二章-受理与调查" class="headerlink" title="第二章  受理与调查"></a>第二章  受理与调查</h1><p>第十一条 个人贷款申请应具备以下条件：</p><p>（一）借款人为具有完全民事行为能力的中华人民共和国公民或符合国家有关规定的境外自然人；</p><p>（二）贷款用途明确合法； </p><p>（三）贷款申请数额、期限和币种合理；</p><p>（四）借款人具备还款意愿和还款能力；</p><p>（五）借款人信用状况良好，无重大不良信用记录；</p><p>（六）贷款人要求的其他条件。</p><p>第十二条  贷款人应要求借款人以<strong>书面形式</strong>提出个人贷款申请，并要求借款人提供能够证明其符合贷款条件的相关资料。</p><p>第十三条 贷款人受理借款人贷款申请后，应履行尽职调查职责，对个人贷款申请内容和相关情况的真实性、准确性、完整性进行调查核实，形成调查评价意见。</p><p>第十四条  贷款调查包括但不限于以下内容：</p><p>（一）借款人基本情况；</p><p>（二）借款人收入情况；</p><p>（三）借款用途；</p><p>（四）借款人还款来源、还款能力及还款方式；</p><p>（五）<strong>保证人担保意愿、担保能力或抵（质）押物价值及变现能力</strong>。</p><p>第十五条 贷款调查应以实地调查为主、间接调查为辅，采取现场核实、电话查问以及信息咨询等途径和方法。</p><p>第十六条  贷款人在不损害借款人合法权益和风险可控的前提下，可将贷款调查中的部分特定事项审慎委托第三方代为办理，但必须明确第三方的资质条件。</p><p>贷款人不得将贷款调查的全部事项委托第三方完成。</p><p>第十七条  贷款人应建立并严格执行贷款面谈制度。</p><p>通过电子银行渠道发放低风险质押贷款的，贷款人至少应当采取有效措施确定借款人真实身份。</p><h1 id="第三章-风险评价与审批"><a href="#第三章-风险评价与审批" class="headerlink" title="第三章 风险评价与审批"></a>第三章 风险评价与审批</h1><p>第十八条 贷款审查应对贷款调查内容的合法性、合理性、准确性进行全面审查，重点关注调查人的尽职情况和借款人的偿还能力、诚信状况、担保情况、抵（质）押比率、风险程度等。</p><p>第十九条  贷款风险评价应以分析借款人现金收入为基础，采取定量和定性分析方法，全面、动态地进行贷款审查和风险评估。贷款人应建立和完善借款人信用记录和评价体系。</p><p>第二十条 贷款人应根据审慎性原则，完善授权管理制度，规范审批操作流程，明确贷款审批权限，实行审贷分离和授权审批，确保贷款审批人员按照授权独立审批贷款。</p><p>第二十一条 对未获批准的个人贷款申请，贷款人应告知借款人。</p><p>第二十二条 <strong>贷款人应根据重大经济形势变化、违约率明显上升等异常情况，对贷款审批环节进行评价分析，及时、有针对性地调整审批政策，加强相关贷款的管理</strong>。</p><h1 id="第四章-协议与发放"><a href="#第四章-协议与发放" class="headerlink" title="第四章  协议与发放"></a>第四章  协议与发放</h1><p>第二十三条  贷款人应与借款人签订<strong>书面借款合同</strong>，需担保的应同时签订<strong>担保合同</strong>。贷款人应要求借款人当面签订借款合同及其他相关文件，但电子银行渠道办理的贷款除外。 </p><p>第二十四条 借款合同应符合《中华人民共和国合同法》的规定，明确约定各方当事人的诚信承诺和贷款资金的用途、支付对象（范围）、支付金额、支付条件、支付方式等。</p><p>借款合同应设立相关条款，明确借款人不履行合同或怠于履行合同时应当承担的违约责任。</p><p>第二十五条  贷款人应建立健全合同管理制度，有效防范个人贷款法律风险。借款合同采用格式条款的，应当维护借款人的合法权益，并予以公示。</p><p>第二十六条 贷款人应依照《中华人民共和国物权法》、《中华人民共和国担保法》等法律法规的相关规定，规范担保流程与操作。</p><p>按合同约定办理抵押物登记的，贷款人应当参与。贷款人委托第三方办理的，应对抵押物登记情况予以核实。</p><p>以保证方式担保的个人贷款，贷款人应由不少于两名信贷人员完成。</p><p>第二十七条  贷款人应加强对贷款的发放管理，遵循审贷与放贷分离的原则，设立独立的放款管理部门或岗位，负责落实放款条件、发放满足约定条件的个人贷款。</p><p>第二十八条  借款合同生效后，贷款人应按合同约定及时发放贷款。</p><h1 id="第五章-支付管理"><a href="#第五章-支付管理" class="headerlink" title="第五章  支付管理"></a>第五章  支付管理</h1><p>第二十九条  贷款人应按照借款合同约定，通过贷款人受托支付或借款人自主支付的方式对贷款资金的支付进行管理与控制。</p><p>贷款人受托支付是指贷款人根据借款人的提款申请和支付委托，将贷款资金支付给符合合同约定用途的借款人交易对象。</p><p>借款人自主支付是指贷款人根据借款人的提款申请将贷款资金直接发放至借款人账户，并由借款人自主支付给符合合同约定用途的借款人交易对象。</p><p>第三十条  个人贷款资金应当采用贷款人受托支付方式向借款人交易对象支付,但本办法第三十三条规定的情形除外。</p><p>第三十一条  采用贷款人受托支付的，贷款人应要求借款人在使用贷款时提出支付申请，并授权贷款人按合同约定方式支付贷款资金。</p><p>贷款人应在贷款资金发放前审核借款人相关交易资料和凭证是否符合合同约定条件，支付后做好有关细节的认定记录。</p><p>第三十二条 贷款人受托支付完成后，应详细记录资金流向，归集保存相关凭证。</p><p>第三十三条  有下列情形之一的个人贷款，经贷款人同意可以采取借款人自主支付方式：</p><p>（一）借款人无法事先确定具体交易对象且金额不超过三十万元人民币的；</p><p>（二）借款人交易对象不具备条件有效使用非现金结算方式的；</p><p>（三）贷款资金用于生产经营且金额不超过五十万元人民币的；</p><p>（四）法律法规规定的其他情形的。</p><p>第三十四条  采用借款人自主支付的，贷款人应与借款人在借款合同中事先约定，要求借款人定期报告或告知贷款人贷款资金支付情况。</p><p>贷款人应当通过账户分析、凭证查验或现场调查等方式，核查贷款支付是否符合约定用途。</p><h1 id="第六章-贷后管理"><a href="#第六章-贷后管理" class="headerlink" title="第六章 贷后管理"></a>第六章 贷后管理</h1><p>第三十五条 个人贷款支付后，贷款人应采取有效方式对贷款资金使用、借款人的信用及担保情况变化等进行跟踪检查和监控分析，确保贷款资产安全。</p><p>第三十六条 贷款人应区分个人贷款的品种、对象、金额等，确定贷款检查的相应方式、内容和频度。贷款人内部审计等部门应对贷款检查职能部门的工作质量进行抽查和评价。</p><p>第三十七条 贷款人应定期跟踪分析评估借款人履行借款合同约定内容的情况，并作为与借款人后续合作的信用评价基础。</p><p>第三十八条 贷款人应当按照法律法规规定和借款合同的约定，对借款人未按合同承诺提供真实、完整信息和未按合同约定用途使用、支付贷款等行为追究违约责任。</p><p>第三十九条 <strong>经贷款人同意，个人贷款可以展期。</strong></p><p><strong>一年以内（含）的个人贷款，展期期限累计不得超过原贷款期限；一年以上的个人贷款，展期期限累计与原贷款期限相加，不得超过该贷款品种规定的最长贷款期限。</strong></p><p>第四十条  贷款人应按照借款合同约定，收回贷款本息。</p><p>对于未按照借款合同约定偿还的贷款，贷款人应采取措施进行清收，或者协议重组。</p><h1 id="第七章-法律责任"><a href="#第七章-法律责任" class="headerlink" title="第七章 法律责任"></a>第七章 法律责任</h1><p>第四十一条 贷款人违反本办法规定办理个人贷款业务的，中国银行业监督管理委员会应当责令其限期改正。贷款人有下列情形之一的，中国银行业监督管理委员会可采取《中华人民共和国银行业监督管理法》第三十七条规定的监管措施：</p><p>（一）贷款调查、审查未尽职的；</p><p>（二）未按规定建立、执行贷款面谈、借款合同面签制度的；</p><p>（三）借款合同采用格式条款未公示的；</p><p>（四）违反本办法第二十七条规定的；</p><p>（五）支付管理不符合本办法要求的。</p><p>第四十二条  贷款人有下列情形之一的，中国银行业监督管理委员会除按本办法第四十一条采取监管措施外，还可根据《中华人民共和国银行业监督管理法》第四十六条、第四十八条规定对其进行处罚：</p><p>（一）发放不符合条件的个人贷款的；</p><p>（二）签订的借款合同不符合本办法规定的；</p><p>（三）违反本办法第七条规定的；</p><p>（四）将贷款调查的全部事项委托第三方完成的；</p><p>（五）超越或变相超越贷款权限审批贷款的；</p><p>（六）授意借款人虚构情节获得贷款的；</p><p>（七）对借款人违背借款合同约定的行为应发现而未发现，或虽发现但未采取有效措施的；</p><p>（八）严重违反本办法规定的审慎经营规则的其他情形的。</p><h1 id="第八章-附则"><a href="#第八章-附则" class="headerlink" title="第八章  附则"></a>第八章  附则</h1><p>第四十三条 以存单、国债或者中国银行业监督管理委员会认可的其他金融产品作质押发放的个人贷款，消费金融公司、汽车金融公司等非银行金融机构发放的个人贷款，可参照本办法执行。</p><p>银行业金融机构发放给农户用于生产性贷款等国家有专门政策规定的特殊类个人贷款，暂不执行本办法。</p><p>信用卡透支，不适用本办法。</p><p>第四十四条 个体工商户和农村承包经营户申请个人贷款用于生产经营且金额超过五十万元人民币的，按贷款用途适用相关贷款管理办法的规定。</p><p>第四十五条 贷款人应依照本办法制定个人贷款业务管理细则及操作规程。</p><p>第四十六条 本办法由中国银行业监督管理委员会负责解释。</p><p>第四十七条 本办法自发布之日起施行。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt; (2010年2月12日中国银行业监督管理委员会令</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="法律合规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/"/>
    
    <category term="4.汽车金融类法律法规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    
    
  </entry>
  
  <entry>
    <title>关于调整汽车贷款有关政策的通知</title>
    <link href="http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.4%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E5%85%B3%E4%BA%8E%E8%B0%83%E6%95%B4%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E6%9C%89%E5%85%B3%E6%94%BF%E7%AD%96%E7%9A%84%E9%80%9A%E7%9F%A5/"/>
    <id>http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.4%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E5%85%B3%E4%BA%8E%E8%B0%83%E6%95%B4%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E6%9C%89%E5%85%B3%E6%94%BF%E7%AD%96%E7%9A%84%E9%80%9A%E7%9F%A5/</id>
    <published>2023-09-29T12:06:15.000Z</published>
    <updated>2023-10-04T11:50:47.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>中国人民银行 中国银行业监督管理委员会</p><p>银发〔2017〕234号</p></blockquote><p>中国人民银行上海总部，各分行、营业管理部，各省会（首府）城市中心支行，各副省级城市中心支行；各省（自治区、直辖市）银监局；各国有商业银行、股份制商业银行，中国邮政储蓄银行：</p><p>为落实国务院调整经济结构的政策，释放多元化消费潜力，推动绿色环保产业经济发展，提升汽车消费信贷市场供给质效，根据《中国人民银行 银监会关于加大对新消费领域金融支持的指导意见》（银发〔2016〕92号），现将汽车贷款政策有关事项通知如下：</p><p>一、<strong>自用传统动力汽车贷款最高发放比例为80%，商用传统动力汽车贷款最高发放比例为70%；自用新能源汽车贷款最高发放比例为85%，商用新能源汽车贷款最高发放比例为75%；二手车贷款最高发放比例为70%。</strong></p><p>其中，对于实施新能源汽车贷款政策的车型范围，各金融机构可在《汽车贷款管理办法》基础上，根据自愿、审慎和风险可控原则，参考工业和信息化部发布的《新能源汽车推广应用推荐车型目录》执行。</p><p>二、各金融机构应结合本机构汽车贷款投放政策、风险防控等因素，根据借款人信用状况、还款能力等合理确定汽车贷款具体发放比例；切实加强汽车贷款全流程管理，强化贷前审查，不断完善客户资信评估体系，保证贷款第一还款来源能充分覆盖相应本金利息；不断加强残值经验数据积累，落实抵押品、质押品价值审慎评估政策，完善抵押品、质押品价值评估体系；完善贷款分类制度，加强不良贷款监控，足额计提相应<strong>拨备</strong>。</p><p>三、人民银行各分支机构、银监会各派出机构应强化对汽车贷款资产质量、机构稳健性的监测、分析和评估，及时发现、有效应对潜在风险，促进金融机构汽车贷款业务稳健运行。各金融机构在具体业务中遇到重大问题应及时向人民银行及其分支机构、银监会及其派出机构反映。</p><p>四、本通知自2018年1月1日起施行。</p><p>本通知所称金融机构是指在中华人民共和国境内依法设立的、经银监会批准经营人民币贷款业务的商业银行、农村合作银行、农村信用社及获准经营汽车贷款业务的非银行金融机构。</p><p>请人民银行上海总部、各分行、营业管理部、省会（首府）城市中心支行、副省级城市中心支行，各省、自治区、直辖市银监局将本通知联合转发至辖区内相关金融机构。</p><p>中国人民银行  银 监 会</p><p>2017年10月16日</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;中国人民银行 中国银行业监督管理委员会&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="法律合规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/"/>
    
    <category term="4.汽车金融类法律法规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    
    
  </entry>
  
  <entry>
    <title>3.文老师-操作系统.md</title>
    <link href="http://example.com/2023/09/29/%E8%BD%AF%E8%80%83/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/09/29/%E8%BD%AF%E8%80%83/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-09-29T12:05:15.000Z</published>
    <updated>2023-10-25T11:39:44.006Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008213804041.png" alt="image-20231008213804041"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008210620919-16967703815211.png" alt="image-20231008210620919"></p><h2 id="OS-两大作用"><a href="#OS-两大作用" class="headerlink" title="OS 两大作用"></a>OS 两大作用</h2><p>（1）通过资源管理<strong>提高计算机系统的效率</strong>。 （2）改善人机界面，向用户提供良好的工作环境。 </p><h2 id="OS-特征"><a href="#OS-特征" class="headerlink" title="OS 特征"></a>OS 特征</h2><p><strong>并发性</strong>、共享性、虚拟性、不确定性。 </p><h2 id="OS-功能"><a href="#OS-功能" class="headerlink" title="OS 功能"></a>OS 功能</h2><p>进程管理、文件管理、存储管理、设备管理、作业管理。 </p><h2 id="OS-分类-（考点）"><a href="#OS-分类-（考点）" class="headerlink" title="OS 分类 （考点）"></a>OS 分类 （考点）</h2><p>◆批处理操作系统:单道批处理和多道批处理【同时可以处理多个数据】(主机与外设可并行)。</p><p>◆分时操作系统:一个计算机系统与多个终端设备连接。将CPU（假定是单核CPU）的工作时间划分为许多<strong>很短的时间片</strong>，轮流为各个终端的用户服务【人无法察觉时间的间隔】。</p><p>◆实时操作系统:实时是指计算机对于外来信息能够以<strong>足够快的速度</strong>进行处理,并在<strong>被控对象允许</strong>的时间范围内做出快速反应。实时系统<strong>对交互能力要求不高</strong>,但要求<strong>可靠</strong>性有保障。</p><p>◆网络操作系统:是使联网计算机能方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。三种模式:集中模式、客户端&#x2F;服务器模式【CS模式】、对等模式【PPP模式，网络中的计算机既可以作为客户端也可以作为服务器】。</p><p>◆分布式操作系统:分布式计算机系统是由多个<strong>分散</strong>的计算机经连接而成的计算机系统，系统中的计算机无主、次之分，任意两台计算机可以通过通信交换信息。</p><p>◆微型计算机操作系统:简称<strong>微机操作系统</strong>，常用的有Windows、 Mac OS、Linux。</p><p>◆<strong>嵌入式操作系统</strong>（考点）</p><p>主要特点:</p><p>(1)微型化。从性能和成本角度考虑，希望占用的资源和系统代码量少，如内存少、字长短、运行速度有限、能源少(用微小型电池)。</p><p>(2)可定制。从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置，以满足不同应用需要。</p><p>(3)实时性。嵌入工操作系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键领域需要迅速响应的场合，所以对实时性要求较高。</p><p>(4)可靠性。系统构件、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施。</p><p>(5)易移植性。为了提高系统的易移植性，通常采用硬件抽象层和板级支撑包的底层设计技术。</p><p>嵌入式系统初始化过程按照<strong>自底向上、从硬件到软件的次序依次为</strong>:<u>片【芯片】级初始化→板【主板】级初始化→系统初始化</u>。</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008210709187.png" alt="image-20231008210709187"></p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程管理。实质上是对处理机的执行“时间”进行管理，采用多道程序等技术将CPU的时间合理地分配给每个任务，主要包括进程控制、进程同步、进程通信和进程调度。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>进程控制块PCB（唯一标志）、程序（描述进程要做什么）、数据（存放进程执行时所需数据）</p><h2 id="进程状态【考点】"><a href="#进程状态【考点】" class="headerlink" title="进程状态【考点】"></a>进程状态【考点】</h2><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008221134480.png" alt="image-20231008221134480"></p><p><strong>进程状态</strong>是指的在操作系统当中，对进程进行管理的时候，为进程指定了几种状态，以<u>便于给进程分配相应的资源，对其进行管理</u>。</p><p>最初将进程分为运行态，等待态和就绪态三种状态。</p><p><strong>运行态</strong>指的是某一个进程它所需要的所有资源都已经配足了，并且给它了CPU资源，这个时候它就<u>处于运行状态</u>。</p><p><strong>就绪状态</strong>: 某进程的其它所有资源都已经配足了，但<u>缺CPU资源</u>。</p><p><strong>等待&#x2F;阻塞状态</strong>: <u>除了没有CPU资源还缺其它的资源</u>（比如与外设有交互&#x2F;等待用户的指令）</p><p>在单处理机系统中，采用先来先服务调度算法。系统中有4个进程P1、P2、 P3、P4 (假设进程按此顺序到达)，其中P1为运行状态，P2为就绪状态，P3和P4为等待状态， 且P3等待打印机，P4等待扫描仪。若P1 ( C) ,则P1、 P2、P3和P4的状态应分别为(A )。</p><p>A.时间片到B.释放了扫描仪C.释放了打印机.D.已完成</p><p>A.等待、就绪、等待和等待B.运行、就绪、运行和等待C.就绪、运行、等待和等待D.就绪、就绪、等待和运行</p><h2 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h2><p>用来表示哪些任务可以并行执行，哪些任务之间有顺序关系，具体如下图:可知，ABC可以并行执行，但是必须A B C都执行完后，才能执行D,这就确定了两点:<strong>任务间的并行、任务间的先后顺序</strong>。</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008212402103.png" alt="image-20231008212402103"></p><h2 id="进程资源图【非考点】"><a href="#进程资源图【非考点】" class="headerlink" title="进程资源图【非考点】"></a>进程资源图【非考点】</h2><p>用来表示进程和资源之间的分配和请求关系，如下图所示:</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008222521211.png" alt="image-20231008222521211"></p><p><strong>P代表进程，R代表资源</strong>，R方框中有几个圆球就表示有几个这种资源，在上图中，R1指向P1表示R1有一个资源已经分配给了P1，P1指向R2表示P1还需要请求一个R2资源才能执行。</p><blockquote><p>有几个箭头指向P，P就拥有几个资源。</p></blockquote><p>非阻塞节点:某进程所请求的资源还有剩余，可以分配给该进程继续运行。如上图中P1、P3。</p><p><strong>当一个进程资源图中所有进程都是阻塞节点时，即所有进程都无法运行，即陷入死锁状态。</strong></p><p>在如下所示的进程资源图中，(C) ;该进程资源图是(B)。</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008223230551.png" alt="image-20231008223230551"></p><p>A. P1、 P2、 P3都是阻塞节点</p><p>B. P1是阻塞节点、P2、P3是非阻塞节点</p><p>C. P1、P2是阻塞节点、P3是非阻塞节点</p><p>D. P1、P2是非阻塞节点、P3是阻塞节点</p><p>A.可以化简的，其化简顺序为P1→P2≥P3</p><p>B.可以化简的，其化简顺序为P3→P1→P2</p><p>C.可以化简的，其化简顺序为P2 →P1 →P3</p><p>D.不可以化简的，因为P1、P2、 P3申请的资源都不能得到满足</p><blockquote><p>可以化简指所有的程序都能顺利执行完毕，不会陷入死锁。</p><p>进程资源图化简的方法是:先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞的，接着把不阻塞的进程的所有边都去掉,形成一个孤立的点， 再把系统分配给这个进程的资源回收回来,这样，系统剩余的空闲资源便多了起来,接着又去看看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。最后，所有的资源和进程都变成孤立的点。图中P3是不阻塞的，故P3为化简图的开始，把P3孤立，再回收分配给他的资源，可以看到P1也变为不阻塞节点了，故P3、P1、P2是可以的。</p></blockquote><h2 id="进程的同步与互斥【考点】"><a href="#进程的同步与互斥【考点】" class="headerlink" title="进程的同步与互斥【考点】"></a>进程的同步与互斥【考点】</h2><p>◆临界资源:各进程间需要<strong>以互斥方式对其进行访问的资源</strong>。</p><p>◆临界区:指进程中对临界资源实施操作的那段程序。<strong>本质是一段程序代码</strong>。</p><p>◆互斥:某资源(即临界资源)在同一时间内只能由一个任务单独使用， 使用时需要<strong>加锁</strong>，使用完后解锁才能被其他任务使用;如打印机。</p><p>◆同步:多个任务可以并发执行，只不过有速度上的差异，在一定情况下停下等待，不存在资源是否单独或共享的问题;如自行车和汽车。</p><p>◆互斥信号量:对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，<strong>初值为1</strong>。</p><p>◆同步信号量:对共享资源的访问控制，<strong>初值一般是共享资源的数量</strong></p><blockquote><p> 【共享资源数量也是有限的，需要进行控制】。</p></blockquote><h3 id="PV操作【考点】"><a href="#PV操作【考点】" class="headerlink" title="PV操作【考点】"></a>PV操作【考点】</h3><p>PV操作利用信号量机制，是一种有效的进程同步与互斥工具，可以实现资源的互斥使用。</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008212710569.png" alt="image-20231008212710569"></p><p>S信号量：表示可使用的资源数量。</p><p>P操作：<strong>申请资源</strong>，S&#x3D;S-1，若S&gt;&#x3D;0，则执行P操作的进程继续执行；若S&lt;0，则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。</p><blockquote><p><strong>S&gt;0时指的是资源的数量，S&lt;0时，S的绝对值指的是阻塞进程的个数</strong>。</p></blockquote><p>V操作：<strong>释放资源</strong>，S&#x3D;S+1，若S&gt;0，则执行V操作的进程继续执行；若S&lt;&#x3D;0，则从阻塞状态唤醒一个进程，并将其插入就绪队列（此时因为减少资源被P操作阻塞的进程可以继续执行），然后执行V操作的进程继续。</p><h3 id="PV操作练习题"><a href="#PV操作练习题" class="headerlink" title="PV操作练习题"></a>PV操作练习题</h3><p>例题一：经典问题:<strong>生产者和消费者的问题</strong></p><p>三个信号量:互斥信号量S0(仓库独立使用权)，同步信号量S1 (仓库空闲个数)，同步信号量S2 (仓库商品个数)。</p><table><thead><tr><th align="center">生产者流程</th><th align="center">消费者流程</th></tr></thead><tbody><tr><td align="center">生产一个商品S</td><td align="center">P(S0)</td></tr><tr><td align="center">P(S0)</td><td align="center">P(S2)</td></tr><tr><td align="center">P(S1)</td><td align="center">取出一一个商品</td></tr><tr><td align="center">将商品放入仓库中</td><td align="center">V(S1)</td></tr><tr><td align="center">V(S2)</td><td align="center">V(S0)</td></tr><tr><td align="center">V(S0)</td><td align="center"></td></tr></tbody></table><p>例题二：</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008225444836.png" alt="image-20231008225444836"></p><blockquote><p><a href="https://www.bilibili.com/video/BV1xK4y1D7ph?t=3793.9&p=4">https://www.bilibili.com/video/BV1xK4y1D7ph?t=3793.9&amp;p=4</a></p><p>前驱图的每条线都是一个信号量。</p><p>P1执行完，P2、P3就能执行，也就是释放了两个信号量，即V(S1),V(S2)。</p></blockquote><p>例题三：</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008213236903.png" alt="image-20231008213236903"></p><p>购书者进程中 P(Sn)和 V(Sn)执行的操作就是书店最多允许n个购书者进入。</p><p>上面的题选AC</p><p>可以假设先执行收营员进程，如果不加任何限制条件，此时显然没有购书者，而收银员进程则循环执行，显然这样是不行的，所以我们想到在b1处加一个P操作，用来限制，当有购书者时，才会执行收银员进程，所以对应者a1肯定是一个V操作。假设先执行购书者进程时，我们刚才已经推断出a1是V操作，但是者显然不具备约束，此时如果收银员没有进行收费操作时，显然我们不能完成购书，所以a2必须是一个P操作，对应着b2是V操作。</p><p>例题4：</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008230157938.png" alt="image-20231008230157938"></p><h3 id="PV操作与前趋图"><a href="#PV操作与前趋图" class="headerlink" title="PV操作与前趋图"></a>PV操作与前趋图</h3><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008213314717.png" alt="image-20231008213314717"><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008213330750.png" alt="image-20231008213330750"></p><p>解决上面问题的方法: 首先在每个箭头上标识一个信号量，顺序按从左到右（从上到下）的形式<img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008213348953.png" alt="image-20231008213348953"></p><p>箭头的开始处一般对应V操作，结束处（目标处）一般对应P操作，可以明显推出 a处空填 V(S1) b处空填V(S2)，c 处空填 P(S1)和P(S2)，d 处空填V(S3)和V(S4)，e处填P(S3)，f处填P(S4)</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>◆进程调度方式是指当有更高优先级的进程到来时如何分配CPU。分为可剥夺和不可剥夺两种，可剥夺指当有更高优先级进程到来时，强行将正在运行进程的CPU分配给高优先级进程;不可剥夺是指高优先级进程必须等待当前进程自动释放CPU。</p><p>◆在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度。</p><p>(1)高级调度。高级调度又称”长调度”、“<strong>作业调度</strong>”【作业指一组程序】 或”接纳调度”，它决定处于输入池中的哪个后备作业可以调入主系统做好运行的准备，成为-一个或一组就绪进程。 在系统中一个作业只需经过一次高级调度。</p><p>(2) 中级调度。中级调度又称“中程调度”或“对换调度”，它决定处于交换区中的哪个就绪进程可以调入内存，以便直接参与对CPU的竞争。</p><p>(3)低级调度。低级调度又称”短程调度”或“<strong>进程调度</strong>”，它决定处于内存中的哪个就绪进程可以占用CPU。低级调度是操作系统中<strong>最活跃、最重要</strong>的调度程序，对系统的影响很大。</p><p><strong>调度算法</strong>:</p><p>先来先服务FCFS:先到达的进程优先分配CPU。用于宏观调度。</p><p>时间片轮转:分配给每个进程CPU时间片,轮流使用CPU,每个进程时间片大小相同，很公平,用于微观调度。</p><p>优先级调度:每个进程都拥有一个优先级,优先级大的先分配CPU。</p><p>多级反馈调度:时间片轮转和优先级调度结合而成，设置多个就绪队列1,23,..n,每个队列分别赋予不同的优先级，<strong>分配不同的时间片长度</strong>;新进程先进入队列1的末尾，按FCFS原则,执行队列1的时间片;若未能执行完进程，则转入队列2的末尾，如此重复。降低优先级</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008231353198.png" alt="image-20231008231353198"></p><h2 id="死锁问题【考点】"><a href="#死锁问题【考点】" class="headerlink" title="死锁问题【考点】"></a>死锁问题【考点】</h2><p>当一个进程在等待永远不可能发生的事件时，就会产生死锁，若系统中有多个进程处于死锁状态，就会造成系统死锁。</p><p>死锁产生的<strong>四个必要条件</strong>:<u>资源互斥、每个进程占有资源并等待其他资源【不会主动释放自己占有的资源】、系统不能剥夺进程资源、进程资源图是一个<strong>环路</strong></u>。</p><blockquote><p>互斥: 如果进程间不是互斥使用资源，而是同时使用属于自己的资源，那就不存在死锁的情况了。</p><p>保持和等待: 各个进程会保持自己的资源，并且等待别的进程释放更多的资源给自己。</p><p>不剥夺: 系统不会把分配给某进程的资源剥夺掉给其它的进程。</p><p>环路等待: 如 - A，B，C进程，A等待B释放资源，B等C释放资源，C又等A释放资源。</p><p>解决死锁问题的两种方案: 死锁的预防(打破四大条件)和死锁的避免。</p></blockquote><p>死锁产生后，解决措施是打破四大条件，有下列方法:</p><p><strong>死锁预防</strong>:采用某种策略限制并发进程对于资源的请求，破坏死锁产生的四个条件之一， 使系统任何时刻都不满足死锁的条件。</p><p><strong>死锁避免</strong>: 一般采用银行家算法来避免，银行家算法，就是提前计算出一条不会死锁的资源分配方法，才分配资源，否则不分配资源，相当于借贷,考虑对方还得起才借钱，提前考虑好以后，就可以避免死锁。</p><p><strong>死锁检测</strong>:允许死锁产生,但系统定时运行一个检测死锁的程序,若检测到系统中发生死锁，则设法加以解除。</p><p><strong>死锁解除</strong>:即死锁发生后的解除方法,如强制剥夺资源，撤销进程等.</p><p><u>死锁资源计算:系统内有n个进程，每个进程都需要R个资源，那么其发生死锁的最大资源数为n×(R-1)。其<strong>不发生死锁的最小资源数为n×(R-1)+1</strong>。</u></p><p>例题：某系统中有3个并发进程竞争资源R，每个进程都需要5个R，那么至少有(B)个R，才能保证系统不会发生死锁。A.12</p><p>B.13</p><p>C.14</p><p>D.15</p><p>例题：假设系统中有n个进程共享3台打印机，任一进程在任- 时刻最多只能使用1台打印机。若用PV操作控制n个进程使用打印机，则相应信号量S的取值范围为() ;若信号量s的值为-3，则系统中有()个进程等待使用打印机。</p><p><a href="https://www.bilibili.com/video/BV1xK4y1D7ph?t=1011.7&p=5">https://www.bilibili.com/video/BV1xK4y1D7ph?t=1011.7&amp;p=5</a></p><p>A.0, -1，…. -(n-1)B.3， 2, 1, 0，-1, … -(n-3)C.1, 0, -1, … -(n-1)D.2, 1，0, -1, … - (n-2)</p><p>A.0B.1C.2D.3</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><a href="https://www.bilibili.com/video/BV1xK4y1D7ph?t=1146.2&p=5">https://www.bilibili.com/video/BV1xK4y1D7ph?t=1146.2&amp;p=5</a></p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231008233049439.png" alt="image-20231008233049439"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>传统的进程有两个属性:可拥有资源的独立单位;可<strong>独立调度</strong>和分配的基本单位。</p><blockquote><p>进程内的资源被线程所共享。线程之间不加锁。</p></blockquote><p><strong>引入线程的原因</strong>是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，<strong>故在系统中设置的进程数目不宜过多,进程切换的频率不宜太高</strong>，这就限制了并发程度的提高。引入线程后,将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。</p><p>线程是进程中的一个实体，是被系统独立分配和调度的基本单位。线程基本上不拥有资源，只拥有一点运行中必不可少的资源(如程序计数器、一组寄存器和栈)，它可<strong>与同属一个进程的其他线程共享进程所拥有的全部资源</strong>，例如进程的公共数据、全局变量、代码、文件等资源，但<strong>不能共享线程独有的资源，如线程的栈指针等标识数据</strong>【这些资源用来区分线程】。</p><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h2><p>所谓分区存储组织，就是<strong>整存，将某进程运行所需的内存整体一起分配给它</strong>，然后再执行。有三种分区方式:</p><p><strong>固定分区</strong>:静态分区方法,将主存分为若干个固定的分区，将要运行的作业装配进去，由于分区固定，大小和作业需要的大小不同，<strong>会产生内部碎片</strong>。</p><p><strong>可变分区</strong>:动态分区方法,主存空间的分区是在作业转入时划分，<strong>正好划分为作业需要的大小</strong>，这样就不存在内部碎片,但容易将整片主存空间切割成许多块，会产生<strong>外部碎片</strong>。</p><p>可变分区系统分配内存的算法有很多，如下图所示，根据分配前的内存情况，还需要分配9K空间，对不同算法的结果介绍如下:</p><p>◆首次适应法:按内存地址顺序从头查找，找到第一个&gt;&#x3D;9K空间的空闲块，即<strong>切割</strong>9K空间分配给进程。</p><p>◆最佳适应法:将内存中所有空闲内存块按从小到大排序，找到第一个&gt;&#x3D;9K空间的空闲块，切割分配，这个将会找到与9K空间大小最相近的空闲块。</p><p>◆最差适应法:和最佳适应法相反，将内存中空闲块空间最大的，切割9K空间分配给进程，这是为了<u>预防系统中产生过多的细小空闲块</u>。</p><p>◆循环首次适应法:按内存地址顺序查找，找到第一个&gt;&#x3D;9K空间的空闲块， 而后若还需分配，则找下一个,<u>不用每次都从头查找</u>，这是与首次适应法不同的地方。</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009135830553.png" alt="image-20231009135830553"></p><p>可重定位分区:可以解决碎片问题，移动所有已经分配好的区域，使其成为一个连续的区域，这样其他外部细小的分区碎片可以合并为大的分区，满足作业要求。只在外部作业请求空间得不到满足时进行。</p><h2 id="分页存储管理【考点】"><a href="#分页存储管理【考点】" class="headerlink" title="分页存储管理【考点】"></a>分页存储管理【考点】</h2><p>逻辑页分为页号和页内地址，页内地址就是物理偏移地址，而<u>页号与物理块号并非按序对应的，需要查询页表,才能得知页号对应的物理块号</u>，再用物理块号加上偏移地址才得出了真正运行时的物理地址。</p><blockquote><p>不需要一次性提供程序所需要的所有内存，而是根据根据程序需要调入。本身是静态方法，会产生内部碎片。</p></blockquote><p>优点:利用率高，碎片小，分配及管理简单。</p><p>缺点:增加了系统开销，可能产生抖动现象【抖动现象是指随着页数增加，效率可能下降】</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009140349866.png" alt="image-20231009140349866"></p><blockquote><p>页号指当前是多少页。</p><p>有多少页决定了页号是多少位。</p><p>页内地址和页的大小【4KB】相关。</p><p>页表是存储逻辑地址和物理地址对应关系的表。</p></blockquote><p>页面置换算法</p><p>◆最优算法: OPT, 理论上的算法，无法实现，是在进程执行完后进行的<strong>最佳效率计算</strong>，用来让其他算法比较差距。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的。</p><blockquote><p>一般是通过局部性原理进行预测，如LRU。</p></blockquote><p>◆先进先出算法: FIFO, 先调入内存的页先被置换淘汰，会产生抖动现象，即<strong>分配的页数越多，缺页率可能越多</strong>(即效率越低).</p><p>◆最近最少使用: LRU, 在最近的过去，进程执行过程中，过去最少使用的页面被置换淘汰，根据局部性原理,这种方式效率高，且不会产生抖动现象，使用大量计数器，但是没有LFU多。</p><p>◆淘汰原则:优先淘汰最近未访问的，而后淘汰最近未被修改的页面。</p><p>快表【快速的页表】</p><blockquote><p>快表和页表类似于Cache和主存的关系。</p></blockquote><p>◆是一块小容量的相联存储器，由快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容并行查找，一般用来<strong>存放当前访问最频繁的少数活动页面的页号</strong>。</p><p>◆快表是将页表存于Cache中;慢表是将页表存于内存上。慢表需要访问两次【第一次去内存取页表，第二次去内存取数据】内存才能取出页，而快表是访问一次Cache和一次内存，因此更快。</p><p>例题：</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009142217127.png" alt="image-20231009142217127"></p><p>解析:页面大小为4K，则页内偏移地址为12【4K&#x3D;$2^{12}$】位，才能表示4K大小空间;由此，可知逻辑地址1D16H的低12位D16H为偏移地址,高4位1为逻辑页号，在页表中对应物理块号3，因此物理地址为3D16H。</p><p>例题</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009142745308.png" alt="image-20231009142745308"></p><p>答案: D解析:根据局部性原理，应该优先淘汰最近未被访问过的，而后淘汰最近未被修改过的，由页表可知，023最近都被访问过，而只有3最近未被修改过，应该淘汰3。然而其实这种题目，就算不知道上述原理,也能做出，答案只有一个，肯定是与其他不同的，具有唯一性的一个，在023中，02的访问位和修改位一样,只有3不同,答案就是3.</p><p><strong>通过逻辑地址求物理地址: 先明确逻辑地址中的页号与页内地址（每个页中地址的编号或者说是偏移量），页内地址对应物理地址的页内地址，然后通过页号查找块号，将两部分拼接起来就得到了物理地址。</strong></p><p><strong>例题：</strong>某计算机系统页面大小为4K,进程的页面变换表如下所示。若进程的逻辑地址为2D16H。该地址经过变换后，其物理地址应为（)</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231025190255081.png" alt="image-20231025190255081"></p><p>A.2048HB.4096HC.4D16HD.6D16H</p><blockquote><p>根据题意,页面大小为4K，逻辑地址2D16H所在页号为2，页内地址为D16H，查页表后可知物理块号为4，该地址i过变换后，其物理地址应为物理块号4拼接上页内地址D16H，即十六进制4D16H。</p></blockquote><p><strong>例题：</strong>某计算机系统页面大小为4K，若进程的页面变换表如下所示，逻辑地址为十六进制1D16H。该地址经过变换后，其物理地址应为十六进制( ) 。</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231025190716455.png" alt="image-20231025190716455"></p><blockquote><p>页面大小为4K，而4K&#x3D;2^12，因此逻辑地址的低12位对应页内地址，高位对应页号。题目中逻辑地址为十六进制1D16H，<strong>一位十六进制数对应4位二进制数</strong>，3位十六进制数则对应12位二进制数，因此D16H为页内地址，页号为1。查页面变换表，页号1对应的物理块号为3，将物理块号与页内地址D16H拼接起来即可得到物理地址3D16H。</p></blockquote><h2 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h2><p>将进程空间分为一个个段，<strong>每段也有段号和段内地址</strong>，与页式存储不同的是,<strong>每段物理大小不同，分段是根据逻辑整体分段的</strong>，因此，段表也与页表的内容不同，页表中直接是逻辑页号对应物理块号，而下图所示，<strong>段表有段长和基址两个属性</strong>，才能确定一个逻辑段在物理段中的位置。</p><p>例题：</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009143325512.png" alt="image-20231009143325512"></p><p>解析:正确选项为B。因为0段的段长只有600，而逻鵜地址(0, 1597) 中的1597已经越界，不能转换成逻辑地址，而选项A和选项C中都包含逻辑地址(0, 597)所以是错误的。又因为4段的段长只有960，而逻辑地址(4,1066)中的1066已经越界，也不能转换成逻辑地址，而选项D中包含逻辑地址(4, 1066)所以是错误的。</p><p><img src="/../../pic/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009143039320.png" alt="image-20231009143039320"></p><p>按逻辑方式划分段长，所以段长可以不同。</p><h2 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h2><p>对进程空间先分段,后分页，具体原理图和优缺点如下:</p><p>优点:空间浪费小、存储共享容易、存储保护容易、能动态链接。</p><p>缺点:由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降。</p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><p>设备是计算机系统与外界交互的工具，具体负责计算机与外部的输入&#x2F;输出工作,所以常称为外部设备(简称外设)。在计算机系统中，将负责管理设备和输入&#x2F;输出的机构称为I&#x2F;0系统。因此，I&#x2F;0 系统由设备、控制器、通道(具有通道的计算机系统)、总线和&#x2F;0软件组成。</p><h3 id="设备的分类"><a href="#设备的分类" class="headerlink" title="设备的分类"></a>设备的分类</h3><p>按数据组织分类:块设备、字符设备。按照设备功能分类:输入设备、输出设备、存储设备、网络联网设备、供电设备。资源分配角度分类:独占设备、共享设备和虚拟设备【把独占设备转换为共享设备】。数据传输速率分类:低速设备、中速设备、高速设备。</p><h3 id="设备管理任务"><a href="#设备管理任务" class="headerlink" title="设备管理任务"></a>设备管理任务</h3><p>设备管理的任务是保证在多道程序环境下，当多个进程竞争使用设备时,按一定的策略分配和管理各种设备，控制设备的各种操作，完成I&#x2F;0设备与主存之间的数据交换。</p><h3 id="I-x2F-O软件"><a href="#I-x2F-O软件" class="headerlink" title="I&#x2F;O软件"></a>I&#x2F;O软件</h3><p>I&#x2F;0设备管理软件的所有层次及每一层功能如下图:</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231009234352009.png" alt="image-20231009234352009"></p><p>实例:当用户程序试图读一个硬盘文件时，需要通过操作系统实现这一操作。<strong>与<u>设备无关软件</u>检查高速缓存中有无要读的数据块</strong>，若没有，则<strong>调用设备驱动程序，向I&#x2F;0 硬件发出一个请求</strong>。然后，用户进程阻塞并等待磁盘操作的完成。<strong>当磁盘操作完成时，硬件产生一个中断，转入中断处理程序。</strong>中断处理程序检查中断的原因，认识到这时<strong>磁盘读取操作已经完成</strong>，于是唤醒用户进程取回从磁盘读取的信息，从而结束此次I&#x2F;0请求。用户进程在得到了所需的硬盘文件内容，之后继续运行。</p><h3 id="设备管理技术"><a href="#设备管理技术" class="headerlink" title="设备管理技术"></a>设备管理技术</h3><p>一台独占设备，在同一时间只能由一个进程使用，其他进程只能等待，且不知道什么时候打印机空闲，此时，极大的浪费了外设的工作效率。</p><p>引入<strong>SPOOLING (外围设备联机操作)技术</strong>，就是在外设上建立两个数据缓冲区，分别称为输入井和输出井，这样,无论多少进程，都可以共用这一台打印机，只需要将打印命令发出，数据就会排队存储在缓冲区中，打印机会自动按顺序打印，实现了物理外设的共享,使得<strong>每个进程都感觉在使用一个打印机，这就是物理设备的虚拟化</strong>。如下图所示:</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231010094115054.png" alt="image-20231010094115054"></p><p>例题：</p><p>以下关于I&#x2F;0软件的叙述中，正确的是(C )A.I&#x2F;0软件开放了I&#x2F;0操作实现的细节，方便用户使用I&#x2F;0设备B、I&#x2F;0软件隐藏了I&#x2F;O操作实现的细节，向用户提供物理接口C、I&#x2F;0软件隐藏了I&#x2F;0操作实现的细节，方便用户使用I&#x2F;0设备D. I&#x2F;0软件开放了I&#x2F;O操作实现的细节，用户可以使用逻辑地址访问I&#x2F;0设备</p><p>假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为10us，由缓冲区送至用户区的时间是5us，系统对每个磁盘块数据的处理时间为2us。若用户需要将大小为10个磁盘块的Docl文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为()u s;采用双缓冲区需要花费的时间为(&#x2F; ) us。</p><p>A.100B.107C.152D.170</p><blockquote><p>在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，缓冲区中的数据传送到用户工作区的时间为M，而系统处理(计算）的时间为C，如图( a)所示。</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231025171530380.png" alt="image-20231025171530380"></p><p>当第一块数据送入用户工作区后，缓冲区是空闲的，可以传送第二块数据。这样第一块数据的处理C1与第二块数据的输入T2是可以并行的，如图( b )所示，依次类推。系统对每一块数据的处理时间为:Max ( C，T )+M。因为当T&gt;C时，处理时间为本题每一块数据的处理时间为10+5&#x3D;15，Doc1文件的处理时间为15*10+2&#x3D;152。</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231025171555515.png" alt="image-20231025171555515"></p></blockquote><h2 id="文件管理概述"><a href="#文件管理概述" class="headerlink" title="文件管理概述"></a>文件管理概述</h2><p>文件是<strong>具有符号名的、在逻辑上具有完整意义的</strong>一组相关信息项的集合。</p><p>信息项是构成文件内容的基本单位，可以是一个字符， 也可以是一个记录，记录可以等长，也可以不等长。一个文件包括文件体和文件说明。文件体是文件真实的内容。文件说明是操作系统为了管理文件所用到的信息，包括文件名、文件内部标识、文件的类型、文件存储地址、文件的长度、访问权限、建立时间和访问时间等。</p><p>文件管理系统，就是<strong>操作系统中实现文件统一管理的一组软件和相关数据的集合</strong>，专负责管理和存取文件信息的软件机构，简称文件系统。文件系统的功能包括按名存取;统一的用户接口;并发访问和控制;安全性控制;优化性能;差错恢复。</p><h3 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型:"></a>文件的类型:</h3><p>(1)按文件性质和用途可将文件分为系统文件、库文件和用户文件。</p><p>(2)按信息保存期限分类可将文件分为临时文件、档案文件和永久文件。</p><p>(3)按文件的保护方式分类可将文件分为只读文件、读&#x2F;写文件、可执行文件和不保护文件。</p><p>(4)UNIX系统将文件分为普通文件、 目录文件和设备文件(特殊文件)。</p><p><strong>文件的逻辑结构</strong>可分为两大类:有结构的记录式文件;无结构的流式文件。</p><p><strong>文件的物理结构</strong>是指<strong>文件在物理存储设备上的存放方法</strong>，包括:</p><p>(1)连续结构。连续结构也称顺序结构，它将逻辑上连续的文件信息(如记录)依次存放在连续编号的物理块上。</p><p>(2)链接结构。链接结构也称串联结构，它是将逻辑上连续的文件信息(如记录)<strong>存放在不连续的物理块上</strong>，<strong>每个物理块设有一个指针指向下一个物理块</strong>。</p><p>(3)索引结构。将<strong>逻辑上连续的文件信息(如记录)存放在不连续的物理块中</strong>，系统为每个文件建立一张<strong>索引表</strong>。 索引表记录了文件信息所在的逻辑块号对应的物理块号，并将索引表的起始地址放在与文件对应的文件目录项中。</p><p>(4)多个物理块的索引表。索引表是在文件创建时由系统自动建立的，并与文件一起存放在同一文件卷上。根据个文件大小的不同， 其索引表占用物理块的个数不等，一般占一个或几个物理块。</p><h2 id="索引文件结构【考点】"><a href="#索引文件结构【考点】" class="headerlink" title="索引文件结构【考点】"></a>索引文件结构【考点】</h2><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231010095847836.png" alt="image-20231010095847836"></p><p>如图所示，系统中有13个索引节点，0-9为<strong>直接索引</strong>【直接指向一个物理盘块】，即每个索引节点存放的是内容，假设每个物理盘大小为4KB,共可存4KB* 10&#x3D;40KB数据;</p><p>10号索引节点为<strong>一级间接索引节点，大小为4KB，存放的并非直接数据，而是链接到直接物理盘块的地址</strong>，假设每个地址占4B，则共有1024个地址，对应1024个物理盘，可存1024* 4KB&#x3D;4096KB数据。</p><p>二级索引节点类似，直接盘存放一级地址，一级地址再存放物理盘块地址，而后链接到存放数据的物理盘块，容量又扩大了一个数量级，为1024×1024×4KB数 据。</p><p><strong>例题</strong>：</p><p>设文件索引节点中有8个地址项,每个地址项大小为4字节，其中5个地址项【对应0-4】为直接地址索引，2个地址项是一级间接地址索引， 1个地址项是二级间接地址索引，磁盘索引块和磁盘数据块大小均为1KB，若要访问文件的逻辑块号分别为5和518，则系统应分别采用__ _ 27 _ __ , 而且可表示的单个文件最大长度是_ _28__KB。</p><p>(27)  C</p><p>A.直接地址索引和一级间接地址索引B.直接地址索引和二级间接地址索引C.一级间接地址索引和二级间接地址索引D. 一级间接地址索引和一级间接地址索引</p><blockquote><p>直接索引逻辑块号 0-4</p><p>一级间接地址索引 1KB&#x2F;4B ×2&#x3D;512，即5-516</p></blockquote><p>(28) </p><p>A. 517B.1029C.16513D.66053</p><blockquote><p>5×1KB+512×1KB+256×256×1KB&#x3D;66053</p></blockquote><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231010102121493.png" alt="image-20231010102121493"></p><p>◆文件控制块中包含以下三类信息:基本信息类、存取控制信息类和使用信息类。</p><p>(1)基本信息类。例如文件名、文件的物理地址、文件长度和文件块数等。</p><p>(2）存取控制信息类。文件的存取权限，像UNIX 用户分成文件主、同组用户和-般用户三类，这三类用户的读&#x2F;写执行RWX权限。</p><p>(3)使用信息类。文件建立日期、最后一次修改日期、最后:一次访问的目期、当前使用的信息(如打开文件的进程数、在文件上的等待队列)等。</p><p>◆文件控制块的有序集合称为文件目录。</p><p>◆相对路径:是从<strong>当前路径开始的路径</strong>。</p><p>◆绝对路径:是从根目录开始的路径。</p><p>◆全文件名&#x3D;绝对路径+文件名。要注意,绝对路径和相对路径是不加最后的文件名的，只是单纯的路径序列。</p><blockquote><p> 若某文件系统的目录结构如下图所示，假设用户要访问文件fl.java，且当前工作目录为Program，则该文件的全文件名为(&#x2F;)，其相对路径为()。</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231025095247173.png" alt="image-20231025095247173"></p><p>文件的全文件名应包括盘符及从根目录开始的路径名，所以从题图可以看出文件fl.java的全文件名为D:\Program \Java-prog ifl.java。文件的相对路径是当前工作目录下的路径名，所以从题图可以看出文件fl.java的相对路径名为Java-prog\。</p></blockquote><p>若系统正在将(A）文件修改的结果写回磁盘时系统发生崩渍，则对系统的影响较大。</p><p>A.系统目录B.空闲块C.用户程序D.用户数据</p><blockquote><p>影响文件系统可靠性因素之一是<strong>文件系统的一致性问题</strong>。很多文件系统是先读取磁盘块到主存进行修改，修改完毕再写回磁盘。例如读取某磁盘块,修改后再将信息写回磁盘前系统崩溃，则文件系统就可能会出现不一致性状态。如果这些未被写回的磁盘块是索引节点块、目录块或空闲块，特别是系统目录文件，那么对系统的影响相对较大，且后果也是不堪设想的。通常解决方案是采用文件系统的一致性检查，一致性检查包括<strong>块的一致性检查和文件的一致性检查</strong>。</p></blockquote><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>◆文件的存取方法是<strong>指读&#x2F;写文件存储器上的一个物理块的方</strong>法。通常有<strong>顺序存取和随机存取</strong>两种方法。顺序存取方法是指对文件中的信息按顺序依次进行读&#x2F;写;随机存取方法是指对文件中的信息可以按任意的次序随机地读&#x2F;写。</p><p>◆文件存储空间的管理:</p><p>(1)空闲区表。将外存空间上的一个<strong>连续的未分配区域</strong>称为“空闲区”。操作系统为磁盘外存上的所有空闲区建立一张空闲表， 每个表项对应一个空闲区，适用于连续文件结构。</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231010102809599.png" alt="image-20231010102809599"></p><p>(2）<strong>位示图</strong>【考点】。这种方法是在外存上建立一张位示图(Bitmap) ，记录文件存储的使用情况。<strong>每一位对应文件存储器上的一个物理块，取值0和1分别表示空闲和占用</strong>。</p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231010103057417.png" alt="image-20231010103057417"></p><blockquote><p>某文件管理系统在磁盘上建立了位示图( bitmap ) ，记录磁盘的使用情况。若计算机系统的字长为32位，磁盘的容量为300GB，物理块的大小为4MB ，那么位示图的大小需要()个字。</p><p>A.1200B.2400C.6400D.9600</p><p>根据题意，计算机系统中的字长为32位，每位可以表示一个物通块的“使用”还是“未用”，一个字可记录32个物理块的使用情况。又因为磁盘的容量为300GB，物理块的大小为4MB，那么该磁盘有300*1024&#x2F;4&#x3D;76800个物理块，位示图的大小为76800&#x2F;32&#x3D;2400个字。</p></blockquote><p>(3)空闲块链。每个空闲物理块中有指向下一个空闲物理块的指针，所有空闲物理块构成一个链表， 链表的头指针放在文件存储器的特定位置上(如管理块中)，不需要磁盘分配表，节省空间。</p><p>(4)成组链接法。例如，在实现时系统将空闲块分成若干组，每100个空闲块为一组，每组的第一个空闲块登记了 下一组空闲块的物理盘块号和空闲块总数。假如某个组的第一个空闲块号等于0, 意味着该组是最后一组，无下一组空闲块。</p><p><strong>例题</strong></p><p><img src="/../../pic/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231010103423129.png" alt="image-20231010103423129"></p><h2 id="文件管理安全"><a href="#文件管理安全" class="headerlink" title="文件管理安全"></a>文件管理安全</h2><p>文件级安全管理，是通过系统管理员或文件主对文件属性的设置来控制用户对文件的访问。</p><p>通常可设置以下几种属性:</p><p>只执行︰只允许用户执行该文件，主要针对.exe和.com文件。</p><p>隐含∶指示该文件为隐含属性文件。</p><p>索引︰指示该文件是索引文件。</p><p>修改∶指示该文件自上次备份后是否还被修改。</p><p>只读︰只允许用户读该文件。</p><p>读&#x2F;写∶允许用户对文件进行读和写。</p><p>共享∶指示该文件是可读共享的文件。</p><p>系统︰指示该文件是系统文件。</p><p>用户对文件的访问，将由用户访问权、目录访问权限及文件属性三者的权限所确定。或者说是有效权限和文件属性的交集。例如对于只读文件，尽管用户的有效权限是读&#x2F;写，但都不能对只读文件进行修改、更名和删除。对于一个非共享文件，将禁止在同一时间内由多个用户对它们进行访问。通过上述四级文件保护措施，可有效地保护文件。</p><p>**例题.**在WindowsXP操作系统中，用户利用“磁盘管理”程序可以对磁盘进行初始化、创建卷，(&#x2F; )。通常将“C:\Windowsimyprogram.exe”文件设置成只读和隐藏属性，以便控制用户对该文件的访问，这一级安全管理称之为(A)安全管理。</p><p>A.文件级B.目录级C.用户级D.系统级</p><blockquote><p>将“C\ Windowsimyprogram.exe”文件设置成只读和隐藏属性，以便控制用户对该文件的访问，这一级安全管理称之为文件级安全管理。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;img src=&quot;/../../pic/3.%E6%93%8D%E4%BD</summary>
      
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>中国人民银行金融消费者权益保护实施办法</title>
    <link href="http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/1.2%E6%B6%88%E4%BF%9D-%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%B0%91%E9%93%B6%E8%A1%8C%E9%87%91%E8%9E%8D%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%83%E7%9B%8A%E4%BF%9D%E6%8A%A4%E5%AE%9E%E6%96%BD%E5%8A%9E%E6%B3%95/"/>
    <id>http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/1.2%E6%B6%88%E4%BF%9D-%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%B0%91%E9%93%B6%E8%A1%8C%E9%87%91%E8%9E%8D%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%83%E7%9B%8A%E4%BF%9D%E6%8A%A4%E5%AE%9E%E6%96%BD%E5%8A%9E%E6%B3%95/</id>
    <published>2023-09-29T12:05:15.000Z</published>
    <updated>2023-10-04T04:28:06.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章  总  则"></a>第一章  总  则</h1><p>　　第一条 为了保护金融消费者合法权益，规范金融机构提供金融产品和服务的行为，维护公平、公正的市场环境，促进金融市场健康稳定运行，根据《中华人民共和国中国人民银行法》《中华人民共和国商业银行法》《中华人民共和国消费者权益保护法》和《国务院办公厅关于加强金融消费者权益保护工作的指导意见》（国办发〔2015〕81号）等，制定本办法。</p><p>　　第二条 在中华人民共和国境内依法设立的为金融消费者提供金融产品或者服务的银行业金融机构（以下简称银行），开展与下列业务相关的金融消费者权益保护工作，适用本办法：</p><p>　　（一）与利率管理相关的。</p><p>　　（二）与人民币管理相关的。</p><p>　　（三）与外汇管理相关的。</p><p>　　（四）与黄金市场管理相关的。</p><p>　　（五）与国库管理相关的。</p><p>　　（六）与支付、清算管理相关的。</p><p>　　（七）与反洗钱管理相关的。</p><p>　　（八）与征信管理相关的。</p><p>　　（九）与上述第一项至第八项业务相关的金融营销宣传和消费者金融信息保护。</p><p>　　（十）其他法律、行政法规规定的中国人民银行职责范围内的金融消费者权益保护工作。</p><p>　　在中华人民共和国境内依法设立的非银行支付机构（以下简称支付机构）提供支付服务的，适用本办法。</p><p>　　本办法所称金融消费者是指购买、使用银行、支付机构提供的金融产品或者服务的自然人。</p><p>　　第三条 银行、支付机构向金融消费者提供金融产品或者服务，应当遵循自愿、平等、公平、诚实信用的原则，切实承担金融消费者合法权益保护的主体责任，履行金融消费者权益保护的法定义务。</p><p>　　第四条 金融消费者应当文明、理性进行金融消费，提高自我保护意识，诚实守信，依法维护自身的合法权益。</p><p>　　第五条 中国人民银行及其分支机构坚持公平、公正原则，依法开展职责范围内的金融消费者权益保护工作，依法保护金融消费者合法权益。</p><p>　　中国人民银行及其分支机构会同有关部门推动建立和完善金融机构自治、行业自律、金融监管和社会监督相结合的金融消费者权益保护共同治理体系。</p><p>　　第六条 鼓励金融消费者和银行、支付机构充分运用调解、仲裁等方式解决金融消费纠纷。</p><h1 id="第二章-金融机构行为规范"><a href="#第二章-金融机构行为规范" class="headerlink" title="第二章  金融机构行为规范"></a>第二章  金融机构行为规范</h1><p>　　第七条 银行、支付机构应当将金融消费者权益保护纳入公司治理、企业文化建设和经营发展战略，制定本机构金融消费者权益保护工作的总体规划和具体工作措施。建立金融消费者权益保护专职部门或者指定牵头部门，明确部门及人员职责，确保部门有足够的人力、物力能够独立开展工作，并定期向高级管理层、董（理）事会汇报工作开展情况。</p><p>　　第八条 银行、支付机构应当落实法律法规和相关监管规定关于金融消费者权益保护的相关要求，建立健全金融消费者权益保护的各项内控制度：</p><p>　　（一）金融消费者权益保护工作考核评价制度。</p><p>　　（二）金融消费者风险等级评估制度。</p><p>　　（三）消费者金融信息保护制度。</p><p>　　（四）金融产品和服务信息披露、查询制度。</p><p>　　（五）金融营销宣传管理制度。</p><p>　　（六）金融知识普及和金融消费者教育制度。</p><p>　　（七）金融消费者投诉处理制度。</p><p>　　（八）金融消费者权益保护工作内部监督和责任追究制度。</p><p>　　（九）金融消费者权益保护重大事件应急制度。</p><p>　　（十）中国人民银行明确规定应当建立的其他金融消费者权益保护工作制度。</p><p>　　第九条 银行、支付机构应当建立健全涉及金融消费者权益保护工作的全流程管控机制，确保在金融产品或者服务的设计开发、营销推介及售后管理等各个业务环节有效落实金融消费者权益保护工作的相关规定和要求。全流程管控机制包括但不限于下列内容：</p><p>　　（一）事前审查机制。银行、支付机构应当实行金融消费者权益保护事前审查，及时发现并更正金融产品或者服务中可能损害金融消费者合法权益的问题，有效督办落实金融消费者权益保护审查意见。</p><p>　　（二）事中管控机制。银行、支付机构应当履行金融产品或者服务营销宣传中须遵循的基本程序和标准，加强对营销宣传行为的监测与管控。</p><p>　　（三）事后监督机制。银行、支付机构应当做好金融产品和服务的售后管理，及时调整存在问题或者隐患的金融产品和服务规则。</p><p>　　第十条 银行、支付机构应当开展金融消费者权益保护工作人员培训，增强工作人员的金融消费者权益保护意识和能力。</p><p>　　银行、支付机构应当每年至少开展一次金融消费者权益保护专题培训，培训对象应当全面覆盖中高级管理人员、基层业务人员及新入职人员。对金融消费者投诉多发、风险较高的业务岗位，应当适当提高培训的频次。</p><p>　　第十一条 银行、支付机构开展考核评价时，应当将金融消费者权益保护工作作为重要内容，并合理分配相关指标的占比和权重，综合考虑业务合规性、客户满意度、投诉处理及时率与合格率等，不得简单以投诉数量作为考核指标。</p><p>　　第十二条 银行、支付机构应当根据金融产品或者服务的特性评估其对金融消费者的适合度，合理划分金融产品和服务风险等级以及金融消费者风险承受等级，将合适的金融产品或者服务提供给适当的金融消费者。</p><p>　　第十三条 银行、支付机构应当依法保障金融消费者在购买、使用金融产品和服务时的财产安全，不得挪用、非法占用金融消费者资金及其他金融资产。</p><p>　　第十四条 银行、支付机构应当尊重社会公德，尊重金融消费者的人格尊严和民族风俗习惯，不得因金融消费者性别、年龄、种族、民族或者国籍等不同实行歧视性差别对待，不得使用歧视性或者违背公序良俗的表述。</p><p>　　第十五条 银行、支付机构应当尊重金融消费者购买金融产品或者服务的真实意愿，不得擅自代理金融消费者办理业务，不得擅自修改金融消费者的业务指令，不得强制搭售其他产品或者服务。</p><p>　　第十六条 银行、支付机构应当依据金融产品或者服务的特性，及时、真实、准确、全面地向金融消费者披露下列重要内容：</p><p>　　（一）<strong>金融消费者对该金融产品或者服务的权利和义务，订立、变更、中止和解除合同的方式及限制。</strong></p><p>　　（二）银行、支付机构对该金融产品或者服务的权利、义务及法律责任。</p><p>　　（三）贷款产品的年化利率。</p><p>　　（四）金融消费者应当负担的费用及违约金，包括金额的确定方式，交易时间和交易方式。</p><p>　　（五）因金融产品或者服务产生纠纷的处理及投诉途径。</p><p>　　（六）银行、支付机构对该金融产品或者服务所执行的强制性标准、推荐性标准、团体标准或者企业标准的编号和名称。</p><p>　　（七）在金融产品说明书或者服务协议中，实际承担合同义务的经营主体完整的中文名称。</p><p>　　（八）其他可能影响金融消费者决策的信息。</p><p>　　第十七条 银行、支付机构对金融产品和服务进行信息披露时，应当使用有利于金融消费者接收、理解的方式。对利率、费用、收益及风险等与金融消费者切身利益相关的重要信息，应当根据金融产品或者服务的复杂程度及风险等级，对其中关键的专业术语进行解释说明，并以适当方式供金融消费者确认其已接收完整信息。</p><p>　　第十八条 银行、支付机构向金融消费者说明重要内容和披露风险时，应当依照法律法规和监管规定留存相关资料，自业务关系终止之日起留存时间不得少于3年。法律、行政法规另有规定的，从其规定。</p><p>　　留存的资料包括但不限于：</p><p>　　（一）金融消费者确认的金融产品说明书或者服务协议。</p><p>　　（二）金融消费者确认的风险提示书。</p><p>　　（三）记录向金融消费者说明重要内容的录音、录像资料或者系统日志等相关数据电文资料。</p><p>　　第十九条 银行、支付机构不得利用技术手段、优势地位，强制或者变相强制金融消费者接受金融产品或者服务，或者排除、限制金融消费者接受同业机构提供的金融产品或者服务。</p><p>　　第二十条 银行、支付机构在提供金融产品或者服务的过程中，不得通过附加限制性条件的方式要求金融消费者购买、使用协议中未作明确要求的产品或者服务。</p><p>　　第二十一条 银行、支付机构向金融消费者提供金融产品或者服务时使用格式条款的，应当以足以引起金融消费者注意的字体、字号、颜色、符号、标识等显著方式，<strong>提请金融消费者注意金融产品或者服务的数量、利率、费用、履行期限和方式、注意事项、风险提示、纠纷解决等与金融消费者有重大利害关系的内容，并按照金融消费者的要求予以说明。</strong>格式条款采用电子形式的，应当可被识别且易于获取。</p><p>　　银行、支付机构不得以通知、声明、告示等格式条款的方式作出含有下列内容的规定：</p><p>　　（一）减轻或者免除银行、支付机构造成金融消费者财产损失的赔偿责任。</p><p>　　（二）规定金融消费者承担超过法定限额的违约金或者损害赔偿金。</p><p>　　（三）排除或者限制金融消费者依法对其金融信息进行查询、删除、修改的权利；</p><p>　　（四）排除或者限制金融消费者选择同业机构提供的金融产品或者服务的权利。</p><p>　　（五）其他对金融消费者不公平、不合理的规定。</p><p>　　银行、支付机构应当对存在侵害金融消费者合法权益问题或者隐患的格式条款和服务协议文本及时进行修订或者清理。</p><p>　　第二十二条 银行、支付机构应当对营销宣传内容的真实性负责。银行、支付机构实际承担的义务不得低于在营销宣传活动中通过广告、资料或者说明等形式对金融消费者所承诺的标准。</p><p>　　前款“广告、资料或者说明”是指以营销为目的，利用各种传播媒体、宣传工具或者方式，就银行、支付机构的金融产品或者服务进行直接或者间接的宣传、推广等。</p><p>　　第二十三条 银行、支付机构在进行营销宣传活动时，不得有下列行为：</p><p>　　（一）虚假、欺诈、隐瞒或者引人误解的宣传。</p><p>　　（二）引用不真实、不准确的数据和资料或者隐瞒限制条件等，对过往业绩或者产品收益进行夸大表述。</p><p>　　（三）利用金融管理部门对金融产品或者服务的审核或者备案程序，误导金融消费者认为金融管理部门已对该金融产品或者服务提供保证。</p><p>　　（四）明示或者暗示保本、无风险或者保收益等，对非保本投资型金融产品的未来效果、收益或者相关情况作出保证性承诺。</p><p>　　（五）其他违反金融消费者权益保护相关法律法规和监管规定的行为。</p><p>　　第二十四条 银行、支付机构应当切实承担金融知识普及和金融消费者教育的主体责任，提高金融消费者对金融产品和服务的认知能力，提升金融消费者金融素养和诚实守信意识。</p><p>　　银行、支付机构应当制定年度金融知识普及与金融消费者教育工作计划，结合自身特点开展日常性金融知识普及与金融消费者教育活动，积极参与中国人民银行及其分支机构组织的金融知识普及活动。银行、支付机构不得以营销金融产品或者服务替代金融知识普及与金融消费者教育。</p><p>　　第二十五条 银行、支付机构应当重视金融消费者需求的多元性与差异性，积极支持普惠金融重点目标群体获得必要、及时的基本金融产品和服务。</p><p>　　第二十六条 出现侵害金融消费者合法权益重大事件的，银行、支付机构应当根据重大事项报告的相关规定及时向中国人民银行或其分支机构报告。</p><p>　　第二十七条 银行、支付机构应当配合中国人民银行及其分支机构开展金融消费者权益保护领域的相关工作，按照规定报送相关资料。</p><h1 id="第三章-消费者金融信息保护"><a href="#第三章-消费者金融信息保护" class="headerlink" title="第三章  消费者金融信息保护"></a>第三章  消费者金融信息保护</h1><p>　　第二十八条 本办法所称消费者金融信息，是指银行、支付机构通过开展业务或者其他合法渠道处理的消费者信息，包括个人身份信息、财产信息、账户信息、信用信息、金融交易信息及其他与特定消费者购买、使用金融产品或者服务相关的信息。</p><p>　　消费者金融信息的处理包括消费者金融信息的收集、存储、使用、加工、传输、提供、公开等。</p><p>　　第二十九条 银行、支付机构处理消费者金融信息，应当遵循合法、正当、必要原则，经金融消费者或者其监护人明示同意，但是法律、行政法规另有规定的除外。银行、支付机构不得收集与业务无关的消费者金融信息，不得采取不正当方式收集消费者金融信息，不得变相强制收集消费者金融信息。银行、支付机构不得以金融消费者不同意处理其金融信息为由拒绝提供金融产品或者服务，但处理其金融信息属于提供金融产品或者服务所必需的除外。</p><p>　　金融消费者不能或者拒绝提供必要信息，致使银行、支付机构无法履行反洗钱义务的，银行、支付机构可以根据《中华人民共和国反洗钱法》的相关规定对其金融活动采取限制性措施；确有必要时，银行、支付机构可以依法拒绝提供金融产品或者服务。</p><p>　　第三十条 银行、支付机构收集消费者金融信息用于营销、用户体验改进或者市场调查的，应当以适当方式供金融消费者自主选择是否同意银行、支付机构将其金融信息用于上述目的；金融消费者不同意的，银行、支付机构不得因此拒绝提供金融产品或者服务。银行、支付机构向金融消费者发送金融营销信息的，应当向其提供拒绝继续接收金融营销信息的方式。</p><p>　　第三十一条 银行、支付机构应当履行《中华人民共和国消费者权益保护法》第二十九条规定的明示义务，公开收集、使用消费者金融信息的规则，明示收集、使用消费者金融信息的目的、方式和范围，并留存有关证明资料。</p><p>　　银行、支付机构通过格式条款取得消费者金融信息收集、使用同意的，应当在格式条款中明确收集消费者金融信息的目的、方式、内容和使用范围，并在协议中以显著方式尽可能通俗易懂地向金融消费者提示该同意的可能后果。</p><p>　　第三十二条 银行、支付机构应当按照法律法规的规定和双方约定的用途使用消费者金融信息，不得超出范围使用。</p><p>　　第三十三条 银行、支付机构应当建立以分级授权为核心的消费者金融信息使用管理制度，根据消费者金融信息的重要性、敏感度及业务开展需要，在不影响本机构履行反洗钱等法定义务的前提下，合理确定本机构工作人员调取信息的范围、权限，严格落实信息使用授权审批程序。</p><p>　　第三十四条 银行、支付机构应当按照国家档案管理和电子数据管理等规定，采取技术措施和其他必要措施，妥善保管和存储所收集的消费者金融信息，防止信息遗失、毁损、泄露或者被篡改。</p><p>　　银行、支付机构及其工作人员应当对消费者金融信息严格保密，不得泄露或者非法向他人提供。在确认信息发生泄露、毁损、丢失时，银行、支付机构应当立即采取补救措施；信息泄露、毁损、丢失可能危及金融消费者人身、财产安全的，应当立即向银行、支付机构住所地的中国人民银行分支机构报告并告知金融消费者；信息泄露、毁损、丢失可能对金融消费者产生其他不利影响的，应当及时告知金融消费者，并在72小时以内报告银行、支付机构住所地的中国人民银行分支机构。中国人民银行分支机构接到报告后，视情况按照本办法第五十五条规定处理。</p><h1 id="第四章-金融消费争议解决"><a href="#第四章-金融消费争议解决" class="headerlink" title="第四章  金融消费争议解决"></a>第四章  金融消费争议解决</h1><p>　　第三十五条 金融消费者与银行、支付机构发生金融消费争议的，<strong>鼓励金融消费者先向银行、支付机构投诉，鼓励当事人平等协商，自行和解</strong>。</p><p>　　金融消费者应当依法通过正当途径客观、理性反映诉求，不扰乱正常的金融秩序和社会公共秩序。</p><p>　　本办法所称金融消费争议，是指金融消费者与银行、支付机构因购买、使用金融产品或者服务所产生的民事争议。</p><p>　　第三十六条 银行、支付机构应当切实履行金融消费投诉处理的主体责任，银行、支付机构的法人机构应当按年度向社会发布金融消费者投诉数据和相关分析报告。</p><p>　　第三十七条 银行、支付机构应当通过金融消费者方便获取的渠道公示本机构的投诉受理方式，包括但不限于营业场所、官方网站首页、移动应用程序的醒目位置及客服电话主要菜单语音提示等。</p><p>　　第三十八条 银行、支付机构应当按照中国人民银行要求，加强对金融消费者投诉处理信息系统的建设与管理，对投诉进行正确分类并按时报送相关信息，不得迟报、漏报、谎报、错报或者瞒报投诉数据。</p><p>　　第三十九条 银行、支付机构收到金融消费者投诉后，依照相关法律法规和合同约定进行处理，并告知投诉人处理情况，但因投诉人原因导致无法告知的除外。</p><p>　　第四十条 中国人民银行分支机构设立投诉转办服务渠道。金融消费者对银行、支付机构作出的投诉处理不接受的，可以通过银行、支付机构住所地、合同签订地或者经营行为发生地<strong>中国人民银行分支机构进行投诉</strong>。</p><p>　　通过电子商务、网络交易购买、使用金融产品或者服务的，金融消费者通过银行、支付机构住所地的中国人民银行分支机构进行投诉。</p><p>　　第四十一条 金融消费者通过中国人民银行分支机构进行投诉，应当提供以下信息：姓名，有效身份证件信息，联系方式，明确的投诉对象及其住所地，具体的投诉请求、事实和理由。</p><p>　　金融消费者可以本人提出投诉，也可以委托他人代为提出投诉。以来信来访方式进行委托投诉的，应当向中国人民银行分支机构提交前款规定的投诉材料、授权委托书原件、委托人和受托人的身份证明。授权委托书应当载明受托人、委托事项、权限和期限，并由委托人本人签名。</p><p>　　第四十二条 中国人民银行分支机构对下列投诉不予接收：</p><p>　　（一）投诉人投诉的机构、产品或者服务不属于中国人民银行监管范围的。</p><p>　　（二）投诉人未提供真实身份，或者没有明确的被投诉人、没有具体的投诉请求和事实依据的。</p><p>　　（三）投诉人并非金融消费者本人，也未经金融消费者本人委托的。</p><p>　　（四）<strong>人民法院、仲裁机构、其他金融管理部门、行政部门或者依法设立的调解组织已经受理、接收或者处理的</strong>。</p><p>　　（五）双方达成和解协议并已经执行，没有新情况、新理由的。</p><p>　　（六）被投诉机构已提供公平合理的解决方案，投诉人就同一事项再次向中国人民银行分支机构投诉的。</p><p>　　（七）其他不符合法律、行政法规、规章有关规定的。</p><p>　　第四十三条 中国人民银行分支机构收到金融消费者投诉的，应当自收到投诉之日起7个工作日内作出下列处理：</p><p>　　（一）对投诉人和被投诉机构信息、投诉请求、事实和理由等进行登记。</p><p>　　（二）作出是否接收投诉的决定。决定不予接收的，应当告知投诉人。</p><p>　　（三）决定接收投诉的，应当将投诉转交被投诉机构处理或者转交金融消费纠纷调解组织提供调解服务。</p><p>　　需要投诉人对投诉内容进行补正的，处理时限于补正完成之日起计算。</p><p>　　银行、支付机构应当自收到中国人民银行分支机构转交的投诉之日起15日内答复投诉人。情况复杂的，经本机构投诉处理工作负责人批准，可以延长处理期限，并告知投诉人延长处理期限的理由，但最长处理期限不得超过60日。</p><p>　　第四十四条 银行、支付机构收到中国人民银行分支机构转交的投诉，应当按要求向中国人民银行分支机构反馈投诉处理情况。</p><p>　　反馈的内容包括投诉基本情况、争议焦点、调查结果及证据、处理依据、与金融消费者的沟通情况、延期处理情况及投诉人满意度等。</p><p>　　银行、支付机构应当妥善保存投诉资料，投诉资料留存时间自投诉办结之日起不得少于3年。法律、行政法规另有规定的，从其规定。</p><p>　　第四十五条 银行、支付机构、金融消费者可以向调解组织申请调解、中立评估。调解组织受理调解、中立评估申请后，可在合理、必要范围内请求当事人协助或者提供相关文件、资料。</p><p>　　本办法所称中立评估，是指调解组织聘请独立专家就争议解决提出参考性建议的行为。</p><p>　　第四十六条 金融消费纠纷调解组织应当依照法律、行政法规、规章及其章程的规定，组织开展金融消费纠纷调解、中立评估等工作，对银行、支付机构和金融消费者进行金融知识普及和教育宣传引导。</p><p>　　第五章  监督与管理机制</p><p>　　第四十七条 中国人民银行综合研究金融消费者保护重大问题，负责拟定发展规划和业务标准，建立健全金融消费者保护基本制度。</p><p>　　第四十八条 中国人民银行及其分支机构与其他金融管理部门、地方政府有关部门建立健全金融消费者权益保护工作协调机制，加强跨市场跨业态跨区域金融消费者权益保护的监管，强化信息共享和部门间沟通协作。</p><p>　　第四十九条 中国人民银行及其分支机构统筹开展金融消费者教育，引导、督促银行、支付机构开展金融知识普及宣传活动，协调推进金融知识纳入国民教育体系，组织开展消费者金融素养调查。</p><p>　　第五十条 中国人民银行及其分支机构会同有关部门构建监管执法合作机制，探索合作开展金融消费者权益保护监督检查、评估等具体工作。</p><p>　　第五十一条 中国人民银行及其分支机构牵头构建非诉第三方解决机制，鼓励、支持金融消费者权益保护社会组织依法履行职责，推动构建公正、高效、便捷的多元化金融消费纠纷解决体系。</p><p>　　第五十二条 中国人民银行及其分支机构协调推进相关普惠金融工作，建立健全普惠金融工作机制，指导、督促银行、支付机构落实普惠金融发展战略，组织开展职责范围内的普惠金融具体工作。</p><p>　　第五十三条 中国人民银行及其分支机构对金融消费者投诉信息进行汇总和分析，根据汇总和分析结果适时优化金融消费者权益保护监督管理方式、金融机构行为规范等。</p><p>　　第五十四条 中国人民银行及其分支机构可以采取下列措施，依法在职责范围内开展对银行、支付机构金融消费者权益保护工作的监督检查：</p><p>　　（一）进入被监管机构进行检查。</p><p>　　（二）询问被监管机构的工作人员，要求其对有关检查事项作出说明。</p><p>　　（三）查阅、复制被监管机构与检查事项有关的文件、资料，对可能被转移、隐匿或者毁损的文件、资料予以登记保存。</p><p>　　（四）检查被监管机构的计算机网络与信息系统。</p><p>　　进行现场检查时，检查人员不得少于二人，并应当出示合法证件和检查通知书。</p><p>　　银行、支付机构应当积极配合中国人民银行及其分支机构的现场检查和非现场检查，如实提供有关资料，不得拒绝、阻挠、逃避检查，不得谎报、隐匿、销毁相关证据材料。</p><p>　　第五十五条 银行、支付机构有侵害金融消费者合法权益行为的，中国人民银行及其分支机构可以对其采取下列措施：</p><p>　　（一）要求提交书面说明或者承诺。</p><p>　　（二）约见谈话。</p><p>　　（三）责令限期整改。</p><p>　　（四）视情将相关信息向其上级机构、行业监管部门反馈，在行业范围内发布，或者向社会公布。</p><p>　　（五）建议银行、支付机构对直接负责的董事、高级管理人员和其他直接责任人员给予处分。</p><p>　　（六）依法查处或者建议其他行政管理部门依法查处。</p><p>　　（七）中国人民银行职责范围内依法可以采取的其他措施。</p><p>　　第五十六条 中国人民银行及其分支机构组织开展银行、支付机构履行金融消费者权益保护义务情况的评估工作。</p><p>　　评估工作以银行、支付机构自评估为基础。银行、支付机构应当按年度进行自评估，并于次年1月31日前向中国人民银行或其分支机构报送自评估报告。</p><p>　　中国人民银行及其分支机构根据日常监督管理、投诉管理以及银行、支付机构自评估等情况进行非现场评估，必要时可以进行现场评估。</p><p>　　第五十七条 中国人民银行及其分支机构可以根据具体情况开展金融消费者权益保护环境评估工作。</p><p>　　第五十八条 中国人民银行及其分支机构建立金融消费者权益保护案例库制度，按照预防为先、教育为主的原则向银行、支付机构和金融消费者进行风险提示。</p><p>　　第五十九条 中国人民银行及其分支机构对于涉及金融消费者权益保护的重大突发事件，应当按照有关规定做好相关应急处置工作。</p><h1 id="第六章-法律责任"><a href="#第六章-法律责任" class="headerlink" title="第六章  法律责任"></a>第六章  法律责任</h1><p>　　第六十条 银行、支付机构有下列情形之一，侵害消费者金融信息依法得到保护的权利的，中国人民银行或其分支机构应当在职责范围内依照《中华人民共和国消费者权益保护法》第五十六条的规定予以处罚：</p><p>　　（一）未经金融消费者明示同意，收集、使用其金融信息的。</p><p>　　（二）收集与业务无关的消费者金融信息，或者采取不正当方式收集消费者金融信息的。</p><p>　　（三）未公开收集、使用消费者金融信息的规则，未明示收集、使用消费者金融信息的目的、方式和范围的。</p><p>　　（四）超出法律法规规定和双方约定的用途使用消费者金融信息的。</p><p>　　（五）未建立以分级授权为核心的消费者金融信息使用管理制度，或者未严格落实信息使用授权审批程序的。</p><p>　　（六）未采取技术措施和其他必要措施，导致消费者金融信息遗失、毁损、泄露或者被篡改，或者非法向他人提供的。</p><p>　　第六十一条 银行、支付机构有下列情形之一，对金融产品或者服务作出虚假或者引人误解的宣传的，中国人民银行或其分支机构应当在职责范围内依照《中华人民共和国消费者权益保护法》第五十六条的规定予以处罚：</p><p>　　（一）实际承担的义务低于在营销宣传活动中通过广告、资料或者说明等形式对金融消费者所承诺的标准的。</p><p>　　（二）引用不真实、不准确的数据和资料或者隐瞒限制条件等，对过往业绩或者产品收益进行夸大表述的。</p><p>　　（三）利用金融管理部门对金融产品或者服务的审核或者备案程序，误导金融消费者认为金融管理部门已对该金融产品或者服务提供保证的。</p><p>　　（四）明示或者暗示保本、无风险或者保收益等，对非保本投资型金融产品的未来效果、收益或者相关情况作出保证性承诺的。</p><p>　　第六十二条 银行、支付机构违反本办法规定，有下列情形之一，有关法律、行政法规有处罚规定的，依照其规定给予处罚；有关法律、行政法规未作处罚规定的，中国人民银行或其分支机构应当根据情形单处或者并处警告、处以五千元以上三万元以下罚款：</p><p>　　（一）未建立金融消费者权益保护专职部门或者指定牵头部门，或者金融消费者权益保护部门没有足够的人力、物力独立开展工作的。</p><p>　　（二）擅自代理金融消费者办理业务，擅自修改金融消费者的业务指令，或者强制搭售其他产品或者服务的。</p><p>　　（三）未按要求向金融消费者披露与金融产品和服务有关的重要内容的。</p><p>　　（四）利用技术手段、优势地位，强制或者变相强制金融消费者接受金融产品或者服务，或者排除、限制金融消费者接受同业机构提供的金融产品或者服务的。</p><p>　　（五）通过附加限制性条件的方式要求金融消费者购买、使用协议中未作明确要求的产品或者服务的。</p><p>　　（六）未按要求使用格式条款的。</p><p>　　（七）出现侵害金融消费者合法权益重大事件未及时向中国人民银行或其分支机构报告的。</p><p>　　（八）不配合中国人民银行及其分支机构开展金融消费者权益保护领域相关工作，或者未按照规定报送相关资料的。</p><p>　　（九）未按要求对金融消费者投诉进行正确分类，或者迟报、漏报、谎报、错报、瞒报投诉数据的。</p><p>　　（十）收到中国人民银行分支机构转交的投诉后，未在规定期限内答复投诉人，或者未按要求向中国人民银行分支机构反馈投诉处理情况的。</p><p>　　（十一）拒绝、阻挠、逃避检查，或者谎报、隐匿、销毁相关证据材料的。</p><p>　　第六十三条 对银行、支付机构侵害金融消费者权益重大案件负有直接责任的董事、高级管理人员和其他直接责任人员，有关法律、行政法规有处罚规定的，依照其规定给予处罚；有关法律、行政法规未作处罚规定的，中国人民银行或其分支机构应当根据情形单处或者并处警告、处以五千元以上三万元以下罚款。</p><p>　　第六十四条 中国人民银行及其分支机构的工作人员在开展金融消费者权益保护工作过程中有下列情形之一的，依法给予处分；涉嫌构成犯罪的，移送司法机关依法追究刑事责任：</p><p>　　（一）违反规定对银行、支付机构进行检查的。</p><p>　　（二）泄露知悉的国家秘密或者商业秘密的。</p><p>　　（三）滥用职权、玩忽职守的其他行为。</p><h1 id="第七章-附-则"><a href="#第七章-附-则" class="headerlink" title="第七章  附  则"></a>第七章  附  则</h1><p>　　第六十五条 商业银行理财子公司、金融资产管理公司、信托公司、<strong>汽车金融公司</strong>、消费金融公司以及征信机构、个人本外币兑换特许业务经营机构参照适用本办法。法律、行政法规另有规定的，从其规定。</p><p>　　第六十六条 本办法中除“工作日”以外的“日”为自然日。</p><p>　　第六十七条 本办法由中国人民银行负责解释。</p><p>　　第六十八条 本办法自2020年11月1日起施行。《中国人民银行金融消费权益保护工作管理办法（试行）》（银办发〔2013〕107号文印发）与《中国人民银行金融消费者权益保护实施办法》（银发〔2016〕314号文印发）同时废止。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;第一章-总-则&quot;&gt;&lt;a href=&quot;#第一章-总-则&quot; class</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="法律合规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/"/>
    
    <category term="1.消费者权益保护" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/1-%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%83%E7%9B%8A%E4%BF%9D%E6%8A%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>民法典-人格权</title>
    <link href="http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/1.3%E6%B6%88%E4%BF%9D-%E9%9A%90%E7%A7%81%E6%9D%83/"/>
    <id>http://example.com/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/1.3%E6%B6%88%E4%BF%9D-%E9%9A%90%E7%A7%81%E6%9D%83/</id>
    <published>2023-09-29T12:05:15.000Z</published>
    <updated>2023-10-04T04:50:49.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>《<a href="https://alphalawyer.cn/ilawregu-search/api/v1/lawregu/redict/38c5d01eedd454cc67a12a22cfe4a84d">中华人民共和国民法典</a>》</p><p>（2020 年 5 月 28  日第十三届全国人民代表大会第三次会议通过）</p><p>时效性：    现行有效</p><p>发文机关：  全国人民代表大会</p><p>文号：      主席令第 45 号</p><p>发文日期：  2020 年 05 月 28 日</p><p>施行日期：  2021 年 01 月 01 日</p></blockquote><h1 id="第四编-人格权"><a href="#第四编-人格权" class="headerlink" title="第四编  人格权"></a>第四编  人格权</h1><h2 id="第六章-隐私权和个人信息保护"><a href="#第六章-隐私权和个人信息保护" class="headerlink" title="第六章  隐私权和个人信息保护"></a>第六章  隐私权和个人信息保护</h2><p><strong>第一千零三十二条</strong>   自然人享有隐私权。任何组织或者个人不得 以刺探 、侵扰 、泄露 、公开等方式侵害他人的隐私权。</p><p>隐私是自然人的私人生活安宁和不愿为他人知晓的私密空间、私 密活动 、私密信息。</p><p><strong>第一千零三十三条</strong>  除法律另有规定或者权利人明确同意外，任何组织或者个人不得实施下列行为：</p><p>（一） 以电话 、短信、即时通讯工具 、 电子邮件 、传单等方式侵 扰他人的私人生活安宁；</p><p>（ 二）进入、拍摄、窥视他人的住宅 、宾馆房间等私密空间；</p><p>（ 三）拍摄、窥视、 窃听、公开他人的私密活动；</p><p>（ 四）拍摄、窥视他人身体的私密部位；</p><p>（五）处理他人的私密信息；</p><p>（六） 以其他方式侵害他人的隐私权。</p><p><strong>第一千零三十四条</strong>   自然人的个人信息受法律保护。</p><p>个人信息是以电子或者其他方式记录的能够单独或者与其他信 息结合识别特定自然人的各种信息 ，包括自然人的姓名 、 出生日期、 身份证件号码 、生物识别信息 、住址 、 电话号码 、 电子邮箱 、健康信 息 、行踪信息等。</p><p>个人信息中的私密信息 ，适用有关隐私权的规定； 没有规定的， 适用有关个人信息保护的规定。</p><p><strong>第一千零三十五条</strong>  处理个人信息的，应当遵循合法 、正当、必 要原则，不得过度处理， 并符合下列条件：</p><p>（一）征得该自然人或者其监护人同意，但是法律、行政法规另 有规定的除外；</p><p>（ 二）公开处理信息的规则；</p><p>（ 三） 明示处理信息的目的 、方式和范围；</p><p>（ 四） 不违反法律、行政法规的规定和双方的约定。</p><p>个人信息的处理包括个人信息的收集、存储、使用、加工、传输、 提供、公开等。</p><p><strong>第一千零三十六条</strong>  处理个人信息，有下列情形之一 的，行为人不承担民事责任：</p><p>（一）在该自然人或者其监护人同意的范围内合理实施的行为；</p><p>（ 二）合理处理该自然人自行公开的或者其他已经合法公开的信 息 ，但是该自然人明确拒绝或者处理该信息侵害其重大利益的除外；</p><p>（ 三）为维护公共利益或者该自然人合法权益，合理实施的其他 行为。</p><p><strong>第 一 千零三十七条</strong>   自然人可以依法向信息处理者查阅或者复制其个人信息；发现信息有错误的，有权提出异议并请求及时采取更 正等必要措施。</p><p>自然人发现信息处理者违反法律、行政法规的规定或者双方的约 定处理其个人信息的， 有权请求信息处理者及时删除。</p><p><strong>第一千零三十八条</strong>  信息处理者不得泄露或者篡改其收集、存储 的个人信息；未经自然人同意，不得向他人非法提供其个人信息，但是经过加工无法识别特定个人且不能复原的除外。</p><p>信息处理者应当采取技术措施和其他必要措施，确保其收集、存 储的个人信息安全 ，防止信息泄露 、篡改 、丢失；发生或者可能发生 个人信息泄露 、篡改、丢失的，应当及时采取补救措施，按照规定告 知自然人并向有关主管部门报告。</p><p><strong>第一千零三十九条</strong>  国家机关、承担行政职能的法定机构及其工 作人员对于履行职责过程中知悉的自然人的隐私和个人信息，应当予 以保密，不得泄露或者向他人非法提供。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;《&lt;a href=&quot;https://alphala</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="法律合规" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/"/>
    
    <category term="1.消费者权益保护" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/1-%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%83%E7%9B%8A%E4%BF%9D%E6%8A%A4/"/>
    
    
  </entry>
  
</feed>
