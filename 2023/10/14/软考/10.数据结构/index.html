<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>9.文老师-数据结构 | 民工的自我修养</title><meta name="author" content="民工的自我修养"><meta name="copyright" content="民工的自我修养"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构线性结构线性表 线性结构:每个元素最多只有一个出度和一个入度，表现为一条线状。线性表按存储方式【存储结构】分为顺序 表和链表。  顺序存储:用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素物理上也相邻。  链式存储:存储各数据元素的结点的**地址并不要求是连续的，数据元素逻辑上相邻,物理上分开；一个节点分为数据域和指针域，数据域记录了当前节点的数据，指针域记录了下一"><meta property="og:type" content="article"><meta property="og:title" content="9.文老师-数据结构"><meta property="og:url" content="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="民工的自我修养"><meta property="og:description" content="数据结构线性结构线性表 线性结构:每个元素最多只有一个出度和一个入度，表现为一条线状。线性表按存储方式【存储结构】分为顺序 表和链表。  顺序存储:用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素物理上也相邻。  链式存储:存储各数据元素的结点的**地址并不要求是连续的，数据元素逻辑上相邻,物理上分开；一个节点分为数据域和指针域，数据域记录了当前节点的数据，指针域记录了下一"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/cover/2017GuiDao/103.jpg"><meta property="article:published_time" content="2023-10-14T12:06:15.000Z"><meta property="article:modified_time" content="2023-10-15T11:32:04.445Z"><meta property="article:author" content="民工的自我修养"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/cover/2017GuiDao/103.jpg"><link rel="shortcut icon" href="/cover/2017GuiDao/6.jpg"><link rel="canonical" href="http://example.com/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:500,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"9.文老师-数据结构",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-10-15 19:32:04"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="民工的自我修养" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">401</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">163</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/cover/2017GuiDao/103.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">民工的自我修养</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">9.文老师-数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-14T12:06:15.000Z" title="发表于 2023-10-14 20:06:15">2023-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-15T11:32:04.445Z" title="更新于 2023-10-15 19:32:04">2023-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E8%80%83/">软考</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014182707252.png" alt="image-20231014182707252"></p><p>线性结构:每个元素<strong>最多只有一个出度和一个入度</strong>，表现为一条线状。线性表<strong>按存储方式【存储结构】分为顺序</strong> <strong>表和链表</strong>。</p><ul><li><p>顺序存储:用一组<strong>地址连续的存储单元</strong>依次存储线性表中的数据元素，使得<strong>逻辑上相邻的元素物理上也相邻</strong>。</p></li><li><p>链式存储:存储各数据元素的结点的**<u>地址并不要求是连续的</u><strong>，数据元素逻辑上相邻,物理上分开；</strong>一个节点分为数据域和指针域，数据域记录了当前节点的数据，指针域记录了下一个相邻节点的物理地址**。</p></li></ul><p>顺序存储和链式存储的对比如下图所示:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014183449722.png" alt="image-20231014183449722"></p><p>◆在空间方面，因为链表还需要存储指针，因此有空间浪费存在。</p><p>◆在时间方面，当需要<strong>对元素进行破坏性操作(插入、删除)时，链表效率更高</strong>，<u>因为其只需要修改指针指向即可，而顺序表因为地址是连续的，当删除或插入一个元素后，后面的其他节点位置都需要变动</u>。</p><p>◆而当需要对元素进行**不改变结构操作时(读取)，顺序表效率更高,**因为其物理地址是连续的，如同数组一般，只需按索引号就可快速定位，而链表需要从头节点开始，一个个的查找下去。</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>队列、栈结构如下图；</p><p><strong>队列是先进先出，分队头和队尾;</strong></p><p><strong>栈是先进后出，只有栈顶能进出。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014214721898.png" alt="image-20231014214721898"></p><h3 id="循环队列【考点】"><a href="#循环队列【考点】" class="headerlink" title="循环队列【考点】"></a>循环队列【考点】</h3><p>设循环队列Q的容量为MAXSIZE,初始时队列为空，且Q.rear 和Q.front都等于0。</p><blockquote><p>队头指针永远指向队列第一个元素的地址。队尾指针永远指向队列最后一个元素的下一个元素的地址。</p><p>队头指针——&gt;读操作——&gt;指向当前元素</p><p>队尾指针——&gt;写操作——&gt;指向队列最后一个元素的空闲区域</p></blockquote><p>元素<strong>入队时</strong>修改<strong>队尾</strong>指针，即令Q.rear&#x3D;(Q.rear+1)%MAXSIZE.【%指取余操作】</p><p>元素<strong>出队时</strong>修改<strong>队头</strong>指针，即令Q.front&#x3D;(Q.front+ 1)%MAXSIZE。</p><p>根据队列操作的定义，当出队操作导致队列变为空时,有Q.rear&#x3D;&#x3D;Q.front;若入队操作导致队列满，则Q.rear&#x3D;&#x3D;Q.front。此时无法区分队列空还是队列满。</p><p>在队列空和队列满的情况下，循环队列的队头、队尾指针指向的位置是相同的，此时仅仅根据Q.rear和Q.front之间的关系无法断定队列的状态。为了区别队空和队满的情况，可采用以下两种处理方式:</p><p>其一是设置一个标志，以区别头、尾指针的值相同时队列是空还是满;</p><p>其二是**<u>牺牲一个存储单元，约定以“队列的尾指针所指位置的下一个位置是队头指针时”表示队列满</u>**，如图所示，而头、尾指针的值相同时表示队列为空。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014215959474.png" alt="image-20231014215959474"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1.对于线性表，相对于顺序存储，采用链表存储的缺点是(A) 。</p><p>A.数据元素之间的关系需要占用存储空间，导致存储密度不高</p><p>B.表中结点必须占用地址连续的存储单元，存储密度不高</p><p>C.插入新元素时需要遍历整个链表，运算的时间效率不高</p><p>D.删除元素时需要遍历整个链表，运算的时间效率不高</p><p>2.若一个栈初始为空，其输入序列是1，2, 3, …. n-1, n,其输出序列的第一个元素为k(1≤ k≤ [n&#x2F;2」),则输出序列的最后一个元素是(D)</p><p>A.值为n的元素</p><p>B.值为1的元素</p><p>C.值为n-k的元素</p><p>D.不确定的</p><ol start="3"><li></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014221225325.png" alt="image-20231014221225325"></p><p>答案：D</p><ol start="4"><li></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231014221612909.png" alt="image-20231014221612909"></p><p>答案：B</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一种<strong>特殊的线性表</strong>，其数据元素都为字符。</p><p>◆空串:长度为的字符串，没有任何字符。</p><p>◆空格串:由一个或多个空格组成的串，空格是空白字符,占一个字符长度。</p><blockquote><p>空格是一个空白字符。</p></blockquote><p>◆子串:串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串，空串是任意串的子串。</p><p>◆串的模式匹配:子串的定位操作，用于<strong>查找子串在主串中第一次出现的位置的算法</strong>。</p><h3 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h3><h4 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h4><p><strong>朴素的模式匹配算法</strong>:也称为布鲁特——福斯算法， 其基本思想是<strong>从主串的第1个字符起与模式串的第1个字符比较，若相等，则继续逐个字符进行后续的比较;否则从主串中的<u>第2个字符起</u>与模式串的第1个字符重新比较</strong>，直至模式串中每个字符依次和主串中的一个连续的字符序列相等时为止，此时称为匹配成功，否则称为匹配失败。</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>KMP算法：对基本模式匹配算法的改进，其改进之处在于:每当匹配过程中出现<strong>相比较的字符不相等时，不需要回溯主串的字符位置指针，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的距离</strong>，再继续进行比较。</p><p>当模式串中的字符 pj 与主串中相应的字符Si不相等时，因其前j个字符(“p…pj-1”)已经获得了成功的匹配，所以**若模式串中”p0…pk-1”与”pj-k…pj-1”相同，这时可令pk与si进行比较，<u>从而使i无须回退</u>**。</p><p>在KMP算法中，依据b。若令next[j]&#x3D;k,则next[j]表示当模式串中的pj与主串中相应字符不相等时，<strong>令模式串的nex[j]与主串的相应字符进行比较</strong>。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>在字符串的KMP模式匹配算法中，需先求解模式串的next函数值，其定义如下式所示，j表示模式 串中字符的序号 (从 1 开始)。若模式串 $p$ 为 “abaac”，则其next函数值为 ()。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015111921751.png" alt="image-20231015111921751"></p><p>A. 01234 B. 01122 C. 01211 D. 01111</p><p>解析:考查字符串的模式匹配算法。关键在于理解公式，而后从1开始代入，过程如下:</p><p>j&#x3D;1时p1为a，此时输出next[1]&#x3D;0,</p><p>j&#x3D;2时p2为b，比较中间的判断条件，1&lt;k&lt;j, 但j&#x3D;2， 故k为空，故next[2]&#x3D;1,</p><p>j&#x3D;3时p3&#x3D;a,此时k只能等于2，p1不等于p2,故不能满足中间的情况，此时next[3]&#x3D;1,</p><p>再取j&#x3D;4，k可以等于2或3，判断发现k&#x3D;2时满足但k&#x3D;3不满足，故next[4]&#x3D;2,</p><p>再取j&#x3D;5，k可以等于2或3或4，比较p1p2Lpk 1和右边那个等式，发现k&#x3D;2时成立，next[5]&#x3D;2。</p><p>故答案应该为B: 01122 。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是<strong>定长线性表在维度上的扩展</strong>, 即<strong>线性表中的元素又是一个线性表</strong>。 N维数组是一种 “同构” 的数据结构, 其<strong>每个数据元素类型相同、结构一致</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113002293.png" alt="image-20231015113002293"></p><p>其可以表示为行向量形式或者列向量形式线性表，单个关系最多只有一个前 驱和一个后继, 本质还是线性的。</p><p>数组结构的特点: <strong>数据元素数目固定; 数据元素类型相同; 数据元素的下标 关系具有上下界的约束且下标有序。</strong></p><p>数组数据元素固定, 一般不做插入和删除运算, <strong>适合于采用顺序结构</strong>。</p><p>数组存储地址的计算,特别是二维数组，要注意理解，假设每个数组元素占用存储长度为len，起始地址为a，存储地址计算如下(<strong>默认从0开始编号</strong>) :</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113252350.png" alt="image-20231015113252350"></p><blockquote><p>考试中直接取特殊值求答案。</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>特殊矩阵:矩阵中的元素(或非0元素)的分布有定的规律。常见的特殊矩阵有对称矩阵、三角矩阵和对角矩阵。</p><p>稀疏矩阵:在一个矩阵中，若非零元素的个数远远少于零元素个数，且非零元素的分布没有规律。</p><p><strong>存储方式为三元组结构，即存储每个非零元素的(行，列，值)。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015113930675.png" alt="image-20231015113930675"></p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015114316509.png" alt="image-20231015114316509"></p><blockquote><p>特殊值代入计算。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015114817931.png" alt="image-20231015114817931"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>广义表是线性表的推广，<strong>是由0个或多个单元素或子表组成的有限序列</strong>。</p><p>广义表与线性表的区别:线性表的元素都是结构上不可分的单元素,而<strong>广义表的元素既可以单元素，也可以是有结构的表</strong>。</p><p>广义表一般记为: LS&#x3D; (a1, a2, .. an)。其中LS是表名，ai是表元素，它可以是表(称为子表)，也可以是数据元素(称 为原子)。其中n是**广义表的长度(也就是最外层包含的元素个数)<strong>，n&#x3D;0的广义表为空表;而</strong>递归定义的重数就是广义表的深度，即定义中所含括号的重数(单边括号的个数，原子的深度为0，空表的深度为1)**。</p><blockquote><p>一般计算单边括号的个数就能得到表的深度。</p></blockquote><p>head()和tail():<strong>取表头</strong>(<strong>广义表第一个表元素</strong>，可以是子表也可以是单元素)和<strong>取表尾</strong>(**广义表中，除了第一个表元素之外的其他所有表元素构成的<u>表</u>**，非空广义表的表尾必定是一个表, 即使表尾是单元素)操作。</p><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>树是n个节点的有限集合(n&gt;&#x3D;0) ，当n&#x3D;0时称为空树，在任一颗非空树中，<strong>有且仅有一个根节点</strong>。其余结点可分为m(m&gt;&#x3D;0)个互不相交的有限子集T1，T2, … Tm，其中，每个Ti又都是一棵树，井且称为根结点的子树。</p><h3 id="树的基本概念如下"><a href="#树的基本概念如下" class="headerlink" title="树的基本概念如下"></a>树的基本概念如下</h3><p>(1)<strong>双亲、孩子和兄弟</strong>。结点的子树的根称为该结点的孩子;相应地，该结点称为其子结点的双亲。具有相同双亲的结点互为兄弟。</p><p>(2)<strong>结点的度</strong>。一个结点的子树的个数记为该结点的度。例如A的度为3，B的度为2，C的度为0，D的度为1。</p><blockquote><p>就是该节点的出度。</p></blockquote><p>(3)<strong>叶子结点</strong>。叶子结点也称为终端结点，<strong>指度为0的结点</strong>。例如，E、 F、C、G都是叶子结点。</p><p>(4)<strong>内部结点</strong>。度不为0的非根结点，也称为分支结点或非终端结点。除根结点以外，分支结点也称为内部结点。例如，B、D都是内部结点。</p><p>(5)<strong>结点的层次</strong>。根为第一层，根的孩子为第二层，依此类推，若某结点在第i层，则其孩子结点在第1+1层。例如，A在第1层，B、C、D在第2层，E、F和G在第3层。</p><p>(6)<strong>树的高度</strong>。一棵树的最大层数记为树的高度(或深度)。例如，图中所示树的高度为3。</p><p>(7)<strong>有序(无序)树</strong>。若将树中结点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树，否则称为无序树。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015120007862.png" alt="image-20231015120007862"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>二叉树是n个节点的有限集合,它或者是空树，或者是由一个根节点及<strong>两颗互不相交的且分别称为左、右子树的二叉树所组成</strong>。</p><blockquote><p>子树个数小于等于2.</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015122445611.png" alt="image-20231015122445611"></p><p>两种特殊的二叉树:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015122546634.png" alt="image-20231015122546634"></p><p><strong>满二叉树</strong>：除叶子节点外，每个节点的度都为2。</p><p><strong>完全二叉树</strong>：完全二叉树有n层，n-1层是满的，最后一层从左到右是不间断的。</p><p><strong>非完全二叉树</strong>：完全二叉树有n层，n-1层是满的，最后一层从左到右是间断的。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>二叉树有一些性质如下, 要求掌握, 在实际考试中可以用特殊值法验证。</p><p>(1) 二叉树<strong>第 $i$ 层 $(i \geq 1)$ 上至多有 $2 ^{i-1}$ 个节点</strong>。</p><p>(2) <strong>深度为 $k$ 的二叉树至多有 $2^{k}-1$ 个节点 $(k \geq 1)$</strong> 。</p><p>(3) <strong>对任何一棵二叉树, 若其终端节点数为 $n_0$, 度为2的节点数为 $n_2$, 则 $n_0&#x3D;n_2+1$</strong> 。</p><blockquote><p>此公式可以画一个简单的二叉树使用特殊值法快速验证, 也可以证明如下: 设一棵二叉树上叶结点数为 $n_0$, 单分支结点数为 $n_1$, 双分支结点数为 $ {n}_2$, 则总的点数 $&#x3D;n_0+n_1+n_2$ 。在一棵二叉树中, 所有结点的分支数(即度数)应等于单分支结点 数加上双分支结点数的 2 倍, 即总的分支数 $&#x3D;n_1+2 n_2$ 。由于二叉树中除根结点以外, 每个结点都有唯一的一个分支指向它, 因此二叉树中: 总的分支数&#x3D;总结点数 -1 。</p></blockquote><p>(4) <strong>具有 $n$ 个节点的完全二叉树的深度为 $\lfloor\log 2 n\rfloor+1$</strong> 。【向下取整】</p><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><p>顺序存储，就是<strong>用一组连续的存储单元存储二叉树中的节点</strong>，按照<strong>从上到下，从左到右的顺序依次存储每个节点</strong>。</p><blockquote><p>一般只适用于完全二叉树和满二叉树。</p></blockquote><p>对于深度为k的完全二叉树，除第k层外，其余每层中节点数都是上一层的两倍，由此，从一个节点的编号可推知其双亲、左孩子、右孩子结点的编号。假设有编号为i的节点，则有:</p><p>若i&#x3D;1，则该节点为根节点，无双亲;</p><p>若i&gt;1， 则该节点的双亲节点为[i&#x2F;2]【向下取整】。</p><p>若2i&lt;&#x3D;n，则该节点的左孩子编号为2i,否则无左孩子。</p><p>若2i+1&lt;&#x3D;n，则该节点的右孩子编号为2i+1，否则无右孩子。</p><p>显然，顺序存储结构对完全二叉树而言既简单又节省空间，而对于一般二叉树则不适用。因为在顺序存储结构中，以节点在存储单元中的位置来表示节点之间的关系，那么对于一般的二叉树来说，也必须按照完全二叉树的形式存储，也就是要添上一些实际并不存在的“虚节点”，这将造成空间的浪费。</p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>由于二叉树中节点包含有数据元素、左子树根、右子树根及双亲等信息，因此可以用<strong>三叉链表</strong>或<strong>二叉链表</strong>(即一个节点含有三个指针或两个指针)来存储二叉树，链表的头指针指向二叉树的根节点。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015135005935.png" alt="image-20231015135005935"></p><blockquote><p>三个指针一个指向双亲节点，另外两个指向左右孩子。</p></blockquote><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>◆一颗非空的二叉树由根节点、左子树、右子树三部分组成。遍历这三E部分，也就遍历了整颗二叉树。这三部分遍历的基本顺序是先左子树后右子树，但根节点顺序可变，<strong>以根节点访问的顺序为准有下列三种遍历方式</strong>:</p><p><strong>先序(前序)遍历</strong>:根左右。</p><p><strong>中序遍历</strong>:左根右。</p><p><strong>后序遍历</strong>:左右根。</p><p>示例:前序: 12457836 中序: 42785136 后序: 48752631</p><blockquote><p>中序、后序从叶节点开始访问。</p></blockquote><p>◆层次遍历:按层次，从上到下，从左到右。 ◆反向构造_ &#x3D;叉树: 仅仅有前序和后序是无法构造二叉树的，必须要是和中序遍历的集合才能反向 构造出二叉树。 构造时，前序和后序遍历可以确定根节点，中序遍历用来确定根节点的左子树 节点和右子树节点，而后按此方法进行递归，直至得出结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015135239186.png" alt="image-20231015135239186"></p><h3 id="反向构造二叉树"><a href="#反向构造二叉树" class="headerlink" title="反向构造二叉树"></a>反向构造二叉树</h3><p>仅仅有前序和后序是无法构造二叉树的，<strong>必须要是和中序遍历的集合才能反向构造出二叉树</strong>。</p><blockquote><p>中序+前序或 中序+后续 才能反向构造二叉树。</p></blockquote><p>构造时，前序和后序遍历可以确定根节点，<strong>中序遍历用来确定根节点的左子树节点和右子树节点</strong>，而后按此方法进行递归，直至得出结果。</p><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p>一个高度为h的满二叉树的结点总数为2^h-1, 从根结点开始，自上而下、同层次结点从左至右，对结点按照顺序依次编号，即根结点编号为1,其左、右孩子结点编号分别为2和3,再下一层从左到右的编号为4，5，6, 7,依此类推。那么，在一棵满二叉树中，对于编号为m和n的两个结点，若n&#x3D;2m+1，则(D)</p><p>A.m是n的左孩子</p><p>B.m是n的右孩子</p><p>C.n是m的左孩子</p><p>D.n是m的右孩子</p><p>某二叉树如图所示，若进行顺序存储(即用一维数组元素存储该二叉树中的结点且通过下标反映结点间的关系，例如，<strong>对于下标为i的结点,其左孩子的下标为2i、右孩子的下标为2i+1</strong>)，则该数组的大小至少为(D) ;若采用三叉链表存储该二叉树(各个结点包括结点的数据、父结点指针、左孩子指针、右孩子指针)，则该链表的所有结点中空指针的数目为(B)。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142322242.png" alt="image-20231015142322242"></p><p>A.6B.10C.12.D.15 A.6B.8C.12D.14</p><blockquote><p>把上图二叉树补为完全二叉树。2^4-1&#x3D;15。</p><p>一共有6个节点，每个节点有三个指针域。</p></blockquote><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>引入线索二叉树是为了<strong>保存二叉树遍历时某节点的前驱节点和后继节点的信息</strong>，二叉树的链式存储只能获取到某节点的左孩子和右孩子结点，无法获取其遍历时的前驱和后继节点，因此可以<strong>在链式存储中再增加两个指针域【四叉链表】</strong>，使其分别指向前驱和后继节点，但这样太浪费存储空间，考虑下述实现方法:</p><p>若<strong>n个节点的二叉树使用二叉链表存储，则必然有n+1个空指针域</strong>，利用这些空指针域来存放节点的前驱和后继节点信息，为此，需要增加两个标志，以区分指针域存放的到底是孩子结点还是遍历节点，如下:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142736066.png" alt="image-20231015142736066"></p><p>若二叉树的二叉链表采用上述结构, 则称为<strong>线索链表</strong>, 其中指向前驱、后继节点的指针称为线索，加上线索的二叉树称为线索二叉树。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015142906222.png" alt="image-20231015142906222"></p><h3 id="哈夫曼树【考点】"><a href="#哈夫曼树【考点】" class="headerlink" title="哈夫曼树【考点】"></a>哈夫曼树【考点】</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>最优二叉树又称为哈夫曼树，是一类<strong>带权路径长度最短的树</strong>，相关概念如下:</p><blockquote><p>一个节点到另外一个结点的通路叫路径。</p></blockquote><p>◆ 路径:树中一个结点到另一个结点之间的通路。</p><p>◆结点的路径长度:路径上的分支数目。</p><p>◆树的路径长度:<strong>根节点到达每一个叶子节点之间的路径长度之和</strong>。</p><p>◆权:<strong>节点代表的值</strong>。</p><p>◆结点的带权路径长度:<strong>该结点到根结点之间的路径长度乘以该节点的权值</strong>。</p><p>◆树的带权路径长度(<strong>树的代价</strong>):<strong>树的所有叶子节点的带权路径长度之和</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015143629621.png" alt="image-20231015143629621"></p><h4 id="哈夫曼树的求法"><a href="#哈夫曼树的求法" class="headerlink" title="哈夫曼树的求法"></a>哈夫曼树的求法</h4><p>给出一组权值，<strong>将其中两个最小的权值作为叶子节点，其和作为父节点，组成二叉树，而后删除这两个叶子节点权值，并将父节点的值添加到该组权值中</strong>。重复进行上述步骤，直至所有权值都被使用完。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015144052502.png" alt="image-20231015144052502"></p><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>若需要构造哈夫曼编码(要保证<strong>左节点值小于右节点的值</strong>，才是<strong>标准的哈夫曼树</strong>) <strong>将标准哈夫曼树的左分支设为0,右分支设为1,写出每个叶节点的编码</strong>，会发现，哈夫曼编码前缀不同，因此不会混淆，同时也是最优编码。</p><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015150748271.png" alt="image-20231015150748271"></p><p>答案：AC</p><h3 id="查找二叉树（排序二叉树）【考点】"><a href="#查找二叉树（排序二叉树）【考点】" class="headerlink" title="查找二叉树（排序二叉树）【考点】"></a>查找二叉树（排序二叉树）【考点】</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015154438092.png" alt="image-20231015154438092"></p><p>◆查找二叉树上的每个节点都存储一个值，且<strong>每个节点的所有左孩子结点值都小于父节点值，而所有右孩子结点值都大于父节点值</strong>，是一个有规律排列的二叉树，这种数据结构可以<strong>方便查找</strong>【每一次都把查找范围缩小一半】、插入等数据操作。</p><p>◆二叉排序树的查找效率取决于二叉排序树的深度，<strong>对于结点个数相同的二叉排序树，平衡二叉树的深度最小</strong>，而<strong>单枝树的深度是最大的，故效率最差</strong>。【深度越大比较的次数越多】</p><p>◆平衡二叉树又称为<strong>AVL</strong>树【查找效率最高，深度最小】，它或者是一棵空树，或者是具有下列性质的二叉树。它的左子树和右子树都是平衡二叉树，<strong>且左子树和右子树的高度之差的绝对值不超过1</strong>。若将二叉树结点的<strong>平衡因子(Balance Factor, BF)定义为该结点左子树的高度减去其右子树的高度</strong>，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要树上有一个结点的平衡因子的绝对值大于1,则该二叉树就是不平衡的。</p><h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><p>某二叉树的先序遍历列为cabfedg,中序遍历序列为abcdefg,则二叉树是(C)。</p><p>A.完全二叉树</p><p>B.最优二叉树</p><p>C.平衡二叉树</p><p>D.满二叉树</p><blockquote><p>通过cabfedg确定c是根节点，进而把abcdefg分为左右子树：左子树：ab，右子树：defg；</p><p>通过前序遍历ab知道a是根结点，fedg知道f是右子树根节点。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015155253456.png" alt="image-20231015155253456"></p><p>答案：C</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>◆无向图:图的结点之间连接线是<strong>没有箭头的，不分方向</strong>。</p><p>◆有向图:图的结点之间<strong>连接线是箭头，区分A到B，和B到A是两条线</strong>。</p><p>◆完全图:无向完全图中，<strong>节点<u>两两之间</u>都有连线</strong>，n个结点的连线数为（n-1）+(n-2)+…+1&#x3D; n(n-1)&#x2F;2;有向完全图中，节点两两之间都有互通的两个箭头，n个节点的连线数为n(n-1)。</p><p>◆度、出度和入度:顶点的度是<strong>关联与该顶点的边的数目</strong>。在有向图中，<u>顶点的度为出度和入度之和</u>。</p><p>◆路径:存在一条通路，可以从一个顶点到达另一个顶点。</p><p>◆子图:<strong>有两个图G&#x3D;(V, E)和G’&#x3D;(V’, E’)，如果V’∈V且E’∈E，则称G’为G的子图</strong>。</p><blockquote><p>V是定点结合，E是边的集合。</p></blockquote><p>◆连通图和连通分量:<strong>针对无向图</strong>。若从顶点v到顶点u之间是有路径的，则说明v和u之间是连通的，若无向图中任意两个顶点之间都是连通的，则称为连通图。无向图G的<u>极大连通子图</u>称为其连通分量。</p><p>◆强连通图和强连通分量:<strong>针对有向图</strong>。若有向图任意两个顶点间都互相存在路径，即存在v到u，也存在u到v的路径，则称为强连通图。有向图中的极大连通子图称为其强连通分量。</p><p>◆网:<strong>边带权值的图称为网</strong>。</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p><strong>邻接矩阵</strong>:假设一个图中有<strong>n个节点， 则使用n阶矩阵来存储这个图中各节点的关系,规则是若节点i到节点j有连线，则矩阵Ri,j&#x3D;1, 否则为0</strong>，示例如下图所示:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015165419622.png" alt="image-20231015165419622"></p><blockquote><p>无向图的邻接矩阵是一个对角阵。</p></blockquote><p>适合边比较多的图。</p><p><strong>邻接链表</strong>:用到了两个数据结构,先用一个一维数组将图中所有顶点存储起来，而后，对此一维数组的每个顶点元素，使用链表挂上其出度到达的结点的编号和权值，示例如下图所示:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015165801499.png" alt="image-20231015165801499"></p><p>存储特点:<strong>图中的顶点数决定了邻接矩阵的阶和邻接表中的单链表数目，边数的多少决定了单链表中的结点数</strong>，<strong>而不影响邻接矩阵的规模</strong>，因此采用何种存储方式与有向图、无向图没有区别，要看图的边数和顶点数，<strong>完全图适合采用邻接矩阵存储</strong>。</p><blockquote><p>有向图只考虑出度。</p></blockquote><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>◆图的遍历是<strong>指从图的任意节点出发</strong>，<strong>沿着某条搜索路径对图中所有节点进行访问且只访问一次</strong>,分为以下两种方式:</p><blockquote><p>图的遍历方式不唯一。</p></blockquote><p>◆深度优先遍历:<strong>从任一顶点出发,遍历到底，直至返回，再选取任一其他节点出发</strong>，重复这个过程直至遍历完整个图;</p><p>◆广度优先遍历:先访问完一个顶点的所有邻接顶点，<strong>而后再依次访问其邻接顶点的所有邻接顶点</strong>，类似于层次遍历。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015170314834.png" alt="image-20231015170314834"></p><h3 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h3><p>假设有n个节点，那么这个图的最小生成树有n-1条边(不会形成环路，是树非图)，这n-1条边应该会将所有顶点都连接成一个树，井且这些边的权值之和最小，因此称为最小生成树。共有下列两种算法:</p><h4 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h4><p><strong>普里姆算法</strong>:从<strong>任意顶点出发，找出与其邻接的边权值最小的，此时此边的另外一个顶点自动加入树集合中，而</strong> <strong>后再从<u>这个树集合的所有顶点</u>中找出与其邻接的边权值最小的</strong>，同样此边的另外一个顶点加入树集合中，依次递 归，直至图中所有顶点都加入树集合中，此时此树就是该图的最小生成树。普里姆算法的时间复杂度为0(n^2)，<strong>与图中的边数无关，因此该算法适合于求边稠密的网的最小生成树</strong>。</p><blockquote><p>最小生成树不唯一。但最终的权值之和相等。在面临多个相同的权值时，对权值的选择要保证不能形成一个环，如果形成一个环，既不符合定义了。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015170655573.png" alt="image-20231015170655573"></p><h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><p>克鲁斯卡尔算法(推荐) :这个算法是<strong>从边出发的</strong>，因为本质是选取权值最小的n-1条边，因此，就将边按权值大小排序，依次选取权值最小的边，直至囊括所有节点，要注意，每次选边后要检查<strong>不能形成环路</strong>。克鲁斯卡尔算法的时间复杂度为0(eloge)，与图中的顶点数无关，因此该算法<strong>适合于求边稀疏的网的最小生成树</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015171605178.png" alt="image-20231015171605178"></p><h3 id="拓扑序列【考点】"><a href="#拓扑序列【考点】" class="headerlink" title="拓扑序列【考点】"></a>拓扑序列【考点】</h3><p>若<strong>图中一个节点入度为0，则应该最先执行此活动，而后删除掉此节点和其关联的有向边，再去找图中其他没有入度的结点，执行活动，依次进行</strong>，示例如下(有点类似于进程的前趋图原理)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015171944618.png" alt="image-20231015171944618"></p><h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172250039.png" alt="image-20231015172250039"></p><p>答案：AB</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172257703.png" alt="image-20231015172257703"></p><p>答案：A</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172520892.png" alt="image-20231015172520892"></p><p>答案：CA</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015172749299.png" alt="image-20231015172749299"></p><p>答案:C</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>◆顺序查找的思想:将待查找的关键字为key的元素从头到尾与表中元素进行比较，如果中间存在关键字为key的元素，则返回成功;否则，则查找失败。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015173203799.png" alt="image-20231015173203799"></p><p>时间复杂度为O(n);</p><h2 id="折半查找【考点】"><a href="#折半查找【考点】" class="headerlink" title="折半查找【考点】"></a>折半查找【考点】</h2><p>◆只适用于待查找序列中的元素是<strong>有序排列</strong>的情况。</p><p>◆设查找表的元素存储在一维数组r[1..n]中，在表中元素已经按照关键字递增(或递减)方式排序的情况下，进行折半查找的方法是:</p><p>1、首先将待查元素的关键字(key) 值与表r中间位置上(下标为mid)记录的关键字进行比较，若相等，则查找成功;</p><p>2、若key&gt;r[mid].key，则说明待查记录只可能在后半个子表r[mid+1..n]中，下一步应在后半个子表中查找;</p><p>3、若key&lt;r[mid].key， 说明待查记录只可能在前半个子表r[1..mid-1]中，下一步应在r的前半个子表中查找;</p><p>4、重复上述步骤，逐步缩小范围，直到查找成功或子表为空失败时为止。</p><p>要注意两点:<strong>中间值位置求出若为小数，应该向下取整</strong>，即4.5&#x3D;4， 非四舍五入;中间值已经比较过不相等，在划分下一次比较区间时，<strong>无需将中间值位置再纳入下一次比较区间</strong>。</p><p>时间复杂度为O(log2n)。</p><h2 id="哈希-x2F-散列表【考点】"><a href="#哈希-x2F-散列表【考点】" class="headerlink" title="哈希&#x2F;散列表【考点】"></a>哈希&#x2F;散列表【考点】</h2><p>哈希表通过一个以记录的关键字为自变量的函数(称为<strong>哈希函数</strong>)得到该记录的存储地址，所以在哈希表中进行查找操作时，需要用同一哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获得有关信息再判定查找是否成功。</p><p>当多个关键字产生同一个地址时，则产生哈希冲突。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015180624273.png" alt="image-20231015180624273"></p><p>哈希函数产生了冲突的解决方法如下:</p><p>1.<strong>开放定址法</strong>: Hi&#x3D;(H(key)+di) % m，i&#x3D;1, 2….. k&lt;(k&lt;&#x3D;m-1).其中，H(key)为哈希函数; m为哈希表表长; di为增量序列。</p><p>常见的增量序列有以下3种。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015181550933.png" alt="image-20231015181550933"></p><p>2.链地址法。它在查找表的每一个记录中增加一个链域，链域中存放下一个具有相同哈希函数值的记录的存储地址。利用链域，<strong>就把若干个发生冲突的记录链接在一个链表内</strong>。当链域的值为NULL时，表示已没有后继记录了。因此，对于发生冲突时的查找和插入操作就跟线性表一样了。</p><p>3.再哈希法:在同义词发生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生聚集现象，但增加了计算时间。</p><p>4.建立一个公共溢出区。无论由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入到公共溢出区中。</p><h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015181950594.png" alt="image-20231015181950594"></p><p>答案：A</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015182204804.png" alt="image-20231015182204804"></p><p>答案：B</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>◆要注意的是，前提条件是前1-1个元素是有序的，第1个元素依次从第1-1个元素往前比较，直到找到一个比第1个元素值小的元素，而后插入，插入位置及其后的元素依次向后移动。</p><p>◆当给出- -队无序的元素时，首先，应该将第1个元素看做是一个有序的队列，而后从第2个元素起，按插入排序规则，依次与前面的元素进行比较，直到找到一个小于他的值，才插入。示例如下图所示:</p><p>下图中，59依次向前比较，先和68比较，再和57比较,发现57比他小，才插入。初始状态57 68 59 52</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231015182516357.png" alt="image-20231015182516357"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="内部排序算法总结"><a href="#内部排序算法总结" class="headerlink" title="内部排序算法总结"></a>内部排序算法总结</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="tag_share"><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/105.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">11.文老师-软件工程基础知识.md</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">民工的自我修养</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">401</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">163</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">循环队列【考点】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">模式匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">朴素的模式匹配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">KMP算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">1.4.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">广义表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%A6%82%E4%B8%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">树的基本概念如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">二叉树的顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">二叉树的链式存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.5.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.6.</span> <span class="toc-text">反向构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">1.6.7.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.8.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">1.6.9.</span> <span class="toc-text">哈夫曼树【考点】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%B1%82%E6%B3%95"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">哈夫曼树的求法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">1.6.10.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">1.6.11.</span> <span class="toc-text">查找二叉树（排序二叉树）【考点】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">1.6.12.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.7.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">图的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.3.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">图的最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">普里姆算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">克鲁斯卡尔算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">1.7.5.</span> <span class="toc-text">拓扑序列【考点】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">1.7.6.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">折半查找【考点】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C-x2F-%E6%95%A3%E5%88%97%E8%A1%A8%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">2.3.</span> <span class="toc-text">哈希&#x2F;散列表【考点】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-number">2.3.1.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.5.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">3.8.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">内部排序算法总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="9.文老师-数据结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/103.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="9.文老师-数据结构"></a><div class="content"><a class="title" href="/2023/10/14/%E8%BD%AF%E8%80%83/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="9.文老师-数据结构">9.文老师-数据结构</a><time datetime="2023-10-14T12:06:15.000Z" title="发表于 2023-10-14 20:06:15">2023-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="11.文老师-软件工程基础知识.md"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/105.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="11.文老师-软件工程基础知识.md"></a><div class="content"><a class="title" href="/2023/10/14/%E8%BD%AF%E8%80%83/11.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="11.文老师-软件工程基础知识.md">11.文老师-软件工程基础知识.md</a><time datetime="2023-10-14T12:06:15.000Z" title="发表于 2023-10-14 20:06:15">2023-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/13/%E8%BD%AF%E8%80%83/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="9.文老师-程序设计语言基础知识"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/102.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="9.文老师-程序设计语言基础知识"></a><div class="content"><a class="title" href="/2023/10/13/%E8%BD%AF%E8%80%83/9.%E6%96%87%E8%80%81%E5%B8%88-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="9.文老师-程序设计语言基础知识">9.文老师-程序设计语言基础知识</a><time datetime="2023-10-13T12:06:15.000Z" title="发表于 2023-10-13 20:06:15">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/12/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E5%85%AC%E4%B8%9A%E5%8A%A1/1.1%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/" title="经销商采购车辆贷款授信流程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/18.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="经销商采购车辆贷款授信流程"></a><div class="content"><a class="title" href="/2023/10/12/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E5%85%AC%E4%B8%9A%E5%8A%A1/1.1%E7%BB%8F%E9%94%80%E5%95%86%E9%87%87%E8%B4%AD%E8%BD%A6%E8%BE%86%E8%B4%B7%E6%AC%BE%E6%8E%88%E4%BF%A1%E6%B5%81%E7%A8%8B/" title="经销商采购车辆贷款授信流程">经销商采购车辆贷款授信流程</a><time datetime="2023-10-12T07:47:37.000Z" title="发表于 2023-10-12 15:47:37">2023-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/08/%E8%BD%AF%E8%80%83/%E7%BD%91%E7%BB%9C/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="无题"></a><div class="content"><a class="title" href="/2023/10/08/%E8%BD%AF%E8%80%83/%E7%BD%91%E7%BB%9C/" title="无题">无题</a><time datetime="2023-10-08T12:49:24.388Z" title="发表于 2023-10-08 20:49:24">2023-10-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hibiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>