<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>1.文老师-计算机组成与结构 | 民工的自我修养</title><meta name="author" content="民工的自我修养"><meta name="copyright" content="民工的自我修养"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本章知识点会涉及单选题型和案例分析题型，约占 2～8 分，内容偏重于概念知识。 计算机系统基础知识计算机硬件组成【冯诺依曼结构】计算机的基本硬件系统由运算器、控制器、存储器、输入设备、输出设备五大部件组成。    运算器：负责数据的算术运算和逻辑运算即数据的加工处理 控制器：负责对程序规定的控制信息进行分析,控制并协调输入,输出操作或内存访问。   运算器、控制器构成CPU。   输入设备：实现计"><meta property="og:type" content="article"><meta property="og:title" content="1.文老师-计算机组成与结构"><meta property="og:url" content="http://example.com/2023/09/25/%E8%BD%AF%E8%80%83/1.%E6%96%87%E8%80%81%E5%B8%88-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="民工的自我修养"><meta property="og:description" content="本章知识点会涉及单选题型和案例分析题型，约占 2～8 分，内容偏重于概念知识。 计算机系统基础知识计算机硬件组成【冯诺依曼结构】计算机的基本硬件系统由运算器、控制器、存储器、输入设备、输出设备五大部件组成。    运算器：负责数据的算术运算和逻辑运算即数据的加工处理 控制器：负责对程序规定的控制信息进行分析,控制并协调输入,输出操作或内存访问。   运算器、控制器构成CPU。   输入设备：实现计"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/cover/2017GuiDao/67.jpg"><meta property="article:published_time" content="2023-09-25T12:05:15.000Z"><meta property="article:modified_time" content="2023-10-10T04:30:14.660Z"><meta property="article:author" content="民工的自我修养"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/cover/2017GuiDao/67.jpg"><link rel="shortcut icon" href="/cover/2017GuiDao/6.jpg"><link rel="canonical" href="http://example.com/2023/09/25/%E8%BD%AF%E8%80%83/1.%E6%96%87%E8%80%81%E5%B8%88-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:500,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"1.文老师-计算机组成与结构",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-10-10 12:30:14"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="民工的自我修养" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">394</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">163</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/cover/2017GuiDao/67.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">民工的自我修养</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1.文老师-计算机组成与结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-25T12:05:15.000Z" title="发表于 2023-09-25 20:05:15">2023-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-10T04:30:14.660Z" title="更新于 2023-10-10 12:30:14">2023-10-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E8%80%83/">软考</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章知识点会涉及单选题型和案例分析题型，约占 2～8 分，内容偏重于概念知识。</p><h1 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h1><h2 id="计算机硬件组成【冯诺依曼结构】"><a href="#计算机硬件组成【冯诺依曼结构】" class="headerlink" title="计算机硬件组成【冯诺依曼结构】"></a>计算机硬件组成【冯诺依曼结构】</h2><p>计算机的基本硬件系统由<code>运算器、控制器、存储器、输入设备、输出设备</code>五大部件组成。</p><ul><li><strong>运算器</strong>：负责数据的算术运算和逻辑运算即数据的加工处理</li><li><strong>控制器</strong>：负责对程序规定的控制信息进行分析,控制并协调输入,输出操作或内存访问。</li></ul><blockquote><p>运算器、控制器构成CPU。</p></blockquote><ul><li>输入设备：实现计算程序和原始数据的输入。</li><li>输出设备：实现计算结果输出。</li></ul><blockquote><p>输入和输出合称外部设备，简称外设，前者用于输入原始数据和命令，后者用于输出处理结果</p></blockquote><ul><li>存储器是计算机系统的<strong>记忆设备</strong>，分为<strong>内外存储器</strong>：<ul><li>内部存储器：速度高、容量小，一般临时存放程序、数据、中间结果</li><li>外部存储器：速度低、容量大，长期保存程序和数据</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gletthereblight.github.io/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A1%86%E5%9B%BE.jpg" alt="计算机组成框图"></p><h2 id="CPU-的功能和组成"><a href="#CPU-的功能和组成" class="headerlink" title="CPU 的功能和组成"></a>CPU 的功能和组成</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>(1) <strong>程序控制</strong>。CPU通过执行指令来控制程序的执行顺序,这是CPU的重要功能。</p><p>(2)<strong>操作控制</strong>。一条指令功能的实现需要若干操作信号配合来完成，CPU 产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。</p><p>(3)<strong>时间控制</strong>。CPU 对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。</p><p>(4)<strong>数据处理</strong>。CPU 通过对数据进行算术运算【指加减乘除】及逻辑运算【指与或非】等方式进行加工处理,数据加工处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务。</p><p>此外，CPU 还需要<strong>对系统内部和外部的中断(异常)做出响应，进行相应的处理。</strong></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>CPU 主要由<u>运算器、控制器、寄存器组和内部总线</u>等部件组成。</p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>执行所有<strong>算数运算</strong>（加减乘除、附加运算），执行所有<strong>逻辑运算</strong>和逻辑测试（与或非、零值测试、两值比较）。</p><p>组成：</p><ul><li><strong>算数逻辑单元</strong>（<strong>ALU</strong>）：负责处理数据，实现算数运算和逻辑运算</li><li><strong>累加寄存器</strong>（<strong>AC</strong>）：累加器，通用寄存器，为 ALU 提供工作区，**<u>存放运算结果和源操作数</u>**</li></ul><blockquote><p>ALU本身只能存储一个数字，因此需要累加寄存器。</p></blockquote><ul><li><strong>数据缓冲寄存器</strong>（<strong>DR</strong>）：<strong>暂时存放指令或数据字</strong>，将不同时间段内的读写隔离。</li><li><strong>状态条件寄存器</strong>（<strong>PSW</strong>）：存放指令结果条形码内容，分为<strong>状态标志和控制标志</strong>。</li></ul><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>控制 CPU 工作，决定其自动化。包括<strong>指令、时序、总线、中断控制逻辑</strong>。</p><ul><li>指令控制逻辑：完成取指令、分析指令、执行指令操作，分为取指令、指令译码、按指令操作码执行、形成下一条指令地址</li><li>时序控制逻辑：为每条指令按时间顺序提供控制信号</li><li>总线控制逻辑：信息通路的控制电路</li><li>中断控制逻辑：控制中断请求，按照优先级排队</li></ul><p>组成：</p><ul><li>指令寄存器（IR）：<strong>指令从内存储器取出到缓冲寄存器</strong>，在 IR 暂存，在送入 ID</li><li><strong><u>程序计数器（PC）</u><strong>：</strong>寄存信息和计数</strong>，<u>存放指令执行地址</u>，分为顺序执行和转义执行</li><li>地址寄存器（AR）：<strong>保存当前 CPU 所访问内存单元地址</strong></li><li>指令译码器（ID）：<strong>分析指令操作码，分为操作码和地址码</strong></li></ul><p><strong>CPU根据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令CPU分别取取指令或数据。</strong></p><p>程序被加载到内存后开始运行，当 CPU 执行一条指令时，先把它从内存储器取到缓冲寄存器（DR）中，再送入 指令寄存器（IR） 暂存，指令译码器（ID）根据 IR 的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。</p><p>程序计数器（PC）具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分为两种情况，一是顺序执行，二是转移执行。在程序开始执行前，将程序的起始地址送入 PC，该地址在程序加载到内存时确定，因此 PC 的内容即是程序第一条指令的地址。执行指令时，CPU 将自动修改 PC 的内容，以便使其总保持将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对 PC 加 1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移地址得到。</p><p>寄存器组是 CPU 中的一个重要组成部分，它是 CPU 内部的临时存储空间。寄存器既可以用来 存放数据和地址，也可以存放控制信息或 CPU 工作时的状态。在 CPU 中增加寄存器的数量，可以 使 CPU 把执行程序时所需的数据尽可能地放在寄存器中，从而减少访问内存的次数，提高其运行 速度。但是，寄存器的数目也不能太多，除了增加成本外，寄存器地址编码的增加还会增加指令的 长度。CPU 中的寄存器通常分为存放数据的寄存器、存放地址的寄存器、存放控制信息的寄存器、 存放状态信息的寄存器和其他寄存器等类型。</p><p>指令寄存器（IR）用于存放正在执行的指令，指令从内存取出后送入指令寄存器。其<strong>操作码</strong>部 分经指令译码器送到微操作信号发生器，<strong>地址码</strong>部分指明参加运算的操作数的地址形成方式。在指 令执行的过程中，指令寄存器中的内容保持不变。</p><p>状态字寄存器（PSW）用于<strong>保存指令执行完成后产生的条件码</strong>，如运算是否有溢出、结果为 正还是为负、是否有进位等。此外，PSW 还<strong>保存中断和系统工作状态等信息</strong>。</p><p><strong>通用寄存器组</strong>是 CPU 中的一组工作寄存器，运算时用于暂存操作数或地址。在程序中使用通用寄存器可以减少访问内存的次数，提高运算速度。 在汇编语言程序中，程序员可以直接访问通用寄存器以存取数据，可以访问状态字寄存器以获取有关数据处理结果的相关信息，可以通过相对程序计数器进行寻址，但是不能访问指令寄存器。</p><p>例题：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009152946394.png" alt="image-20231009152946394"></p><p>答案：B、C</p><h4 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h4><p>分为专用和通用寄存器：</p><ul><li>专用寄存器：用在运算器和控制器中，作用固定</li><li>通用寄存器：有程序员规定其用途</li></ul><h4 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h4><p>分为数据总线、地址总线、控制总线 3 类。</p><h4 id="多核-CPU"><a href="#多核-CPU" class="headerlink" title="多核 CPU"></a>多核 CPU</h4><p>各种 CPU 核心都具有固定的逻辑结构，一级缓存、二级缓存、执行单元、指令级单元、总线接口等逻辑单元都会有合理的布局。</p><p>Intel 的方案称为 “双芯”，将 AMD 的方案称为 “双核”。</p><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><p>进制的表示：二进制、十六进制，一般在题目中会给出中文说明，如果没给出，注意二进制符号为0b, 一般表示为0b0011,十六进制符号为0x或H,可表示为0x18F或18FH。(十六进制可表示0-15, 其中10-15用A-F来表示)</p><p><strong>R进制整数转十进制</strong>：位权展开法，用R进制数的每一位乘以R的n次方， n是变量，从R进制数的整数最低位开始，依次为0,1,2,3累加。例如有6进制数5043，此时R&#x3D;6, 用6进制数的每一位乘以6的n次方， n是变量,从6进制数的整数最低位开始(5043从低位到高位排列: 3,4,0,5) ，n依次为0,1,2,3，那么最终5043&#x3D;3×6^0+4×6^1 + 0×6^2 + 5×6^3&#x3D; 1107。</p><p>十进制转R进制:十进制整数(除以R倒取余数)，用十进制整数除以R,记录每次所得余数，若商不为0，则继续除以R,直至商为0,而后将所有余数从下至上记录，排列成从左至右顺序，即为转换后的R进制数;</p><p>例:有十进制数200,转换为6进制，此时R&#x3D;6,将200&#x2F;6, 得商为33，余数为2;因为商不等于0，因此再将商33&#x2F;6,得商为5,余数为3;再将5&#x2F;6,得商为0，余数为5;此时商为0，将所有余数从下到上记录，得532。</p><p>m进制转n进制:先将m进制转化为十进制数，再将十进制数转化为n进制数,中间需要通过十进制中转，但下面两种进制间可以<strong>直接转化</strong>:</p><p>◆二进制转八进制:<strong>每三位二进制数按照十进制转换为一位八进制数</strong>,<u>二进制数位个数不是三的倍数，则在前面补0</u> (原则是数值不变)，如二进制数01101有五位，前面补一个0就有六位，为001101,每三位转换为一位八进制数, 001&#x3D;1,101&#x3D;1+4&#x3D;5，也即01101&#x3D;15。</p><p>◆二进制转十六进制:<strong>每四位二进制数转换为一位十六进制数</strong>，二进制数位个数不是四的倍数，则在前面补0,如二进制数101101有六位,前面补两个0就有八位，为0010 1101,每四位转换为一位十六进制数，0010&#x3D;2,1101&#x3D;13&#x3D;D, 也即101101&#x3D;2D.</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>机器数</strong>:各种数值在计算机中表示的形式，其特点是使用二进制计数制,数的符号用0和1表示，小数点则隐含，不占位置。</p><p>机器数<strong>有无符号数</strong>【c语言中unsigned定义】和<strong>带符号数</strong>之分。无符号数表示正数，没有符号位。带符号数最高位为符号位，正数符号位为0，负数符号位为1。</p><p>定点表示法分为纯小数和纯整数两种，其中小数点不占存储位，而是按照以下约定:</p><ul><li><p>纯小数:约定小数点的位置在机器数的最高数值位之前，比如0.0101。</p></li><li><p>纯整数:约定小数点的位置在机器数的最低数值位之后，比如1011.。</p></li></ul><p><strong>真值</strong>:机器数对应的实际数值。</p><p>带符号数有下列<strong>编码方式</strong>，当真值为-45时:</p><p><strong>原码</strong>: 一个数的正常二进制表示，最高位表示符号,数值0的源码有两种形式:+0 (0 000000)和-0 (1 000000)。</p><p>-45对应原码为10101101</p><blockquote><p>计算机默认8位，101101前需要补一个0和一个符号位1</p></blockquote><p><strong>反码</strong>:正数的反码即原码；<strong>负数的反码是在原码的基础上，除符号位外,其他各位【包括补充的0】按位取反。</strong>数值0的反码也有两种形式: +0 (0 000000)，0 (1111111)。-45对应反码为11010010</p><p><strong>补码</strong>:正数的补码即原码;<strong>负数的补码是在原码的基础上,除符号位外,其他各位按位取反，而后末位+1,若有进位则产生进位</strong>【第一位被“挤掉”】。因此数值0的补码<u>只有一种形式+0&#x3D;-0&#x3D; 0 0000000</u>。-45对应补码为11010011</p><blockquote><p>因此补码表示的范围会比反码多一个</p></blockquote><p><strong>移码</strong>:用作<strong>浮点运算的阶码</strong>，无论正数负数，都是将<strong>该原码的<u>补码</u>的首位(符号位)取反得到移码</strong>。-45对应移码为01010011</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009162929494.png" alt="image-20231009162929494"></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xK4y1D7ph?t=2750.9&p=2">https://www.bilibili.com/video/BV1xK4y1D7ph?t=2750.9&amp;p=2</a></p><p>n&#x3D;n-1【数值位】+1【符号位】</p><blockquote><p>小数是把整数左右同除 $2^{n-1}$</p></blockquote><p><strong>浮点数</strong>:表示方法为$N&#x3D;F× 2^{E}$,其中E称为<strong>阶码</strong>，F称为<strong>尾数</strong>;类似于十进制的科学计数法，如85.125 &#x3D; 0.85125×10^2, 二进制如101.011 &#x3D; 0.101011×2^3。</p><p>在浮点数的表示中，<strong>阶码为带符号的纯整数，尾数为带符号的纯小数</strong>，要注意符号占最高位(正数0负数1)，其表示格式如下:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009163905258.png" alt="image-20231009163905258"></p><p>很明显，与科学计数法类似，-一个浮点数的表示方法不是唯一的,<strong>浮点数所能表示的数值范围由阶码确定，所表示的数值精度由尾数确定</strong>。</p><p>尾数的表示采用规格化方法，也即带符号尾数的补码必须为1.0xxx (负数)或者0.1xxx (正数) , 其中x可为0或1.</p><p>浮点数的运算:对阶(使两个数的阶码相同，小阶向大阶看齐，较小阶码增加几位，尾数就右移几位)</p><p>尾数计算(相加，若是减运算,则加负数)</p><p>结果规格化(即尾数表示规格化，带符号尾数转换为:.0xx或0.1xxx)。</p><p>例题：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009164541184.png" alt="image-20231009164541184"></p><p>解析:这里主要是考察补码的表示，补码中无正负之分，符号位作为数值参与计数。2X的补码90H转换为二进制为1001 0000，可知最高位符号位为1,也就是负数,按照负数转化为补码规则(先取反后加1)，求真值应该逆向转化即对补码先-1再取反，得出2x的源码为1111 0000,在真值中区分正负，最高位作为符号独立显示，不参与计数(与补码的区别)，因此为1110000&#x3D;-112,X就是-56.</p><p>例题：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009164602046.png" alt="image-20231009164602046"></p><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><p><strong>码距</strong>: 就单个编码A: 00而言,其码距为1，因为其只需要改变一位就变成另一个编码。<strong>在两个编码中，从A码到B码转换所需要改变的位数称为码距</strong>，如A: 00要转换为B: 11, 码距为2。一般来说，码距越大，越利于纠错和检错。</p><blockquote><p>通常只考虑两个编码的情况。</p></blockquote><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>在编码中<strong>增加1位校验位来使编码中1的个数为奇数(奇校验)或者偶数(偶校验)，从而使<u>码距</u>变为2</strong>【本来出错的一位+校验码改变的一位】。例如:</p><ul><li><p>奇校验:编码中，<strong>含有奇数个1</strong>,发送给接收方，接收方收到后，会计算收到的编码有多少个1，如果是奇数个，则无误，是偶数个，则有误。</p></li><li><p>偶校验同理，只是编码中有偶数个1，由上述，<strong>奇偶校验只能检1位错，并且无法纠错</strong>。</p></li></ul><h3 id="循环冗余校验码（CRC）"><a href="#循环冗余校验码（CRC）" class="headerlink" title="循环冗余校验码（CRC）"></a><strong>循环冗余校验码</strong>（CRC）</h3><p><strong>只能检错，不能纠错</strong>。使用CRC编码，需要**先约定一个生成多项式G(x)**。 生成多项式的最高位和最低位必须是1。假设原始信息有m位，则对应多项式M(x)。生成校验码思想就是在原始信息位后追加若干校验位，使得追加的信息能被G(x)整除。接收方接收到带校验位的信息，然后用G(x)整除。余数为0，则没有错误;反之则发生错误。</p><p>例:假设原始信息串为10110, CRC 的生成多项式为G(x)&#x3D;x^4+x+1,求CRC校验码。</p><p>(1)在原始信息位后面添0，<strong>假设生成多项式的阶为r，则在原始信息位后添加r个0</strong>，本题中，G(x)阶为4，则在原始信息串后加4个0，得到的新串为101100000,作为被除数。</p><p>(2)<strong>由多项式得到除数</strong>，多项中<strong>x的幂指数存在的位置1,不存在的位置0</strong>。本题中，x的幂指数为0,1,4的变量都存在,而幂指数为2,3的不存在，因此得到串10011。</p><p>(3)<strong>生成CRC校验码</strong>，将<strong>前两步得出的被除数和除数进行模2【<u>异或运算</u>】除法运算</strong>(即<u>不进位也不借位的除法运算</u>)。除法过程如下图所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009171923634.png" alt="image-20231009171923634"></p><p><strong>得到余数1111</strong>。</p><p>注意:<strong>余数不足r,则余数左边用若千个0补齐。</strong>如求得余数为11, r&#x3D;4, 则补两个0得到0011。</p><p>(4)生成最终发送信息串，将余数添加到原始信息后。上例中， 原始信息为10110，添加余数1111后，结果为10110 1111。发送方将此数据发送给接收方。</p><p>(5)接收方进行校验。接收方的CRC校验过程与生成过程类似，接收方接收了带校验和的帧后，<strong>用多项式G(x)来除</strong>。<strong>余数为0，则表示信息无错</strong>;否则要求发送方进行重传。</p><p>注意:收发信息双方需使用相同的生成多项式。</p><p>例题：循环冗余校验码(Cyclic Redundancy Check，CRC)是数据通信领域中最常用的一种差错校验码,该校验方法中，使用多项式除法(模2除法)运算后的余数为校验字段。若数据信息为n位，则将其左移k位后，被长度为k+1位的生成多项式相除，所得的k位余数即构成k个校验位，构成n+k位编码。若数据信息为1100，生成多项式为X3+X+1 (即1011) ，则CRC编码是(A )。</p><p>A.1100010</p><p>B.1011010</p><p>C.1100011</p><p>D.1011110</p><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a><strong>海明码</strong></h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xK4y1D7ph?t=1251.0&p=3">https://www.bilibili.com/video/BV1xK4y1D7ph?t=1251.0&amp;p=3</a></p><p>本质也是利用奇偶性来<strong>检错和纠错</strong>的检验方法，构成方法是在数据位之间的确定位置上插入k个校验位，通过扩大码距实现检错和纠错。设数据位是n位，校验位是k位,则n和k必须满足以下关系: <strong>2^k-1&gt;&#x3D;n+k</strong>。</p><p>例:求信息1011的海明码</p><p>1.<strong>校验位的位数和具体的数据位的位数之间的关系</strong></p><p><strong>所有位都编号，从最低位编号，从1开始递增，校验位处于2的n (n&#x3D;0 1…….)次方中，即处于第1,2,4,8,16,32, …..</strong> 上,其余位才能填充真正的数据位，若信息数据为1011,则可知，第1,2,4位为校验位,第3,5,6,7位为数据位, 用来从低位开始存放1011,得出信息位和校验位分布如下:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009173159404.png" alt="image-20231009173159404"></p><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h2><p>按处理机的数量进行分类:<strong>单处理系统</strong>(一个处理单元和其他设备集成)、<strong>并行处理系统</strong>(两个以上的处理机互联)、 分布式处理系统(物理上远距离且松耦合的多计算机系统)。</p><p><strong><u>Flynn分类法</u></strong>:分类有两个因素，即<strong>指令流</strong>和<strong>数据流</strong>，指令流由控制部分处理，每一个控制部分处理一条指令流，多指令流就有多个控制部分;数据流由处理器来处理，每一个处理器处理一条数据流，<strong>多数据流就有多个处理器</strong>;至于主存模块，是用来存储的,存储指令流或者数据流，因此，无论是多指令流还是多数据流，都需要多个主存模块来存储，对于主存模块，指令和数据都一样。</p><p>依据计算机特性，是由指令来控制数据的传输，因此，<strong>一条指令可以控制一条或多条数据流，但一条数据流不能被多条指令控制，否则会出错</strong>【有多个指令，但只有一个处理器】，就如同上级命令太多还互相冲突，不知道该执行哪个，因此多指令单数据<strong>MISD不可能</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009182613028.png" alt="image-20231009182613028"></p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>计算机指令的组成: 一条指令由<strong>操作码和操作数</strong>两部分组成,操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。在计算机中，操作要求和操作数地址都由二进制数码表示，分别称作操作码和地址码，整条指令以二进制编码的形式存放在存储器中。</p><p>计算机指令执行过程:<strong>取指令–分析指令– 执行指令</strong>三个步骤， 首先将程序计数器PC中的指令地址取出，送入地址总线，CPU依据指令地址去内存中取出指令内容存入指令寄存器IR;而后由指令译码器进行分析，分析指令操作码;最后执行指令，取出指令执行所需的源操作数。</p><h3 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a><strong>指令寻址方式</strong></h3><p><strong>顺序</strong>寻址方式:当执行一段程序时， 是<strong>一条指令接着一条指令地顺序执行</strong>。</p><p><strong>跳跃</strong>寻址方式:指下一条指令的地址码<strong>不是由程序计数器给出，而是由本条指令直接给出</strong>【汇编语言中的跳转指令】。程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。</p><h3 id="指令操作数的寻址方式"><a href="#指令操作数的寻址方式" class="headerlink" title="指令操作数的寻址方式"></a><strong>指令操作数的寻址方式</strong></h3><p><strong>立即寻址方式</strong>:<strong>指令的地址码字段指出的不是地址，而是操作数本身</strong>。</p><p><strong>直接寻址方式</strong>:在指令的地址字段中直接指出操作数在<strong>主存</strong>中的地址。</p><p><strong>间接寻址方式</strong>:指令地址码字段所指向的存储单元中存储的是操作数的地址【地址码中存放的是操作数的地址】。</p><p><strong>寄存器寻址方式</strong>:指令中的地址码是寄存器的编号。</p><p>基址寻址方式:将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。</p><p>变址寻址方式:变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。</p><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p><strong>CISC是复杂指令系统</strong>，兼容性强，指令繁多、长度可变，由<u>微程序</u>实现; <strong>RISC是精简指令系统</strong>，指令少,使用频率接近，主要依靠硬件实现(<u>通用寄存器、硬布线逻辑控制</u>)。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009183638224.png" alt="image-20231009183638224"></p><p><strong>例题1</strong>：Flynn分类法根据计算机在执行程序的过程中( )的不同组合,将计算机分为4类。当前主流的多 核计算机属于( D)计算机。 A.指令流和数据流 B.数据流和控制流 C.指令流和控制流 D.数据流和总线带宽</p><p>A.SISD B.SIMD C.MISD D.MIMD</p><p><strong>例题2</strong>：以下关于复杂指令集计算机(Complex Instruction Set Computer,ISC)的叙述中，正确的是( D)。</p><p>A.只设置使用频度高的一些简单指令，不同指令执行时间差别很小 B.CPU中设置大量寄存器，利用率低 C.常采用执行速度更快的组合逻辑实现控制器 D.指令长度不固定，指令格式和寻址方式多</p><h3 id="指令流水处理"><a href="#指令流水处理" class="headerlink" title="指令流水处理"></a>指令流水处理</h3><p>指令流水线原理:<strong>将指令分成不同段，每段由不同的部分去处理</strong>，因此可以产生<strong>叠加的效果</strong>，所有的部件去处理指令的不同段</p><p>RISC中的流水线技术:</p><p>(1)<strong>超流水线(Super Pipe Line)技术</strong>。它通过细化流水【把分为3段的分为6段】、增加级数和提高主频，使得在每个机器周期内能完成一个甚至两个浮点操作。其实质是<strong>以时间换取空间</strong>。</p><p>(2)<strong>超标量(Super Scalar)技术</strong>。它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却有更小的CPI。其实质是<strong>以空间换取时间</strong>。</p><p>(3)<strong>超长指令字</strong>(Very Long Instruction Word, VLIW) 技术。VLIW和超标量都是20世纪80年代出现的概念，其共同点是要同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，VLIW 则充分发挥<strong>软件的作用</strong>，而使硬件简化,性能提高。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009184041782.png" alt="image-20231009184041782"></p><h4 id="流水线时间计算"><a href="#流水线时间计算" class="headerlink" title="流水线时间计算"></a>流水线时间计算</h4><p><strong>流水线周期</strong>:指令分成不同执行段,其中<u>执行时间最长的段</u>为流水线周期。</p><p><strong>流水线执行时间</strong>: 1条指令总执行时间+ (总指令条数-1) *流水线周期。</p><p><strong>流水线吞吐率</strong>计算:吞吐率即单位时间内执行的指令条数。公式:指令条数&#x2F;<strong>流水线执行时间</strong>。</p><p><strong>流水线的加速比</strong>计算:加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高，公式:不使用流水线执行时间&#x2F;使用流水线执行时间。</p><p><strong>例题1</strong>：流水线的吞吐率是指流水线在单位时间里所完成的任务数或输出的结果数。设某流水线有5段,有1段的时间为2ns，另外4段的每段时间为1ns,利用此流水线完成100个任务的吞吐率约为( B)个&#x2F;s。</p><p>A.500x 10^6 B.490x 10^6 C.250x 10^6 D.167x10^6</p><p><strong>例题2</strong>假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为15us，由缓冲区送至用户区的时间是5us，在用户区内系统对每块数据的处理时间为1us,若用户需要将大小为10个磁盘块的Docl文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为(D)us;采用双缓冲区需要花费的时间为(C) us。</p><p>A.150;B.151;C.156;D.201</p><p>A.150;B.151;C.156;D.201</p><blockquote><p>如果是一个缓冲区，那么第一和第二个任务不能并行。对于但缓冲区而言，第一、第二段应该合并为一段。</p></blockquote><p><strong>例题2</strong>流水线技术是通过并行硬件来提高系统性能的常用方法。对于一个k段流水线，假设其各段的执行时间均相等(设为t) ，输入到流水线中的任务是连续的理想情况下，完成n个连续任务需要的总时间为(B )。若某流水线浮点加法运算器分为5段,所需要的时间分别是6ns、7ns、 8ns、 9ns 和6ns，则其最大加速比为(A )。 A.nkt；B.{k+n- 1)t；C.(n- k)kt；D.(k+n+1)t A.4；B.5；C.6；D.7</p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="高速缓存Cache"><a href="#高速缓存Cache" class="headerlink" title="高速缓存Cache"></a>高速缓存Cache</h2><p>计算机采用分级存储体系的主要目的是为了<strong>解决存储容量、成本和速度之间的矛盾问题</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gletthereblight.github.io/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="存储器层次结构"></p><p>两级存储: Cache-主存、 主存辅存(虚拟存储体系)。</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p><strong>局部性原理</strong>:总的来说，在CPU运行时, 所访问的数据会趋向于一个较小的局部空间地址内，包括下面两个方面:</p><p>时间局部性原理:如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即在<strong>相邻的时间里会访问同一个数据项</strong>。</p><p>空间局部性原理:在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，即<strong>相邻的空间地址会被连续访问</strong>。</p><p>高速缓存Cache用来存储当前<strong>最活跃的程序和数据，直接与CPU交互，位于CPU和主存之间</strong>，容量小，速度为内存的5-10倍，由半导体材料构成。其<strong>内容是主存内存的副本拷贝</strong>，对于程序员来说是<strong>透明</strong>的。</p><p>Cache由<strong>控制部分和存储器</strong>组成，存储器存储数据，控制部分判断CPU要访问的数据是否在Cache中，在则<strong>命中</strong>，不在则依据一定的算法从主存中替换。</p><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a><strong>地址映射</strong></h3><p>在CPU工作时，<strong>送出的是主存单元的地址，而应从Cache存储器中读&#x2F;写信息</strong>。这就需要将主存地址转换为Cache存储器地址，这种地址的转换称为地址映像，<strong>由硬件自动完成映射</strong>，分为下列三种方法:</p><ul><li>直接映像:<strong>将Cache存储器等分成块，主存也等分成块并编号</strong>。主存中的块与Cache中的块的对应关系是固定的，也即<strong>二者块号相同才能命中</strong>。地址变换简单但不灵活，容易造成资源浪费。(如图所示)</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009214247806.png" alt="image-20231009214247806"></p><ul><li>全相联映像:同样都等分成块并编号。<strong>主存中任意一块都与Cache中任意一块对应。</strong> 因此可以<strong>随意调入Cache任意位置</strong>，但地址变换复杂，速度较慢。因为主存可以随意调入Cache任意块，只有当Cache满了才会发生块冲突,是**<u>最不容易发生块冲突的映像方式</u>**。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009214509559.png" alt="image-20231009214509559"></p><ul><li>组组相连映像:前面两种方式的结合,将Cache存储器先分块再分组，主存也同样先分块再分组，组间采用直接映像，即<strong>主存中组号与Cache中组号相同的组才能命中</strong>，但是组内全相联映像，也即组号相同的两个组内的所有块可以任意调换。</li></ul><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p><strong><u>替换算法</u><strong>的目标就是</strong>使Cache获得尽可能高的命中率</strong>。常用算法有如下几种。</p><p><strong>(1)随机替换算法</strong>。就是用随机数发生器产生一个要替换的块号,将该块替换出去。</p><p><strong>(2)先进先出算法</strong>。就是将最先进入Cache的信息块替换出去。</p><p>**(3)<u>近期最少使用算法</u>**。这种方法是将近期最少使用的Cache中的信息块替换出去。</p><p><strong>(4)优化替换算法</strong>。这种方法必须先执行一次程序,统计Cache的替换情况。有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换。</p><h3 id="命中率及平均时间"><a href="#命中率及平均时间" class="headerlink" title="命中率及平均时间"></a>命中率及平均时间</h3><p>Cache有一个命中率的概念，即当CPU所访问的数据在Cache中时，命中，直接从Cache中读取数据，设读取一次Cache时间为1ns, 若CPU访问的数据不在Cache中,则需要从内存中读取，设读取一次内存的时间为1000ns, 若在CPU多次读取数据过程中，有90%命中Cache, 则CPU读取一次的平均时间为(90%×1 + 10%×1000)ns</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009215212430.png" alt="image-20231009215212430"></p><p>例题1：</p><p>按照Cache地址映像的块冲突概率,从高到低排列的是(B )。</p><p>A.全相联映像&gt;直接映像→组相联映像</p><p>B.直接映像→组相联映像&gt;全相联映像</p><p>C.组相联映像&gt;全相联映像: &gt;直接映像</p><p>D.直接映像&gt;全相联映像:→组相联映像</p><p>例题2：</p><p>以吓关于Cache与主存间地址映射的叙述中，正确的是(D )。</p><p>A.操作系统负责管理Cache与主存之间的地址映射</p><p>B.程序员需要通过编程来处理Cache与主存之间的地址映射</p><p>C.应用软件对 ache与主存之间的地址映射进行调度</p><p>D:由硬件自动完成Cache与主存之间的地址映射</p><p><strong>基本概念</strong>: K、M、G是数量单位,在存储器里相差1024倍。b, B是存储单位，1B【字节】&#x3D; 8b【比特，或位】 .</p><p>真题:地址编号从80000H到FFFFH且按<strong>字节编址</strong>的内存容量为(5 )KB，若用16K* 4bit的存储器芯片构成该内存,共需()片</p><p>A.128B.256C.512D.1024 A.8.B.16C.32D.64</p><blockquote><p>解析:首先计算出地址段包含的存储空间数，为BFFFFH -80000H+1&#x3D;40000H,按字节编制，即-一个存储空间占-一个字节,共40000H个字节，转换为十进制即256KB;该存储芯片总容量为16K*0.5B&#x3D;8KB，因此共需256&#x2F;8&#x3D;32片该芯片才够存储。</p></blockquote><h3 id="磁盘结构和参数【考点】"><a href="#磁盘结构和参数【考点】" class="headerlink" title="磁盘结构和参数【考点】"></a>磁盘结构和参数【考点】</h3><p>磁盘有<strong>正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道,每个同心圆又被划分为多个扇区，数据就被存放在一个个扇区【数据存放的最小单位】中</strong>。</p><p>磁头首先要寻找到对应的磁道，然后等待磁盘进行周期旋转【硬盘的转速】，旋转到指定的扇区，才能读取到对应的数据，因此，会产生寻道时间和等待时间。公式为:</p><p>存取时间&#x3D;寻道时间+等待时间(平均定位时间+转动延迟)。</p><p>注意:寻道时间是指磁头移动到磁道所需的时间;等待时间为等待读写的扇区转到磁头下方所用的时间。</p><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhahu/p/12333689.html">https://www.cnblogs.com/zhahu/p/12333689.html</a></p><p>之前已经说过，,磁盘数据的读取时间分为寻道时间+旋转时间，也即先找到对应的磁道，而后再旋转到对应的扇区才能读取数据，其中寻道时间耗时最长,需要重点调度，有如下调度算法:</p><p><strong>先来先服务</strong>FCFS:根据进程请求访问磁盘的先后顺序进行调度。</p><p><strong>最短寻道时间优先SSTF</strong>:请求访问的磁道与当前磁道最近的进程优先调度,使得每次的寻道时间最短。会<strong>产生“饥饿”现象</strong>，即远处进程可能永远无法访问。</p><p><strong>扫描算法SCAN</strong>【考点】:又称“电梯算法”，磁头在磁盘上<strong>双向移动</strong>，其会选择离磁头当前所在磁道最近的请求访问的磁道，并且与磁头移动方向一致，磁头永远都是<u>从里向外或者从外向里一直移动完才掉头</u>，与电梯类似。</p><p>单向扫描调度算法CSCAN:与SCAN不同的是， 其只做单向移动，即只能从里向外或者从外向里。</p><p>例题：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009222540636.png" alt="image-20231009222540636"></p><p>11个物理块-&gt;11个扇区；</p><p>C,B</p><p>优化分布如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009223714908.png" alt="image-20231009223714908"></p><p>例题2：D</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009223748009.png" alt="image-20231009223748009"></p><h1 id="输入输出技术"><a href="#输入输出技术" class="headerlink" title="输入输出技术"></a>输入输出技术</h1><h2 id="编址方法"><a href="#编址方法" class="headerlink" title="编址方法"></a>编址方法</h2><p>计算机系统中存在多种内存与接口地址的编址方法，常见的是下面两种:</p><p><strong>1)内存与接口地址独立编址方法</strong></p><p>内存地址和接C地址是<strong>完全独立的两个地址空间</strong>。<strong>访问数据时所使用的指令也完全不同</strong>，用于接口的指令只用于接口的读&#x2F;写，其余的指令全都是用于内存的。因此，在编程序或读程序时很易使用和辨认。这种编址方法的<strong>缺点是用于接口的指令太少功能太弱</strong>。</p><p><strong>2)内存与接口地址统一编址方法</strong></p><p>内存地址和接口地址统一<strong>在一个公共的地址空间里</strong>， 即内存单元和接口共用地址空间。<strong>优点是原则上用于内存的指令全都可以用于接口，这就大大地增强了对接口的操作功能</strong>，而且在指令上也不再区分内存或接口指令。该编<strong>址方法的缺点就在于整个地址空间被分成两部分</strong>,其中-分分配给接口使用，剩余的为内存所用，这经常会导致内存地址不连续。</p><h2 id="计算机和外设间的数据交互方式-考点"><a href="#计算机和外设间的数据交互方式-考点" class="headerlink" title="计算机和外设间的数据交互方式[考点]"></a>计算机和外设间的数据交互方式[考点]</h2><h3 id="程序控制-查询-x2F-直接控制方式"><a href="#程序控制-查询-x2F-直接控制方式" class="headerlink" title="程序控制(查询)&#x2F;直接控制方式"></a>程序控制(查询)&#x2F;直接控制方式</h3><p>CPU主动查询外设是否完成数据传输，<strong>效率极低</strong>。</p><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p>外设完成数据传输后，<strong>向CPU发送中断</strong>，等待CPU处理数据,效率相对较高。</p><p><strong>中断响应时间</strong>指的是从发出中断请求到开始进入中断处理程序;<strong>中断处理时间</strong>指的是从中断处理开始到中断处理结束。<strong>中断向量</strong>提供中断服务程序的入口地址。多级中断嵌套，使用堆栈来保护断点和现场。</p><h3 id="DMA方式-直接主存存取"><a href="#DMA方式-直接主存存取" class="headerlink" title="DMA方式(直接主存存取)"></a>DMA方式(直接主存存取)</h3><p>CPU<strong>只需完成必要的初始化等操作，数据传输的整个过程都由DMA控制器来完成，在主存和外设之间建立直接的数据通路</strong>,效率很高。</p><blockquote><p>把数据直接读到内存里，CPU向内存读取数据。不需要CPU执行程序指令来传送数据。</p></blockquote><p>在**<u>一个总线周期结束后，CPU会响应DMA请求开始读取数据; CPU响应程序中断方式请求是在一条指令执行结束时。</u>**</p><blockquote><p>时钟频率的倒数就是时钟周期，是CPU最小的时间单位。</p></blockquote><h4 id="中断的流程"><a href="#中断的流程" class="headerlink" title="中断的流程"></a>中断的流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009225112418.png" alt="image-20231009225112418"></p><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><p>总线(Bus) ，是指<strong>计算机设备和设备之间传输信息的公共数据通道</strong>。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上。</p><p>从广义上讲，任何连接两个以上电子元器件的导线都可以称为总线，通常分为以下三类:</p><p><strong>内部总线</strong>:内部芯片级别的总线,芯片与处理器之间通信的总线。</p><p><strong>系统总线</strong>:是<strong>板级总线</strong>，用于计算机内各部分之间的连接,具体分为<strong>数据总线(并行数据传输位数)、地址总线(系统可管理的内存空间的大小)、控制总线(传送控制命令)<strong>。代表的</strong>有ISA总线、EISA总线、 PCI总线【并行】</strong>。</p><p><strong>外部总线</strong>:设备一级的总线， 微机和外部设备的总线。代表的有RS232 (串行总线)、SCSI (并行总线)、USB (通用串行总线，即插即用，支持热插拔)。</p><p><strong>例题</strong>：</p><p>计算机系统中常用的输入&#x2F;输出控制方式有无条件传送、中断、程序查询和DMA方式等。当采用(D)方式时，不需要CPU执行程序指令来传送数据。</p><p>A.中断 B.程序查询 C.无条件传送 D.DMA</p><p>以下关于总线的说法中，正确的是(C )。 A.串行总线适合近距离高速数据传输，但线间串扰会导致速率受限 B.并行总线适合长距离数据传输，易提高通信时钟频率来实现高速数据传输 C.单总线结构在一个总线上适应不同种类的设备，设计复杂导致性能降低 D.半双工总线只能在一个方向上传输信息</p><blockquote><p>串行：一次只能1bit、1bit传输</p><p>并行：一次多传输多bit，但只适合短距离传输，因为成本高</p></blockquote><h1 id="计算机可靠性"><a href="#计算机可靠性" class="headerlink" title="计算机可靠性"></a>计算机可靠性</h1><h2 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h2><p>平均无故障时间MTTF&#x3D;1&#x2F;失效率。</p><p>平均故障修复时间MTTR&#x3D;1&#x2F;修复率。</p><blockquote><p>出现故障后需要花多久时间修复。</p></blockquote><p>平均故障间隔时间MTBF&#x3D;MTTF+MTTR。</p><p>系统可用性&#x3D;MTTF&#x2F;(MTTF+MTTR)*100%。</p><h2 id="串并联系统可靠性【考点】"><a href="#串并联系统可靠性【考点】" class="headerlink" title="串并联系统可靠性【考点】"></a>串并联系统可靠性【考点】</h2><p>无论什么系统，都是由多个设备组成的，协同工作，而这多个设备的组合方式可以是串联、并联，也可以是混合模式，假设每个设备的可靠性为R1, R….R..则不同的系统的可靠性公式如下:</p><p><strong>串联系统</strong>，一个设备不可靠，整个系统崩溃，整个系统可靠性R&#x3D;R1 <em>R2</em> .. * Rn。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009232113413.png" alt="image-20231009232113413"></p><p><strong>并联系统</strong>，所有设备都不可靠,整个系统才崩溃，整个系统可靠性R&#x3D;1-(1-R1)*(1-R2) * …(1-Rn)。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009232314450.png" alt="image-20231009232314450"></p><p><strong>N模冗余系统</strong>【不考】: N模冗余系统由N个(N&#x3D;2n + 1)相同的子系统和一个表决器组成，表决器把N个子系统中占多数相同结果的输出作为输出系统的输出，如图所示。在N个子系统中，只要有<strong>n+1个或n+ 1个以上子系统能正常工作，系统就能正常工作</strong>【一半以上的设备正常工作即可】，输出正确的结果。</p><p>例题：（A）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../pic/1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/image-20231009232620476.png" alt="image-20231009232620476"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="tag_share"><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/25/%E8%BD%AF%E8%80%83/2.%E6%96%87%E8%80%81%E5%B8%88-%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/98.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2.文老师-数据库</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/24/%E5%B7%A5%E4%BD%9C/%E4%B8%9C%E5%8C%97%E5%8C%BA%E5%AE%9E%E4%B9%A0%E6%9C%9F%E9%97%B4/2023-09-23%20%E6%9C%88%E5%BA%A6%E4%BC%9A%E8%AE%AE/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">民工的自我修养</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">394</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">163</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">计算机系统基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%E3%80%90%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E3%80%91"><span class="toc-number">1.1.</span> <span class="toc-text">计算机硬件组成【冯诺依曼结构】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">CPU 的功能和组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">运算器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">寄存器组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">内部总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8-CPU"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">多核 CPU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.3.</span> <span class="toc-text">数据表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">进制的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">校验码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">奇偶校验码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88CRC%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">循环冗余校验码（CRC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E7%A0%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">海明码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">计算机体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">计算机分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.</span> <span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">指令寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">指令操作数的寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.3.</span> <span class="toc-text">指令分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E5%A4%84%E7%90%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">指令流水处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">流水线时间计算</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98Cache"><span class="toc-number">3.1.</span> <span class="toc-text">高速缓存Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">替换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E7%8E%87%E5%8F%8A%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4"><span class="toc-number">3.1.4.</span> <span class="toc-text">命中率及平均时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%82%E6%95%B0%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">3.1.5.</span> <span class="toc-text">磁盘结构和参数【考点】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">磁盘调度算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">输入输出技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%9D%80%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">编址方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E5%A4%96%E8%AE%BE%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F-%E8%80%83%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">计算机和外设间的数据交互方式[考点]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6-%E6%9F%A5%E8%AF%A2-x2F-%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">程序控制(查询)&#x2F;直接控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">程序中断方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E6%96%B9%E5%BC%8F-%E7%9B%B4%E6%8E%A5%E4%B8%BB%E5%AD%98%E5%AD%98%E5%8F%96"><span class="toc-number">4.2.3.</span> <span class="toc-text">DMA方式(直接主存存取)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">中断的流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">总线结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">计算机可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.</span> <span class="toc-text">可靠性指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%B9%B6%E8%81%94%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-number">6.2.</span> <span class="toc-text">串并联系统可靠性【考点】</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/08/%E8%BD%AF%E8%80%83/%E7%BD%91%E7%BB%9C/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="无题"></a><div class="content"><a class="title" href="/2023/10/08/%E8%BD%AF%E8%80%83/%E7%BD%91%E7%BB%9C/" title="无题">无题</a><time datetime="2023-10-08T12:49:24.388Z" title="发表于 2023-10-08 20:49:24">2023-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.4%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E5%85%B3%E4%BA%8E%E8%B0%83%E6%95%B4%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E6%9C%89%E5%85%B3%E6%94%BF%E7%AD%96%E7%9A%84%E9%80%9A%E7%9F%A5/" title="关于调整汽车贷款有关政策的通知"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/12.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="关于调整汽车贷款有关政策的通知"></a><div class="content"><a class="title" href="/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.4%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E5%85%B3%E4%BA%8E%E8%B0%83%E6%95%B4%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E6%9C%89%E5%85%B3%E6%94%BF%E7%AD%96%E7%9A%84%E9%80%9A%E7%9F%A5/" title="关于调整汽车贷款有关政策的通知">关于调整汽车贷款有关政策的通知</a><time datetime="2023-09-29T12:06:15.000Z" title="发表于 2023-09-29 20:06:15">2023-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.3%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%B8%AA%E4%BA%BA%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E6%9A%82%E8%A1%8C%E5%8A%9E%E6%B3%95%20/" title="个人贷款管理暂行办法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/12.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="个人贷款管理暂行办法"></a><div class="content"><a class="title" href="/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.3%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%B8%AA%E4%BA%BA%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E6%9A%82%E8%A1%8C%E5%8A%9E%E6%B3%95%20/" title="个人贷款管理暂行办法">个人贷款管理暂行办法</a><time datetime="2023-09-29T12:06:15.000Z" title="发表于 2023-09-29 20:06:15">2023-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.2%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/" title="汽车贷款管理办法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="汽车贷款管理办法"></a><div class="content"><a class="title" href="/2023/09/29/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/4.2%E6%B1%BD%E8%BD%A6%E9%87%91%E8%9E%8D%E7%B1%BB%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E6%B1%BD%E8%BD%A6%E8%B4%B7%E6%AC%BE%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/" title="汽车贷款管理办法">汽车贷款管理办法</a><time datetime="2023-09-29T12:06:15.000Z" title="发表于 2023-09-29 20:06:15">2023-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/29/%E8%BD%AF%E8%80%83/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="3.文老师-操作系统.md"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/68.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3.文老师-操作系统.md"></a><div class="content"><a class="title" href="/2023/09/29/%E8%BD%AF%E8%80%83/3.%E6%96%87%E8%80%81%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="3.文老师-操作系统.md">3.文老师-操作系统.md</a><time datetime="2023-09-29T12:05:15.000Z" title="发表于 2023-09-29 20:05:15">2023-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hibiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>