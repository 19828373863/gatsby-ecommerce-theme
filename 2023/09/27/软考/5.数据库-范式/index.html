<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>4.数据库-范式 | 民工的自我修养</title><meta name="author" content="民工的自我修养"><meta name="copyright" content="民工的自我修养"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇文章来自于我的一个回答，内容进行了少量调整，并补充了几个习题。为简单起见，并不非常严谨地区分 “关系” 和 “数据表” 的概念。 首先要明白”范式（NF）”是什么意思。按照经典教材——王珊的《数据库系统概论》中的定义，范式是 “符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。就像"><meta property="og:type" content="article"><meta property="og:title" content="4.数据库-范式"><meta property="og:url" content="http://example.com/2023/09/27/%E8%BD%AF%E8%80%83/5.%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/"><meta property="og:site_name" content="民工的自我修养"><meta property="og:description" content="这篇文章来自于我的一个回答，内容进行了少量调整，并补充了几个习题。为简单起见，并不非常严谨地区分 “关系” 和 “数据表” 的概念。 首先要明白”范式（NF）”是什么意思。按照经典教材——王珊的《数据库系统概论》中的定义，范式是 “符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。就像"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/cover/2017GuiDao/58.jpg"><meta property="article:published_time" content="2023-09-27T12:06:15.000Z"><meta property="article:modified_time" content="2023-10-07T13:07:25.219Z"><meta property="article:author" content="民工的自我修养"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/cover/2017GuiDao/58.jpg"><link rel="shortcut icon" href="/cover/2017GuiDao/6.jpg"><link rel="canonical" href="http://example.com/2023/09/27/%E8%BD%AF%E8%80%83/5.%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:500,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!0,percent:{toc:!0,rightside:!0}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"4.数据库-范式",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-10-07 21:07:25"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="民工的自我修养" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">600</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">234</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/cover/2017GuiDao/58.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">民工的自我修养</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">4.数据库-范式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-27T12:06:15.000Z" title="发表于 2023-09-27 20:06:15">2023-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-07T13:07:25.219Z" title="更新于 2023-10-07 21:07:25">2023-10-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E8%80%83/">软考</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇文章来自于我的一个回答，内容进行了少量调整，并补充了几个习题。为简单起见，并不非常严谨地区分 “关系” 和 “数据表” 的概念。</p><p>首先要明白”范式（NF）”是什么意思。按照经典教材——王珊的《数据库系统概论》中的定义，范式是 “符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为<strong>一张数据表的表结构所符合的某种设计标准的级别</strong>。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，如符合2NF的关系模式，必定符合1NF。</p><p>接下来就对每一级范式进行一下解释，首先是<strong>第一范式（1NF）。</strong></p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>符合1NF的关系（你可以把“关系”理解为数据表。此外还有一个“关系模式”的概念。“关系”和“关系模式”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。<strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分</strong>。表1所示的情况，就不符合1NF的要求。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/89507a1682f28fd2dde066cf94d77b4a_r.jpg" alt="表1"></p><p>实际上，<strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为表2的形式：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/e00979f6836921f80083ac0c02262e45_r.jpg" alt="表2"></p><p>但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于<strong>表3</strong>中的设计：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/dfdc86b0e2babe1f8da03d8e2b17ad06_r.jpg" alt="表3"></p><ol><li><p>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——<strong>数据冗余过大</strong></p></li><li><p>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——<strong>插入异常</strong></p><p>注１：根据三种关系完整性约束中<u>实体完整性</u>的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。</p><p>注２：<strong>码：关系中的某个属性或者某几个属性的组合，用于区分每个元组</strong>（可以把“元组”理解为一张表中的每条记录，也就是每一行）<strong>。</strong></p></li><li><p>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong></p></li><li><p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。</p></li></ol><p>正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</p><p><strong>第二范式（2NF）</strong>在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解2NF对1NF进行了哪些改进即可。其改进是，<strong>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</strong>。接下来对这句话中涉及到的四个概念——<strong>“函数依赖”</strong>、<strong>“码”</strong>、<strong>“非主属性”</strong>、与<strong>“部分函数依赖”</strong>进行一下解释。</p><p><strong>函数依赖</strong> 我们可以这么理解（但并不是特别严格的定义）：<strong>若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y</strong>。也就是说，在数据表中，<u>不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同</u>。这也就是“函数依赖”名字的由来，类似于函数关系 y &#x3D; f(x)，在x的值确定的情况下，y的值一定是确定的。</p><p>例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说<strong>姓名函数依赖于学号</strong>，写作 <strong>学号 → 姓名</strong>。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如：</p><ul><li>系名 → 系主任</li><li>学号 → 系主任</li><li>（学号，课名） → 分数</li></ul><p>但以下函数依赖关系则不成立：</p><ul><li>学号 → 课名</li><li>学号 → 分数</li><li>课名 → 系主任</li><li>（学号，课名） → 姓名</li></ul><p>从“函数依赖”这个概念展开，还会有三个概念： <strong>完全函数依赖</strong> 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X <strong>完全函数依赖</strong>，记作 X F→ Y。（那个F应该写在箭头的正上方，没办法打出来……，正确的写法如<strong>图1</strong>）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/12513de20079d12b99d946072df7311a_b.jpg" alt="img"></p><p>图1</p><p>例如：</p><ul><li>学号 F→ 姓名</li><li>（学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）</li></ul><p><strong>部分函数依赖</strong> 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y，如<strong>图2</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/10b52b39b18b8ea9fb17b46babf4d20f_b.jpg" alt="img"></p><p>图2</p><p>例如：</p><ul><li>（学号，课名） P→ 姓名</li></ul><p><strong>传递函数依赖</strong> 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，如<strong>图3</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/51f8105fbbe92adaa3e343ea2db3bf49_b.jpg" alt="img"></p><p><strong>码</strong> 设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都<strong>完全函数</strong>依赖于 K（这个“完全”不要漏了），那么我们称 K 为<strong>候选码</strong>，简称为<strong>码</strong>。在实际中我们通常可以理解为：<strong>假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。</strong>一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为<strong>主码</strong>）</p><p>例如： 对于表3，<strong>（学号、课名）</strong>这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p><p><strong>主属性</strong></p><p>包含在任意一个码中的属性称为主属性。</p><p><strong>非主属性</strong> 不包含在任何一个码中的属性称为非主属性。</p><p>例如： 对于表3，主属性就有两个，<strong>学号</strong> 与 <strong>课名</strong>。其余的属性都是非主属性。</p><p>终于可以回过来看2NF了。首先，我们需要判断，表3是否符合2NF的要求？根据2NF的定义，判断的依据实际上就是看数据表中<strong>是否存在非主属性对于码的部分函数依赖</strong>。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：</p><p>第一步：找出数据表中所有的<strong>码</strong>。 第二步：根据第一步所得到的码，找出所有的<strong>主属性</strong>。 第三步：数据表中，除去所有的主属性，剩下的就都是<strong>非主属性</strong>了。 第四步：查看是否存在非主属性对码的<strong>部分函数依赖</strong>。</p><p>对于表3，根据前面所说的四步，我们可以这么做： 第一步：</p><ol><li>查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。</li><li>查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。</li><li>……</li><li>查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。</li></ol><p>看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“<strong>完全</strong>函数依赖”）。</p><p><strong>图4</strong>表示了表中所有的函数依赖关系：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/51e2689ac9416a91800e63101bee9db7_r.jpg" alt="img"></p><p>这一步完成以后，可以得到，表3的码只有一个，就是（学号、课名）。</p><p>第二步： 主属性有两个：<strong>学号</strong> 与 <strong>课名</strong></p><p>第三步： 非主属性有四个：<strong>姓名</strong>、<strong>系名</strong>、<strong>系主任</strong>、<strong>分数</strong></p><p><strong>第四步：</strong> 对于<strong>（学号，课名） → 姓名</strong>，有 <strong>学号 → 姓名</strong>，存在非主属性 <strong>姓名</strong> 对码<strong>（学号，课名）</strong>的部分函数依赖。 对于<strong>（学号，课名） → 系名</strong>，有 <strong>学号 → 系名</strong>，存在非主属性 系<strong>名</strong> 对码<strong>（学号，课名）</strong>的部分函数依赖。 对于<strong>（学号，课名） → 系主任</strong>，有 <strong>学号 → 系主任</strong>，存在非主属性 对码<strong>（学号，课名）</strong>的部分函数依赖。</p><p>所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p><p>为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”<strong>模式分解</strong>“。模式分解的方法不是唯一的，以下是其中一种方法： 选课（学号，课名，分数） 学生（学号，姓名，系名，系主任）</p><p>我们先来判断以下，<strong>选课</strong>表与<strong>学生</strong>表，是否符合了2NF的要求？</p><p>对于<strong>选课</strong>表，其码是<strong>（学号，课名）</strong>，主属性是<strong>学号</strong>和<strong>课名</strong>，非主属性是<strong>分数</strong>，<strong>学号</strong>确定，并不能唯一确定<strong>分数</strong>，<strong>课名</strong>确定，也不能唯一确定<strong>分数</strong>，所以不存在非主属性<strong>分数</strong>对于码 <strong>（学号，课名）</strong>的部分函数依赖，所以此表符合2NF的要求。</p><p>对于<strong>学生</strong>表，其码是<strong>学号，</strong>主属性是<strong>学号</strong>，非主属性是<strong>姓名、系名</strong>和<strong>系主任</strong>，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。</p><p><strong>图5</strong>表示了模式分解以后的新的函数依赖关系</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/2f4b4a887f6a61674a49d03d79e3fe17_r.jpg" alt="img"></p><p>表4表示了模式分解以后新的数据</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic4.zhimg.com/46b18d25eb2a0da487e4f1b4520c979f_r.jpg" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/e3d91cd4a91ae656c9bf874ae298836a_r.jpg" alt="img"></p><p>（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）</p><p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p><ol><li>李小明转系到法律系 只需要修改一次李小明对应的系的值即可。——有改进</li><li>数据冗余是否减少了？ 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li><li>删除某个系中所有的学生记录 该系的信息仍然全部丢失。——无改进</li><li>插入一个尚无学生的新系的信息。 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li></ol><p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。</p><p><strong>第三范式（3NF）</strong> <strong>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</strong>。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p><p>接下来我们看看表4中的设计，是否符合3NF的要求。</p><p>对于<strong>选课</strong>表，主码为（学号，课名），主属性为<strong>学号</strong>和<strong>课名，</strong>非主属性只有一个，为分数，不可能存在传递函数依赖，所以<strong>选课</strong>表的设计，符合3NF的要求。</p><p>对于<strong>学生</strong>表，主码为<strong>学号</strong>，主属性为<strong>学号</strong>，非主属性为<strong>姓名</strong>、<strong>系名</strong>和<strong>系主任</strong>。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖，所以<strong>学生</strong>表的设计，不符合3NF的要求。。</p><p>为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式： 选课（学号，课名，分数） 学生（学号，姓名，系名） 系（系名，系主任）</p><p>对于<strong>选课</strong>表，符合3NF的要求，之前已经分析过了。</p><p>对于<strong>学生</strong>表，码为<strong>学号</strong>，主属性为<strong>学号</strong>，非主属性为<strong>系名</strong>，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。</p><p>对于<strong>系</strong>表，码为<strong>系名</strong>，主属性为<strong>系名</strong>，非主属性为<strong>系主任</strong>，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。。</p><p>新的函数依赖关系如图6</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/5b20707ff3d9afb51ef7bfda726c3e34_r.jpg" alt="img"></p><p>新的数据表如表5</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/cbb6b2658e4ba90a895f94ef5823d52a_r.jpg" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/253c5d60c6ebcbb257cf8c3025399cf2_r.jpg" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/2ae1f9ab577ce5eec0d0e028a749bc71_b.jpg" alt="img"></p><p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p><ol><li>删除某个系中所有的学生记录 该系的信息不会丢失。——有改进</li><li>插入一个尚无学生的新系的信息。 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li><li>数据冗余更加少了。——有改进</li></ol><p><strong>结论</strong> 由此可见，符合3NF要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p><p><strong>BCNF范式</strong> 要了解 BCNF 范式，那么先看这样一个问题： 若：</p><ol><li>某公司有若干个仓库；</li><li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li><li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li></ol><p>那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p><p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量 码：（管理员，物品名），（仓库名，物品名） 主属性：仓库名、管理员、物品名 非主属性：数量 ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p><p>基于此关系模式的关系（具体的数据）可能如图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic3.zhimg.com/68d080d437732aad8cfe451b427849d6_r.jpg" alt="img"></p><p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p><ol><li>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li><li>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li><li>如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li></ol><p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p><p>造成此问题的原因：存在着<strong>主属性</strong>对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p><p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p><p>仓库（仓库名，管理员） 库存（仓库名，物品名，数量）</p><p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p><p>以上就是关于 BCNF 的解释。</p><h1 id="几个典型习题及其解答吧。"><a href="#几个典型习题及其解答吧。" class="headerlink" title="几个典型习题及其解答吧。"></a>几个典型习题及其解答吧。</h1><p>问题1：</p><p><a target="_blank" rel="noopener" href="http://www.zhihu.com/people/li-de-zhu-84">李德竹</a> ：老师您好，我看了您关于数据库范式的回答，有一点不太理解，就是关于码的定义，如果除K之外的所有属性都完全函数依赖于K时才能称K为码，那么在判断2NF时又怎么会存在非主属性对码的部分函数依赖这种情况？希望老师有时间能指点一下，谢谢</p><p>我 ：在“码”的定义中，除 K 之外的所有属性应该看成是一个集合 U（也就是一个整体），也就是说，只有 K 能够完全函数决定 U 中的每一个属性，那么 K 才是码。如果 K 只是能够完全函数决定 U 中的一部分属性，而不能完全函数决定另外一部分属性，那么 K 不是码。</p><p>比如有关系模式 R (Sno, Sname, Cno, Cname, Sdept, Sloc, Grade)，其中函数依赖集为 F&#x3D; {Sno → Sname, Sno → Sdept, Sdept → Sloc，Sno → Sloc, Cno → Cname, (Sno, Cno) → Grade }</p><p>那么 R 中的码只能是 (Sno, Cno)，Sno 或 Cno 并不能完全函数决定除 Sno &#x2F; Cno 之外的所有其他属性（其实就是不能决定 Grade )，所以单独的 Sno 与 Cno 并不能作为码。</p><p>所以可得到主属性：Sno, Cno</p><p>非主属性：Sname, Cname, Sdept, Sloc, Grade</p><p>R 中存在非主属性 Cname 对于码 (Sno, Cno) 的部分函数依赖 (Cno → Cname) 。（还有很多别的例子就不一一列举了）。所以 R 不符合 2NF 的要求。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 问题2：</p><p>（推导过程比较复杂，直接在 SP3 上手写了，请忽略难看的字。）</p><p>已知有关系模式 R(A, B, C, D)，已知有函数依赖集：{(A, B)→C, C→D D→A}，问关系模式 R 最高支持第几范式？</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/fe2721b0fe0b75097a863e653bcc7738_r.jpg" alt="img"></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>问题3：</p><p>已知有关系模式R(A, B, C, D)，已知有函数依赖集：{A→B, A→C, A→ D, B→D, (B, C)→A }。问关系模式 R 最高支持第几范式？</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/93b184d5a6dd2d51d8434e48fc7e5455_r.jpg" alt="img"></p><h1 id="第一范式、第二范式、第三范式"><a href="#第一范式、第二范式、第三范式" class="headerlink" title="第一范式、第二范式、第三范式"></a>第一范式、第二范式、第三范式</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>实体</strong>：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。</p><p><strong>属性</strong>：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，<strong>属性又是个物理概念，属性可以看作是“表的一列”</strong>。</p><p><strong>元组</strong>：表中的<strong>一行就是一个元组</strong>。</p><p><strong>分量</strong>：元组的<strong>某个属性值</strong>。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。</p><p><strong>码</strong>：<strong>表中可以唯一确定一个元组的某个属性</strong>（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。</p><p><strong>全码</strong>：如果一个码包含了所有的属性，这个码就是全码。</p><p><strong>主属性</strong>：<u>一个属性只要在任何一个候选码中出现过，这个属性就是主属性。</u></p><p><strong>非主属性</strong>：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</p><p><strong>外码</strong>：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。</p><p><strong>第一范式</strong>：第一范式列不能再分。</p><p><strong>第二范式</strong>：第二范式建立在第一范式的基础上，非主属性完全依赖于码。</p><p>简单说：消除部分依赖。</p><p>（什么是码？） 表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。<strong>主码</strong>可以包含多个属性。</p><p>要理解第二第三范式需要理解完全函数依赖、部分函数依赖、传递函数依赖。</p><p><strong>完全函数依赖</strong></p><p>定义：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><p>比如通过学号-&gt;姓名</p><p><strong>部分函数依赖</strong></p><p>定义：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p><p>需要借用知乎刘慰教师的例子用一下，自己也理解了很长时间。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/0099ee963b99b2a08f78af70bbcab552.png"></p><p>码用(学号+课程),为什么要加课程呢？因为不同课程成绩是通过学号查不出来的。</p><p>不过用(学号+课程)当作码是不是有些问题？</p><p>(学号+课程)-&gt;姓名，但是学号-&gt;姓名</p><p>(学号+课程)-&gt;系名，但是学号-&gt;系名</p><p>(学号+课程)-&gt;系主任，但是学号-&gt;系主任</p><p>这个就是部分依赖，说实话我看定义一脸懵逼。</p><p>要是上面那张表符合第二范式。需要将表拆分为两张表。</p><p>一张是 学号、课程、分数表</p><p>另外一张是 学号、姓名、系名、系主任表</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/94a4230520a842bf949eb83d490ec24e.png"></p><hr><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rl529014/article/details/48391465">https://blog.csdn.net/rl529014/article/details/48391465</a></p></blockquote><p>采用这位大佬的例子<br>在关系R(学号 ,宿舍, 费用)中，(学号)-&gt;(宿舍),宿舍！&#x3D;学号，(宿舍)-&gt;(费用),费用!&#x3D;宿舍，所以符合传递函数的要求</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>满足第二范式的条件下不存在传递函数依赖。</p><p>要满足第三范式，在分成两张表的时候第二张表还是有问题?</p><p>学号-&gt;系名，系名-&gt;系主任 传递依赖。</p><p>需要将系名和系主任另外新建一张表。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/dfe5d8f3dcb41d4e1c7eebd4ee8f3335.png"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>第一范式：简单说 列不能再分</p><p>第二范式：简单说 建立在第一范式基础上，消除部分依赖</p><p>第三范式：简单说 建立在第二范式基础上，消除传递依赖。</p><hr><p>码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。</p><p>主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。</p><p>非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</p><h4 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h4><blockquote><p><a target="_blank" rel="noopener" href="https://www.2cto.com/database/201404/290140.html">https://www.2cto.com/database/201404/290140.html</a></p></blockquote><p>BCNF是3NF的改进形式</p><p>一个满足BCNF的关系模式的条件:</p><p>1.所有非主属性对每一个码都是完全函数依赖。</p><p>2.所有的主属性对每一个不包含它的码,也是完全函数依赖。</p><p>3.没有任何属性完全函数依赖于非码的任何一组属性。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/e5b36673ca3d55743d70189ab70030ab.png"></p><p>如上表</p><p>(仓库名，管理员)-&gt;(物品名，数量)</p><p>(管理员，物品名)-&gt;(仓库名，数量)</p><p>但是(仓库名)-&gt;(管理员) 不满足第二条</p><p>所以需要改成两种表：</p><p>第一张：仓库名，管理员</p><p>第二张：仓库名，物品名，数量</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="tag_share"><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/28/%E5%B7%A5%E4%BD%9C/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/%E6%B3%95%E5%BE%8B%E5%90%88%E8%A7%84/2.1%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86-%E5%95%86%E4%B8%9A%E9%93%B6%E8%A1%8C%E8%A1%A8%E5%A4%96%E4%B8%9A%E5%8A%A1%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2.风险管理-商业银行表外业务风险管理办法</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/27/%E8%BD%AF%E8%80%83/7.%E6%96%87%E8%80%81%E5%B8%88-%E5%AE%89%E5%85%A8%E6%80%A7%E7%9F%A5%E8%AF%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/99.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">7.文老师-安全性知识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/11.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">民工的自我修养</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">600</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">234</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">第一范式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E4%B9%A0%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E7%AD%94%E5%90%A7%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">几个典型习题及其解答吧。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%E3%80%81%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E3%80%81%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">第一范式、第二范式、第三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">传递函数依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">第三范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BCNF%E8%8C%83%E5%BC%8F"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">BCNF范式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/27/%E5%B7%A5%E4%BD%9C/%E8%B4%A2%E5%8A%A1%E8%B5%84%E9%87%91%E9%83%A8/20240110%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96/5.2/" title="5.2信贷资产证券化中受托机构的工作流程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="5.2信贷资产证券化中受托机构的工作流程"></a><div class="content"><a class="title" href="/2024/02/27/%E5%B7%A5%E4%BD%9C/%E8%B4%A2%E5%8A%A1%E8%B5%84%E9%87%91%E9%83%A8/20240110%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96/5.2/" title="5.2信贷资产证券化中受托机构的工作流程">5.2信贷资产证券化中受托机构的工作流程</a><time datetime="2024-02-27T01:07:23.491Z" title="发表于 2024-02-27 09:07:23">2024-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/26/CPA%E8%AF%BE%E7%A8%8B/%E4%BC%9A%E8%AE%A1/4.1%E6%97%A0%E5%BD%A2%E8%B5%84%E4%BA%A7%E7%9A%84%E7%A1%AE%E8%AE%A4%E5%92%8C%E5%88%9D%E5%A7%8B%E8%AE%A1%E9%87%8F/" title="4.1无形资产的确认和初始计量"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="4.1无形资产的确认和初始计量"></a><div class="content"><a class="title" href="/2024/02/26/CPA%E8%AF%BE%E7%A8%8B/%E4%BC%9A%E8%AE%A1/4.1%E6%97%A0%E5%BD%A2%E8%B5%84%E4%BA%A7%E7%9A%84%E7%A1%AE%E8%AE%A4%E5%92%8C%E5%88%9D%E5%A7%8B%E8%AE%A1%E9%87%8F/" title="4.1无形资产的确认和初始计量">4.1无形资产的确认和初始计量</a><time datetime="2024-02-26T11:40:23.508Z" title="发表于 2024-02-26 19:40:23">2024-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/26/CPA%E8%AF%BE%E7%A8%8B/%E4%BC%9A%E8%AE%A1/3.3%E5%9B%BA%E5%AE%9A%E8%B5%84%E4%BA%A7%E7%9A%84%E5%A4%84%E7%BD%AE/" title="3.3固定资产的处置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3.3固定资产的处置"></a><div class="content"><a class="title" href="/2024/02/26/CPA%E8%AF%BE%E7%A8%8B/%E4%BC%9A%E8%AE%A1/3.3%E5%9B%BA%E5%AE%9A%E8%B5%84%E4%BA%A7%E7%9A%84%E5%A4%84%E7%BD%AE/" title="3.3固定资产的处置">3.3固定资产的处置</a><time datetime="2024-02-26T11:32:26.374Z" title="发表于 2024-02-26 19:32:26">2024-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/26/%E5%B7%A5%E4%BD%9C/%E8%B4%A2%E5%8A%A1%E8%B5%84%E9%87%91%E9%83%A8/20240110%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96/5.1/" title="5.1SPV和受托机构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="5.1SPV和受托机构"></a><div class="content"><a class="title" href="/2024/02/26/%E5%B7%A5%E4%BD%9C/%E8%B4%A2%E5%8A%A1%E8%B5%84%E9%87%91%E9%83%A8/20240110%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96/5.1/" title="5.1SPV和受托机构">5.1SPV和受托机构</a><time datetime="2024-02-26T09:01:20.572Z" title="发表于 2024-02-26 17:01:20">2024-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/26/%E5%B7%A5%E4%BD%9C/%E8%B4%A2%E5%8A%A1%E8%B5%84%E9%87%91%E9%83%A8/20240110%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96/3.4%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96%E5%8F%91%E8%B5%B7%E4%BA%BA%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%902/" title="3.4资产证券化发起人案例分析2-住房贷款"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/cover/2017GuiDao/85.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="3.4资产证券化发起人案例分析2-住房贷款"></a><div class="content"><a class="title" href="/2024/02/26/%E5%B7%A5%E4%BD%9C/%E8%B4%A2%E5%8A%A1%E8%B5%84%E9%87%91%E9%83%A8/20240110%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96/3.4%E8%B5%84%E4%BA%A7%E8%AF%81%E5%88%B8%E5%8C%96%E5%8F%91%E8%B5%B7%E4%BA%BA%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%902/" title="3.4资产证券化发起人案例分析2-住房贷款">3.4资产证券化发起人案例分析2-住房贷款</a><time datetime="2024-02-26T07:53:27.157Z" title="发表于 2024-02-26 15:53:27">2024-02-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.1},options:{renderActions:{findScript:[10,t=>{for(const n of document.querySelectorAll('script[type^="math/tex"]')){var e=!!n.type.match(/; *mode=display/),e=new t.options.MathItem(n.textContent,t.inputJax[0],e),a=document.createTextNode("");n.parentNode.replaceChild(a,n),e.start={node:a,delim:"",n:0},e.end={node:a,delim:"",n:0},t.math.push(e)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t.hasAttribute("display")?btf.wrap(t,"div",{class:"mathjax-overflow"}):btf.wrap(t,"span",{class:"mathjax-overflow"})})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script></div></div></body></html>